<?xml version="1.0"?>
<root ptr="0xb0726b0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa8993000"><page ptr="0xa8993000" next="0xa899315c" prev="(nil)" upper="0xb0726b0" lower="0xa8996000"><header ptr="0xa8996000" next="0xa8995000" prev="(nil)" upper="0xa8993000" lower="0xa8997000"><txt ptr="0xa8997000" next="(nil)" prev="(nil)" upper="0xa8996000" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt></header><body ptr="0xa8995000" next="0xa8998000" prev="0xa8996000" upper="0xa8993000" lower="0xa99bc480"><section ptr="0xa99bc480" next="(nil)" prev="(nil)" upper="0xa8995000" lower="0xa99a50d0" follow="0xa99bc680"><column ptr="0xa99a50d0" next="0xa99a5134" prev="(nil)" upper="0xa99bc480" lower="0xa999c968"><body ptr="0xa999c968" next="(nil)" prev="(nil)" upper="0xa99a50d0" lower="0xa8997bd0"><txt ptr="0xa8997bd0" next="0xa8997d80" prev="(nil)" upper="0xa999c968" lower="(nil)">STRUCTURE<Text nLength="9" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa8997d80" next="0xa8997e10" prev="0xa8997bd0" upper="0xa999c968" lower="(nil)">阶乘<Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa8997e10" next="0xa8997ea0" prev="0xa8997d80" upper="0xa999c968" lower="(nil)">阶乘的位数（仅有位数）<Text nLength="11" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa8997ea0" next="0xa8997f30" prev="0xa8997e10" upper="0xa999c968" lower="(nil)">pku 1423 HDU 1018<Text nLength="17" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa8997f30" next="0xa99bd004" prev="0xa8997ea0" upper="0xa999c968" lower="(nil)">double e=2.7182818284590452354;<Text nLength="31" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd004" next="0xa99bd094" prev="0xa8997f30" upper="0xa999c968" lower="(nil)">double pi=atan2(0.0,-1.0);<Text nLength="26" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd094" next="0xa99bd124" prev="0xa99bd004" upper="0xa999c968" lower="(nil)"><Finish/></txt><txt ptr="0xa99bd124" next="0xa99bd1b4" prev="0xa99bd094" upper="0xa999c968" lower="(nil)">int count_number_bit(int n){<Text nLength="28" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd1b4" next="0xa99bd244" prev="0xa99bd124" upper="0xa999c968" lower="(nil)">*double sum=0;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="13" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd244" next="0xa99bd2d4" prev="0xa99bd1b4" upper="0xa999c968" lower="(nil)">*if(n&lt;100000){<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="13" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd2d4" next="0xa99bd364" prev="0xa99bd244" upper="0xa999c968" lower="(nil)">*for(int i=1;i&lt;=n;i++)<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="21" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd364" next="0xa99bd3f4" prev="0xa99bd2d4" upper="0xa999c968" lower="(nil)">**sum+=log10(i*1.0);<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="1" nType="POR_TABLEFT"/><Text nLength="18" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd3f4" next="0xa99bd484" prev="0xa99bd364" upper="0xa999c968" lower="(nil)">*}else{<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="6" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd484" next="0xa99bd514" prev="0xa99bd3f4" upper="0xa999c968" lower="(nil)">*sum=log10(sqrt(2*pi*n))+n*log10(n/e);<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="37" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd514" next="0xa99bd5a4" prev="0xa99bd484" upper="0xa999c968" lower="(nil)">*}<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd5a4" next="0xa99bd634" prev="0xa99bd514" upper="0xa999c968" lower="(nil)">*int ans=(int)sum;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="17" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd634" next="0xa99bd6c4" prev="0xa99bd5a4" upper="0xa999c968" lower="(nil)">*if(ans&lt;=sum)ans++;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="18" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd6c4" next="0xa99bd754" prev="0xa99bd634" upper="0xa999c968" lower="(nil)">*return ans;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="11" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd754" next="0xa99bd7e4" prev="0xa99bd6c4" upper="0xa999c968" lower="(nil)">} <Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd7e4" next="0xa99bd874" prev="0xa99bd754" upper="0xa999c968" lower="(nil)">阶乘0的个数<Text nLength="2" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd874" next="0xa99bd904" prev="0xa99bd7e4" upper="0xa999c968" lower="(nil)">其实0的个数至于5的个数有关，因此需要分解n!中5的个数<Text nLength="1" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="5" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="12" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="2" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd904" next="0xa99bd994" prev="0xa99bd874" upper="0xa999c968" lower="(nil)">__int64 count_zero(__int64 m){<Text nLength="30" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bd994" next="0xa99bda24" prev="0xa99bd904" upper="0xa999c968" lower="(nil)">*__int64 sum=0;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="14" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bda24" next="0xa99bdab4" prev="0xa99bd994" upper="0xa999c968" lower="(nil)">*while(m)<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="8" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bdab4" next="(nil)" prev="0xa99bda24" upper="0xa999c968" lower="(nil)">**sum+=(m/=5);<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="1" nType="POR_TABLEFT"/><Text nLength="12" nType="POR_TXT"/><LineBreak/><Finish/></txt></body></column><column ptr="0xa99a5134" next="0xa99a5198" prev="0xa99a50d0" upper="0xa99bc480" lower="0xa999c9c8"><body ptr="0xa999c9c8" next="(nil)" prev="(nil)" upper="0xa99a5134" lower="0xa99bdb44"><txt ptr="0xa99bdb44" next="0xa99bdbd4" prev="(nil)" upper="0xa999c9c8" lower="(nil)">*return sum;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="11" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bdbd4" next="0xa99bdc64" prev="0xa99bdb44" upper="0xa999c9c8" lower="(nil)">}<Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bdc64" next="0xa99bdcf4" prev="0xa99bdbd4" upper="0xa999c9c8" lower="(nil)">阶乘最后非0位<Text nLength="5" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bdcf4" next="0xa99bdd84" prev="0xa99bdc64" upper="0xa999c9c8" lower="(nil)">const int mod[20]= {1,1,2,6,4,2,2,4,2,8,4,4,8,4,6,8,8,6,8,2}; <Text nLength="18" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Text nLength="43" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bdd84" next="0xa99bde14" prev="0xa99bdcf4" upper="0xa999c9c8" lower="(nil)">int lastdigit(char* buf){ <Text nLength="26" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bde14" next="0xa99be1b8" prev="0xa99bdd84" upper="0xa999c9c8" lower="(nil)">    int len=strlen(buf),a[MAXN],i,c,ret=1; <Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="39" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be1b8" next="0xa99be248" prev="0xa99bde14" upper="0xa999c9c8" lower="(nil)">    if (len==1) return mod[buf[0]-'0']; <Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="36" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be248" next="0xa99be2d8" prev="0xa99be1b8" upper="0xa999c9c8" lower="(nil)">    <Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be2d8" next="0xa99be368" prev="0xa99be248" upper="0xa999c9c8" lower="(nil)">    for (i=0;i&lt;len;i++) <Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="20" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be368" next="0xa99be3f8" prev="0xa99be2d8" upper="0xa999c9c8" lower="(nil)">        a[i]=buf[len-1-i]-'0'; <Text nLength="1" nType="POR_TXT"/><Text nLength="7" nType="POR_TXT"/><Text nLength="23" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be3f8" next="0xa99be488" prev="0xa99be368" upper="0xa999c9c8" lower="(nil)">    for (;len;len-=!a[len-1]){ <Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="27" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be488" next="0xa99be518" prev="0xa99be3f8" upper="0xa999c9c8" lower="(nil)">        ret=ret*mod[a[1]%2*10+a[0]]%5; <Text nLength="1" nType="POR_TXT"/><Text nLength="7" nType="POR_TXT"/><Text nLength="31" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be518" next="0xa99be5a8" prev="0xa99be488" upper="0xa999c9c8" lower="(nil)">        for (c=0,i=len-1;i&gt;=0;i--) <Text nLength="1" nType="POR_TXT"/><Text nLength="7" nType="POR_TXT"/><Text nLength="27" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be5a8" next="0xa99be638" prev="0xa99be518" upper="0xa999c9c8" lower="(nil)">            c=c*10+a[i],a[i]=c/5,c%=5; <Text nLength="1" nType="POR_TXT"/><Text nLength="11" nType="POR_TXT"/><Text nLength="27" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be638" next="0xa99be6c8" prev="0xa99be5a8" upper="0xa999c9c8" lower="(nil)">    } <Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be6c8" next="0xa99be758" prev="0xa99be638" upper="0xa999c9c8" lower="(nil)">    return ret+ret%2*5; <Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="20" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be758" next="0xa99be7e8" prev="0xa99be6c8" upper="0xa999c9c8" lower="(nil)">}<Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be7e8" next="0xa99be878" prev="0xa99be758" upper="0xa999c9c8" lower="(nil)"><Finish/></txt><txt ptr="0xa99be878" next="0xa99be908" prev="0xa99be7e8" upper="0xa999c9c8" lower="(nil)">阶乘分解<Text nLength="4" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be908" next="0xa99be998" prev="0xa99be878" upper="0xa999c9c8" lower="(nil)">__int64 search_bit(__int64 n,__int64 m){<Text nLength="40" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99be998" next="0xa99bea28" prev="0xa99be908" upper="0xa999c9c8" lower="(nil)">*__int64 sum=0;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="14" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bea28" next="0xa99beab8" prev="0xa99be998" upper="0xa999c9c8" lower="(nil)">*while(n)sum+=(n/=m);<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="20" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99beab8" next="0xa99beb48" prev="0xa99bea28" upper="0xa999c9c8" lower="(nil)">*return sum;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="11" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99beb48" next="0xa99bebd8" prev="0xa99beab8" upper="0xa999c9c8" lower="(nil)">}<Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bebd8" next="0xa99bec68" prev="0xa99beb48" upper="0xa999c9c8" lower="(nil)">阶乘的位数（求各位数字）<Text nLength="6" nType="POR_TXT"/><Text nLength="5" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bec68" next="(nil)" prev="0xa99bebd8" upper="0xa999c9c8" lower="(nil)">高精度乘法<Text nLength="5" nType="POR_TXT"/><LineBreak/><Finish/></txt></body></column><column ptr="0xa99a5198" next="(nil)" prev="0xa99a5134" upper="0xa99bc480" lower="0xa999ca28"><body ptr="0xa999ca28" next="(nil)" prev="(nil)" upper="0xa99a5198" lower="0xa99becf8"><txt ptr="0xa99becf8" next="0xa99bed88" prev="(nil)" upper="0xa999ca28" lower="(nil)">阶乘素数分解<Text nLength="2" nType="POR_TXT"/><Text nLength="4" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bed88" next="0xa99bee18" prev="0xa99becf8" upper="0xa999ca28" lower="(nil)">N!的素数银子因子分解中的素数p的幂为[n/p]+[n/p^2]+[n/p^3]+…<Text nLength="2" nType="POR_TXT"/><Text nLength="13" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><Text nLength="6" nType="POR_TXT"/><LineBreak/><Text nLength="16" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bee18" next="0xa99beea8" prev="0xa99bed88" upper="0xa999ca28" lower="(nil)">乘方a^k<Text nLength="2" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99beea8" next="0xa99bef38" prev="0xa99bee18" upper="0xa999ca28" lower="(nil)">快速乘方(a^k)<Text nLength="4" nType="POR_TXT"/><Text nLength="5" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bef38" next="0xa99bf00c" prev="0xa99beea8" upper="0xa999ca28" lower="(nil)">int qkpower(int a,int k){<Text nLength="25" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf00c" next="0xa99bf09c" prev="0xa99bef38" upper="0xa999ca28" lower="(nil)">*int ans=1,temp=a;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="17" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf09c" next="0xa99bf12c" prev="0xa99bf00c" upper="0xa999ca28" lower="(nil)">*while(k){<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="9" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf12c" next="0xa99bf1bc" prev="0xa99bf09c" upper="0xa999ca28" lower="(nil)">**if(k&amp;1)ans*=temp;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="1" nType="POR_TABLEFT"/><Text nLength="17" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf1bc" next="0xa99bf24c" prev="0xa99bf12c" upper="0xa999ca28" lower="(nil)">**temp*=temp;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="1" nType="POR_TABLEFT"/><Text nLength="11" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf24c" next="0xa99bf2dc" prev="0xa99bf1bc" upper="0xa999ca28" lower="(nil)">**k&gt;&gt;=1; <Text nLength="1" nType="POR_TABLEFT"/><Text nLength="1" nType="POR_TABLEFT"/><Text nLength="7" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf2dc" next="0xa99bf36c" prev="0xa99bf24c" upper="0xa999ca28" lower="(nil)">*} <Text nLength="1" nType="POR_TABLEFT"/><Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf36c" next="0xa99bf3fc" prev="0xa99bf2dc" upper="0xa999ca28" lower="(nil)">*return ans; <Text nLength="1" nType="POR_TABLEFT"/><Text nLength="12" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf3fc" next="0xa99bf75c" prev="0xa99bf36c" upper="0xa999ca28" lower="(nil)">} <Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf75c" next="0xa99bf7ec" prev="0xa99bf3fc" upper="0xa999ca28" lower="(nil)">A 的B次方的首位数字<Text nLength="2" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="7" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf7ec" next="0xa99bf87c" prev="0xa99bf75c" upper="0xa999ca28" lower="(nil)">A^B=10^(A*log(B) ),即可以转化求10*（A*log(B)）的首位数字。<Text nLength="19" nType="POR_TXT"/><Text nLength="6" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="8" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Text nLength="6" nType="POR_TXT"/><Special nLength="0" nType="POR_MARGIN" rText=""/><LineBreak/><Finish/></txt><txt ptr="0xa99bf87c" next="0xa99bf90c" prev="0xa99bf7ec" upper="0xa999ca28" lower="(nil)">对于10^（X），X为一个实数，可以分解成一个整数加一个小数的和，X=Z+P。即 <Text nLength="2" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="2" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="14" nType="POR_TXT"/><LineBreak/><Text nLength="9" nType="POR_TXT"/><Text nLength="5" nType="POR_TXT"/><Text nLength="2" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_MARGIN" rText=""/><LineBreak/><Finish/></txt><txt ptr="0xa99bf90c" next="0xa99bf99c" prev="0xa99bf87c" upper="0xa999ca28" lower="(nil)">10*（X）=10^(Z+P)=10^Z+10^P,其中（0&lt;=P&lt;1）<Text nLength="3" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="20" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="6" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf99c" next="0xa99bfa2c" prev="0xa99bf90c" upper="0xa999ca28" lower="(nil)">显然这里的10^Z是不会影响到10*X的首位数字。<Text nLength="5" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="4" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="6" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="4" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="6" nType="POR_TXT"/><Special nLength="0" nType="POR_MARGIN" rText=""/><LineBreak/><Finish/></txt><txt ptr="0xa99bfa2c" next="0xa99bfabc" prev="0xa99bf99c" upper="0xa999ca28" lower="(nil)">int GetHighest(double a,double b){<Text nLength="34" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bfabc" next="0xa99bfb4c" prev="0xa99bfa2c" upper="0xa999ca28" lower="(nil)">    double intpart;<Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="15" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bfb4c" next="0xa99bfbdc" prev="0xa99bfabc" upper="0xa999ca28" lower="(nil)">    double fractpart = modf(b*log10(a),&amp;intpart);<Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="45" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bfbdc" next="0xa99bfc6c" prev="0xa99bfb4c" upper="0xa999ca28" lower="(nil)">    double temp=pow((double)10,fractpart);<Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="38" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bfc6c" next="0xa99bfcfc" prev="0xa99bfbdc" upper="0xa999ca28" lower="(nil)">    modf(temp,&amp;intpart);<Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="20" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bfcfc" next="(nil)" prev="0xa99bfc6c" upper="0xa999ca28" lower="(nil)">    return (int)intpart;  <Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Text nLength="22" nType="POR_TXT"/><LineBreak/><Finish/></txt></body></column></section></body><footer ptr="0xa8998000" next="(nil)" prev="0xa8995000" upper="0xa8993000" lower="0xa8997120"><txt ptr="0xa8997120" next="0xa8997090" prev="(nil)" upper="0xa8998000" lower="(nil)"><anchored><fly ptr="0xb73e758" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa8997240"><txt ptr="0xa8997240" next="0xa89971b0" prev="(nil)" upper="0xb73e758" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa89971b0" next="(nil)" prev="0xa8997240" upper="0xb73e758" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="1"/><LineBreak/><Finish/></txt></fly></anchored>V<Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa8997090" next="(nil)" prev="0xa8997120" upper="0xa8998000" lower="(nil)">er 04make by tiankonguse <Text nLength="4" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="8" nType="POR_TXT"/><Text nLength="11" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt></footer></page><page ptr="0xa899315c" next="0xa8993074" prev="0xa8993000" upper="0xb0726b0" lower="0xa89960c0"><header ptr="0xa89960c0" next="0xa897b618" prev="(nil)" upper="0xa899315c" lower="0xa8928c68"><txt ptr="0xa8928c68" next="(nil)" prev="(nil)" upper="0xa89960c0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt></header><body ptr="0xa897b618" next="0xa89980c0" prev="0xa89960c0" upper="0xa899315c" lower="0xa99bc680"><section ptr="0xa99bc680" next="(nil)" prev="(nil)" upper="0xa897b618" lower="0xa8999898" follow="0xa894be0c" precede="0xa99bc480"><column ptr="0xa8999898" next="0xa8999708" prev="(nil)" upper="0xa99bc680" lower="0xa9983250"><body ptr="0xa9983250" next="(nil)" prev="(nil)" upper="0xa8999898" lower="0xa99bfd8c"><txt ptr="0xa99bfd8c" next="0xa99bfe1c" prev="(nil)" upper="0xa9983250" lower="(nil)">}<Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bfe1c" next="0xa99bfeac" prev="0xa99bfd8c" upper="0xa9983250" lower="(nil)">二进制中一的个数<Text nLength="8" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bfeac" next="0xa99bff3c" prev="0xa99bfe1c" upper="0xa9983250" lower="(nil)">自底向上分治法O(5) <Text nLength="7" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="5" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99bff3c" next="0xa99c0010" prev="0xa99bfeac" upper="0xa9983250" lower="(nil)">unsigned countbits(unsigned x){<Text nLength="31" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0010" next="0xa99c00a0" prev="0xa99bff3c" upper="0xa9983250" lower="(nil)">unsigned mask[]={0x55555555,0x33333333, 0x0F0F0F0F,  0x00FF00FF, 0x0000FFFF};<Text nLength="40" nType="POR_TXT"/><LineBreak/><Text nLength="37" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c00a0" next="0xa99c0130" prev="0xa99c0010" upper="0xa9983250" lower="(nil)">*for(unsigned i=0,j=1;i&lt;5;i++,j&lt;&lt;=1)<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="35" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0130" next="0xa99c01c0" prev="0xa99c00a0" upper="0xa9983250" lower="(nil)">x=(x &amp; mask[i]) + ((x&gt;&gt;j) &amp; mask[i]);<Text nLength="37" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c01c0" next="0xa99c0250" prev="0xa99c0130" upper="0xa9983250" lower="(nil)">*return x;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="9" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0250" next="0xa99c02e0" prev="0xa99c01c0" upper="0xa9983250" lower="(nil)">} <Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c02e0" next="0xa99c0370" prev="0xa99c0250" upper="0xa9983250" lower="(nil)">复杂度为1的个数<Text nLength="4" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0370" next="0xa99c0400" prev="0xa99c02e0" upper="0xa9983250" lower="(nil)">从最低位扫描'1',每次扫描一个<Text nLength="6" nType="POR_TXT"/><Text nLength="4" nType="POR_TXT"/><Text nLength="6" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0400" next="0xa99c0490" prev="0xa99c0370" upper="0xa9983250" lower="(nil)">unsigned _countbits(unsigned x){<Text nLength="32" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0490" next="0xa99c0520" prev="0xa99c0400" upper="0xa9983250" lower="(nil)">*unsigned n=0;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="13" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0520" next="0xa99c05b0" prev="0xa99c0490" upper="0xa9983250" lower="(nil)">*while(++n , x&amp;=x-1);<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="20" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c05b0" next="0xa99c0640" prev="0xa99c0520" upper="0xa9983250" lower="(nil)">*return n;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="9" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0640" next="0xa99c06d0" prev="0xa99c05b0" upper="0xa9983250" lower="(nil)">} <Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c06d0" next="0xa99c0760" prev="0xa99c0640" upper="0xa9983250" lower="(nil)">朴素的算法O(32)<Text nLength="5" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="5" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0760" next="0xa99c07f0" prev="0xa99c06d0" upper="0xa9983250" lower="(nil)">unsigned __countbits(unsigned x){<Text nLength="33" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c07f0" next="0xa99c0880" prev="0xa99c0760" upper="0xa9983250" lower="(nil)">*unsigned n=0;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="13" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0880" next="0xa99c0910" prev="0xa99c07f0" upper="0xa9983250" lower="(nil)">*while(n+=(x&amp;1) , x&gt;&gt;=1);<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="24" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0910" next="0xa99c09a0" prev="0xa99c0880" upper="0xa9983250" lower="(nil)">*return n;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="9" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c09a0" next="0xa99c0d00" prev="0xa99c0910" upper="0xa9983250" lower="(nil)">}<Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0d00" next="0xa99c0d90" prev="0xa99c09a0" upper="0xa9983250" lower="(nil)">树根<Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0d90" next="0xa99c0e20" prev="0xa99c0d00" upper="0xa9983250" lower="(nil)">root(a+b)=root(root(a) + root(b)) <Text nLength="34" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0e20" next="(nil)" prev="0xa99c0d90" upper="0xa9983250" lower="(nil)">root(a*b)=root(root(a) * root(b)) <Text nLength="34" nType="POR_TXT"/><LineBreak/><Finish/></txt></body></column><column ptr="0xa8999708" next="0xa89996a4" prev="0xa8999898" upper="0xa99bc680" lower="0xa99831f0"><body ptr="0xa99831f0" next="(nil)" prev="(nil)" upper="0xa8999708" lower="0xa99c0eb0"><txt ptr="0xa99c0eb0" next="0xa99c0f40" prev="(nil)" upper="0xa99831f0" lower="(nil)">root(a)=root(root(a/10) + a%10) <Text nLength="32" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0f40" next="0xa99c2014" prev="0xa99c0eb0" upper="0xa99831f0" lower="(nil)">一、n的树根<Text nLength="2" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><Special nLength="0" nType="POR_MARGIN" rText=""/><LineBreak/><Finish/></txt><txt ptr="0xa99c2014" next="0xa99c20a4" prev="0xa99c0f40" upper="0xa99831f0" lower="(nil)">模拟 <Text nLength="2" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c20a4" next="0xa99c2134" prev="0xa99c2014" upper="0xa99831f0" lower="(nil)">int root(int n){<Text nLength="16" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2134" next="0xa99c21c4" prev="0xa99c20a4" upper="0xa99831f0" lower="(nil)">*while(n&gt;9)n=n%10+n/10;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="22" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c21c4" next="0xa99c2254" prev="0xa99c2134" upper="0xa99831f0" lower="(nil)">*return n;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="9" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2254" next="0xa99c22e4" prev="0xa99c21c4" upper="0xa99831f0" lower="(nil)">} <Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c22e4" next="0xa99c2374" prev="0xa99c2254" upper="0xa99831f0" lower="(nil)">找规律 <Text nLength="3" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2374" next="0xa99c2404" prev="0xa99c22e4" upper="0xa99831f0" lower="(nil)">int _root(int n){<Text nLength="17" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2404" next="0xa99c2494" prev="0xa99c2374" upper="0xa99831f0" lower="(nil)">*return n?(n+8)%9+1:0;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="21" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2494" next="0xa99c2524" prev="0xa99c2404" upper="0xa99831f0" lower="(nil)">} <Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2524" next="0xa99c25b4" prev="0xa99c2494" upper="0xa99831f0" lower="(nil)">高精度<Text nLength="3" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c25b4" next="0xa99c2644" prev="0xa99c2524" upper="0xa99831f0" lower="(nil)">int __root(char *p){<Text nLength="20" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2644" next="0xa99c26d4" prev="0xa99c25b4" upper="0xa99831f0" lower="(nil)">*int n=0;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="8" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c26d4" next="0xa99c2764" prev="0xa99c2644" upper="0xa99831f0" lower="(nil)">*for(int i=0;p[i];i++)n+=p[i]-'0';<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="33" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2764" next="0xa99c27f4" prev="0xa99c26d4" upper="0xa99831f0" lower="(nil)">*return n?(n+8)%9+1:0;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="21" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c27f4" next="0xa99c2884" prev="0xa99c2764" upper="0xa99831f0" lower="(nil)">} <Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2884" next="0xa99c2914" prev="0xa99c27f4" upper="0xa99831f0" lower="(nil)">二、n^n的树根<Text nLength="2" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><Special nLength="0" nType="POR_MARGIN" rText=""/><LineBreak/><Finish/></txt><txt ptr="0xa99c2914" next="0xa99c29a4" prev="0xa99c2884" upper="0xa99831f0" lower="(nil)">找规律<Text nLength="3" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c29a4" next="0xa99c2a34" prev="0xa99c2914" upper="0xa99831f0" lower="(nil)">int treeroot(int n){<Text nLength="20" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2a34" next="0xa99c2ac4" prev="0xa99c29a4" upper="0xa99831f0" lower="(nil)">*int tree[19]={9,1,4,9,4,2,9,7,1,9,1,5,9,4,7,9,7,8};<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="51" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2ac4" next="0xa99c2b54" prev="0xa99c2a34" upper="0xa99831f0" lower="(nil)">*return tree[n%18];<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="18" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2b54" next="0xa99c2be4" prev="0xa99c2ac4" upper="0xa99831f0" lower="(nil)">} <Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2be4" next="0xa99c2c74" prev="0xa99c2b54" upper="0xa99831f0" lower="(nil)">模拟见a^b的树根<Text nLength="3" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2c74" next="0xa99c2d04" prev="0xa99c2be4" upper="0xa99831f0" lower="(nil)">三、 a^b的树根<Text nLength="2" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><Special nLength="0" nType="POR_KERN" rText=""/><Text nLength="3" nType="POR_TXT"/><Special nLength="0" nType="POR_MARGIN" rText=""/><LineBreak/><Finish/></txt><txt ptr="0xa99c2d04" next="0xa99c2d94" prev="0xa99c2c74" upper="0xa99831f0" lower="(nil)">循环搜索<Text nLength="4" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2d94" next="0xa99c2e24" prev="0xa99c2d04" upper="0xa99831f0" lower="(nil)">int _treeroot(int a,int b){<Text nLength="27" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2e24" next="(nil)" prev="0xa99c2d94" upper="0xa99831f0" lower="(nil)">*a=root(a);<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="10" nType="POR_TXT"/><LineBreak/><Finish/></txt></body></column><column ptr="0xa89996a4" next="(nil)" prev="0xa8999708" upper="0xa99bc680" lower="0xa9983370"><body ptr="0xa9983370" next="(nil)" prev="(nil)" upper="0xa89996a4" lower="0xa99c2eb4"><txt ptr="0xa99c2eb4" next="0xa99c2f44" prev="(nil)" upper="0xa9983370" lower="(nil)">*int ans=1;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="10" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c2f44" next="0xa99c32e8" prev="0xa99c2eb4" upper="0xa9983370" lower="(nil)">*while(b--)ans=root(ans*a);<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="26" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c32e8" next="0xa99c3378" prev="0xa99c2f44" upper="0xa9983370" lower="(nil)">*return ans;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="11" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3378" next="0xa99c3408" prev="0xa99c32e8" upper="0xa9983370" lower="(nil)">} <Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3408" next="0xa99c3498" prev="0xa99c3378" upper="0xa9983370" lower="(nil)">二进制法<Text nLength="4" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3498" next="0xa99c3528" prev="0xa99c3408" upper="0xa9983370" lower="(nil)">int mytreeroot(int a,int b){<Text nLength="28" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3528" next="0xa99c35b8" prev="0xa99c3498" upper="0xa9983370" lower="(nil)">*a=root(a);<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="10" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c35b8" next="0xa99c3648" prev="0xa99c3528" upper="0xa9983370" lower="(nil)">*int t=a,ans=1;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="14" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3648" next="0xa99c36d8" prev="0xa99c35b8" upper="0xa9983370" lower="(nil)">*while(b){<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="9" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c36d8" next="0xa99c3768" prev="0xa99c3648" upper="0xa9983370" lower="(nil)">**if(b&amp;1)ans=root(ans*t);<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="1" nType="POR_TABLEFT"/><Text nLength="23" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3768" next="0xa99c37f8" prev="0xa99c36d8" upper="0xa9983370" lower="(nil)">**b&gt;&gt;=1;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="1" nType="POR_TABLEFT"/><Text nLength="6" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c37f8" next="0xa99c3888" prev="0xa99c3768" upper="0xa9983370" lower="(nil)">**t=root(t*t);<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="1" nType="POR_TABLEFT"/><Text nLength="12" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3888" next="0xa99c3918" prev="0xa99c37f8" upper="0xa9983370" lower="(nil)">*}<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3918" next="0xa99c39a8" prev="0xa99c3888" upper="0xa9983370" lower="(nil)">*return ans;<Text nLength="1" nType="POR_TABLEFT"/><Text nLength="11" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c39a8" next="0xa99c3a38" prev="0xa99c3918" upper="0xa9983370" lower="(nil)">} <Text nLength="2" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3a38" next="0xa99c3ac8" prev="0xa99c39a8" upper="0xa9983370" lower="(nil)">公式<Text nLength="1" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3ac8" next="0xa99c3b58" prev="0xa99c3a38" upper="0xa9983370" lower="(nil)">三角公式<Text nLength="4" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3b58" next="0xa99c3be8" prev="0xa99c3ac8" upper="0xa9983370" lower="(nil)">Atan2(x,y):结果是以弧度表示(-PI，PI)<Text nLength="11" nType="POR_TXT"/><Text nLength="8" nType="POR_TXT"/><Text nLength="4" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3be8" next="0xa99c3c78" prev="0xa99c3b58" upper="0xa9983370" lower="(nil)">Atan2(0,-1)=PI<Text nLength="14" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3c78" next="0xa99c3d08" prev="0xa99c3be8" upper="0xa9983370" lower="(nil)"><Finish/></txt><txt ptr="0xa99c3d08" next="0xa99c3d98" prev="0xa99c3c78" upper="0xa9983370" lower="(nil)">数学公式<Text nLength="4" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3d98" next="0xa99c3e28" prev="0xa99c3d08" upper="0xa9983370" lower="(nil)">sum(k)=(n+1)*n/2<Text nLength="16" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3e28" next="0xa99c3eb8" prev="0xa99c3d98" upper="0xa9983370" lower="(nil)">sum(k^2)=n (n+1)(2n+1)/6<Text nLength="24" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3eb8" next="0xa99c3f48" prev="0xa99c3e28" upper="0xa9983370" lower="(nil)">sum(k^3)=(n (n+1)/2)^2<Text nLength="22" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c3f48" next="0xa99c401c" prev="0xa99c3eb8" upper="0xa9983370" lower="(nil)">sum(k^4)=n (n+1) (2n+1) （3n^2+3n-1）/30<Text nLength="24" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="9" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="3" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c401c" next="0xa99c40ac" prev="0xa99c3f48" upper="0xa9983370" lower="(nil)">sum(k^5)= n^2 (n+1)^2 (2n^2+2n-1)/12<Text nLength="36" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c40ac" next="(nil)" prev="0xa99c401c" upper="0xa9983370" lower="(nil)">sum(k(k+1))=n(n+1)(n+2)/3<Text nLength="25" nType="POR_TXT"/><LineBreak/><Finish/></txt></body></column></section></body><footer ptr="0xa89980c0" next="(nil)" prev="0xa897b618" upper="0xa899315c" lower="0xa892a490"><txt ptr="0xa892a490" next="0xa892a2e0" prev="(nil)" upper="0xa89980c0" lower="(nil)"><anchored><fly ptr="0xb66b470" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa8975f30"><txt ptr="0xa8975f30" next="0xa89977e0" prev="(nil)" upper="0xb66b470" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa89977e0" next="(nil)" prev="0xa8975f30" upper="0xb66b470" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="2"/><LineBreak/><Finish/></txt></fly></anchored>V<Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa892a2e0" next="(nil)" prev="0xa892a490" upper="0xa89980c0" lower="(nil)">er 04make by tiankonguse <Text nLength="4" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><Text nLength="8" nType="POR_TXT"/><Text nLength="11" nType="POR_TXT"/><Text nLength="1" nType="POR_TXT"/><LineBreak/><Finish/></txt></footer></page><page ptr="0xa8993074" next="0xa9996e84" prev="0xa899315c" upper="0xb0726b0" lower="0xa9985964"><header ptr="0xa9985964" next="0xa896c25c" prev="(nil)" upper="0xa8993074" lower="0xa89185b4"><txt ptr="0xa89185b4" next="(nil)" prev="(nil)" upper="0xa9985964" lower="(nil)"><Finish/></txt></header><body ptr="0xa896c25c" next="0xa9986964" prev="0xa9985964" upper="0xa8993074" lower="0xa894be0c"><section ptr="0xa894be0c" next="(nil)" prev="(nil)" upper="0xa896c25c" lower="0xa88ef7f8" follow="0xa894bb8c" precede="0xa99bc680"><column ptr="0xa88ef7f8" next="0xa88ef85c" prev="(nil)" upper="0xa894be0c" lower="0xa99c8484"><body ptr="0xa99c8484" next="(nil)" prev="(nil)" upper="0xa88ef7f8" lower="0xa99c413c"><txt ptr="0xa99c413c" next="0xa99c41cc" prev="(nil)" upper="0xa99c8484" lower="(nil)">sum(k(k+1)(k+2))=n(n+1)(n+2)(n+3)/4<Text nLength="35" nType="POR_TXT"/><LineBreak/><Finish/></txt><txt ptr="0xa99c41cc" next="0xa99c425c" prev="0xa99c413c" upper="0xa99c8484" lower="(nil)">sum(k(k+1)(k+2)(k+3))=n(n+1)(n+2)(n+3)(n+4)/5<Finish/></txt><txt ptr="0xa99c425c" next="0xa99c42ec" prev="0xa99c41cc" upper="0xa99c8484" lower="(nil)"><Finish/></txt><txt ptr="0xa99c42ec" next="0xa99c437c" prev="0xa99c425c" upper="0xa99c8484" lower="(nil)">精度公式<Finish/></txt><txt ptr="0xa99c437c" next="0xa99c440c" prev="0xa99c42ec" upper="0xa99c8484" lower="(nil)">double eps=e-6;<Finish/></txt><txt ptr="0xa99c440c" next="0xa99c449c" prev="0xa99c437c" upper="0xa99c8484" lower="(nil)">int dblcmp(double x){<Finish/></txt><txt ptr="0xa99c449c" next="0xa99c452c" prev="0xa99c440c" upper="0xa99c8484" lower="(nil)">*return (x&lt;=eps) &amp;&amp; (x&gt;=-eps);<Finish/></txt><txt ptr="0xa99c452c" next="0xa99c488c" prev="0xa99c449c" upper="0xa99c8484" lower="(nil)">}<Finish/></txt><txt ptr="0xa99c488c" next="0xa99c491c" prev="0xa99c452c" upper="0xa99c8484" lower="(nil)">对数公式<Finish/></txt><txt ptr="0xa99c491c" next="0xa99c49ac" prev="0xa99c488c" upper="0xa99c8484" lower="(nil)">logan + logam = loganm <Finish/></txt><txt ptr="0xa99c49ac" next="0xa99c4a3c" prev="0xa99c491c" upper="0xa99c8484" lower="(nil)">klogan = logank <Finish/></txt><txt ptr="0xa99c4a3c" next="0xa99c4acc" prev="0xa99c49ac" upper="0xa99c8484" lower="(nil)">换底公式： logan/logbn=logba <Finish/></txt><txt ptr="0xa99c4acc" next="0xa99c4b5c" prev="0xa99c4a3c" upper="0xa99c8484" lower="(nil)"><Finish/></txt><txt ptr="0xa99c4b5c" next="0xa99c4bec" prev="0xa99c4acc" upper="0xa99c8484" lower="(nil)">复杂度公式<Finish/></txt><txt ptr="0xa99c4bec" next="0xa99c4c7c" prev="0xa99c4b5c" upper="0xa99c8484" lower="(nil)">递归式T(n) = aT(n/b) + f(n)<Finish/></txt><txt ptr="0xa99c4c7c" next="0xa99c4d0c" prev="0xa99c4bec" upper="0xa99c8484" lower="(nil)">递归树结果<Finish/></txt><txt ptr="0xa99c4d0c" next="0xa99c4d9c" prev="0xa99c4c7c" upper="0xa99c8484" lower="(nil)">T(n) = f(n)+af(n/b)+a2f(n/b2)+…+aLf(n/bL)其中L=logbn <Finish/></txt><txt ptr="0xa99c4d9c" next="0xa99c4e2c" prev="0xa99c4d0c" upper="0xa99c8484" lower="(nil)">微积分<Finish/></txt><txt ptr="0xa99c4e2c" next="0xa99c4ebc" prev="0xa99c4d9c" upper="0xa99c8484" lower="(nil)">曲线长度<Finish/></txt><txt ptr="0xa99c4ebc" next="0xa99c4f4c" prev="0xa99c4e2c" upper="0xa99c8484" lower="(nil)">在y=f(x)的任意点(x,y)附近去一段小曲线，看成线段，其长度：<Finish/></txt><txt ptr="0xa99c4f4c" next="0xa99c5020" prev="0xa99c4ebc" upper="0xa99c8484" lower="(nil)">Ds = sqrt(dx^2 + dy^2) <Finish/></txt><txt ptr="0xa99c5020" next="0xa99c50b0" prev="0xa99c4f4c" upper="0xa99c8484" lower="(nil)">= dx sqrt(1 + (dy/dx)^2 )<Finish/></txt><txt ptr="0xa99c50b0" next="0xa99c5140" prev="0xa99c5020" upper="0xa99c8484" lower="(nil)">= sqrt(1 + f’(x)^2 ) dx<Finish/></txt><txt ptr="0xa99c5140" next="0xa99c51d0" prev="0xa99c50b0" upper="0xa99c8484" lower="(nil)">所以：s = sqrt(1 + f’(x)^2) [x2,x1]<Finish/></txt><txt ptr="0xa99c51d0" next="0xa99c5260" prev="0xa99c5140" upper="0xa99c8484" lower="(nil)">二次函数<Finish/></txt><txt ptr="0xa99c5260" next="(nil)" prev="0xa99c51d0" upper="0xa99c8484" lower="(nil)">对于抛物线一般式：y=ax^2 + bx + c, y’ = 2ax + b<Finish/></txt></body></column><column ptr="0xa88ef85c" next="0xa88ef8c0" prev="0xa88ef7f8" upper="0xa894be0c" lower="0xa99c84e4"><body ptr="0xa99c84e4" next="(nil)" prev="(nil)" upper="0xa88ef85c" lower="0xa99c52f0"><txt ptr="0xa99c52f0" next="0xa99c5380" prev="(nil)" upper="0xa99c84e4" lower="(nil)">ds = sqrt(1 + f’(x)^2)<Finish/></txt><txt ptr="0xa99c5380" next="0xa99c5410" prev="0xa99c52f0" upper="0xa99c84e4" lower="(nil)"> = sqrt(1 + (2ax + b)^2)dx <Finish/></txt><txt ptr="0xa99c5410" next="0xa99c54a0" prev="0xa99c5380" upper="0xa99c84e4" lower="(nil)"> = 1/2a * sqrt(1 + (2ax+b)^2) d(2ax+b)<Finish/></txt><txt ptr="0xa99c54a0" next="0xa99c5530" prev="0xa99c5410" upper="0xa99c84e4" lower="(nil)"> = 1/2a * sqrt(1 + t^2) dt<Finish/></txt><txt ptr="0xa99c5530" next="0xa99c55c0" prev="0xa99c54a0" upper="0xa99c84e4" lower="(nil)"> = 1/4a * (t * sqrt(1 + t^2) + ln(t + sqrt(1 + t^2))) [x2,x1]<Finish/></txt><txt ptr="0xa99c55c0" next="0xa99c5650" prev="0xa99c5530" upper="0xa99c84e4" lower="(nil)">约瑟夫环的数学方法<Finish/></txt><txt ptr="0xa99c5650" next="0xa99c56e0" prev="0xa99c55c0" upper="0xa99c84e4" lower="(nil)">问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。<Finish/></txt><txt ptr="0xa99c56e0" next="0xa99c5770" prev="0xa99c5650" upper="0xa99c84e4" lower="(nil)"><Finish/></txt><txt ptr="0xa99c5770" next="0xa99c5800" prev="0xa99c56e0" upper="0xa99c84e4" lower="(nil)">我们知道第一个人(编号一定是(m-1)%n) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m%n的人开始）:<Finish/></txt><txt ptr="0xa99c5800" next="0xa99c5890" prev="0xa99c5770" upper="0xa99c84e4" lower="(nil)">  k k+1 k+2 ... n-2, n-1, 0, 1, 2, ... k-2<Finish/></txt><txt ptr="0xa99c5890" next="0xa99c5920" prev="0xa99c5800" upper="0xa99c84e4" lower="(nil)">  并且从k开始报0。<Finish/></txt><txt ptr="0xa99c5920" next="0xa99c59b0" prev="0xa99c5890" upper="0xa99c84e4" lower="(nil)">  现在我们把他们的编号做一下转换：<Finish/></txt><txt ptr="0xa99c59b0" next="0xa99c5a40" prev="0xa99c5920" upper="0xa99c84e4" lower="(nil)">  序列1： 1, 2, 3, 4, …, n-2, n-1, n<Finish/></txt><txt ptr="0xa99c5a40" next="0xa99c5ad0" prev="0xa99c59b0" upper="0xa99c84e4" lower="(nil)">  序列2： 1, 2, 3, 4, … k-1, k+1, …, n-2, n-1, n<Finish/></txt><txt ptr="0xa99c5ad0" next="0xa99c5e30" prev="0xa99c5a40" upper="0xa99c84e4" lower="(nil)">  序列3： k+1, k+2, k+3, …, n-2, n-1, n, 1, 2, 3,…, k-2, k-1<Finish/></txt><txt ptr="0xa99c5e30" next="0xa99c5ec0" prev="0xa99c5ad0" upper="0xa99c84e4" lower="(nil)">  序列4：1, 2, 3, 4, …, 5, 6, 7, 8, …, n-2, n-1<Finish/></txt><txt ptr="0xa99c5ec0" next="(nil)" prev="0xa99c5e30" upper="0xa99c84e4" lower="(nil)" follow="0xa890cb68">  变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来(其实就是利用子问题的解等价转换人数等于n的解,因为n在转化成n-1时已经出队一个人了,剩下n-1的最后出队人仍然和n的解相同,只是需要映射将下标到人数为n的情况)：<Finish/></txt></body></column><column ptr="0xa88ef8c0" next="(nil)" prev="0xa88ef85c" upper="0xa894be0c" lower="0xa99c8724"><body ptr="0xa99c8724" next="(nil)" prev="(nil)" upper="0xa88ef8c0" lower="0xa890cb68"><txt ptr="0xa890cb68" next="0xa99c5f50" prev="(nil)" upper="0xa99c8724" lower="(nil)" precede="0xa99c5ec0">  变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来(其实就是利用子问题的解等价转换人数等于n的解,因为n在转化成n-1时已经出队一个人了,剩下n-1的最后出队人仍然和n的解相同,只是需要映射将下标到人数为n的情况)：<Finish/></txt><txt ptr="0xa99c5f50" next="0xa99c6024" prev="0xa890cb68" upper="0xa99c8724" lower="(nil)">  ∵ k=m%n;<Finish/></txt><txt ptr="0xa99c6024" next="0xa99c60b4" prev="0xa99c5f50" upper="0xa99c8724" lower="(nil)">  ∴ x' = x+k = x+ m%n ; 而 x+ m%n 可能大于n<Finish/></txt><txt ptr="0xa99c60b4" next="0xa99c6144" prev="0xa99c6024" upper="0xa99c8724" lower="(nil)">  ∴x'= (x+ m%n)%n = (x+m)%n<Finish/></txt><txt ptr="0xa99c6144" next="0xa99c61d4" prev="0xa99c60b4" upper="0xa99c8724" lower="(nil)">  得到 x‘=(x+m)%n<Finish/></txt><txt ptr="0xa99c61d4" next="0xa99c6264" prev="0xa99c6144" upper="0xa99c8724" lower="(nil)">  如何知道(n-1)个人报数的问题的解？对，只要知道(n-2)个人的解就行了。(n-2)个人的解呢？当然是先求(n-3)的情况 ---- 这显然就是一个倒推问题！好了，思路出来了，下面写递推公式：<Finish/></txt><txt ptr="0xa99c6264" next="0xa99c62f4" prev="0xa99c61d4" upper="0xa99c8724" lower="(nil)">  令f表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n].<Finish/></txt><txt ptr="0xa99c62f4" next="0xa99c6384" prev="0xa99c6264" upper="0xa99c8724" lower="(nil)">  递推公式:<Finish/></txt><txt ptr="0xa99c6384" next="0xa99c6414" prev="0xa99c62f4" upper="0xa99c8724" lower="(nil)">  f[1]=0;<Finish/></txt><txt ptr="0xa99c6414" next="0xa99c64a4" prev="0xa99c6384" upper="0xa99c8724" lower="(nil)">  f[i]=(f[i-1]+m)%i; (i&gt;1)<Finish/></txt><txt ptr="0xa99c64a4" next="0xa99c6534" prev="0xa99c6414" upper="0xa99c8724" lower="(nil)">  有了这个公式，我们要做的就是从1-n顺序算出f的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1由于是逐级递推，不需要保存每个f，程序也是异常简单：<Finish/></txt><txt ptr="0xa99c6534" next="0xa99c65c4" prev="0xa99c64a4" upper="0xa99c8724" lower="(nil)"><Finish/></txt><txt ptr="0xa99c65c4" next="0xa99c6654" prev="0xa99c6534" upper="0xa99c8724" lower="(nil)">int getAns(int n,int m){<Finish/></txt><txt ptr="0xa99c6654" next="0xa99c66e4" prev="0xa99c65c4" upper="0xa99c8724" lower="(nil)">    int ans = 0;<Finish/></txt><txt ptr="0xa99c66e4" next="0xa99c6774" prev="0xa99c6654" upper="0xa99c8724" lower="(nil)">    for (int i=2; i&lt;=n; i++){<Finish/></txt><txt ptr="0xa99c6774" next="0xa99c6804" prev="0xa99c66e4" upper="0xa99c8724" lower="(nil)">        ans=(ans+m)%i;<Finish/></txt><txt ptr="0xa99c6804" next="0xa99c6894" prev="0xa99c6774" upper="0xa99c8724" lower="(nil)">    }<Finish/></txt><txt ptr="0xa99c6894" next="0xa99c6924" prev="0xa99c6804" upper="0xa99c8724" lower="(nil)">    return ans+1;<Finish/></txt><txt ptr="0xa99c6924" next="0xa99c69b4" prev="0xa99c6894" upper="0xa99c8724" lower="(nil)">}<Finish/></txt><txt ptr="0xa99c69b4" next="(nil)" prev="0xa99c6924" upper="0xa99c8724" lower="(nil)"><Finish/></txt></body></column></section></body><footer ptr="0xa9986964" next="(nil)" prev="0xa896c25c" upper="0xa8993074" lower="0xa8919d98"><txt ptr="0xa8919d98" next="0xa8919be8" prev="(nil)" upper="0xa9986964" lower="(nil)"><anchored><fly ptr="0xae31fd8" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa8975ea0"><txt ptr="0xa8975ea0" next="0xa89161c0" prev="(nil)" upper="0xae31fd8" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa89161c0" next="(nil)" prev="0xa8975ea0" upper="0xae31fd8" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="3"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa8919be8" next="(nil)" prev="0xa8919d98" upper="0xa9986964" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996e84" next="0xa89930e8" prev="0xa8993074" upper="0xb0726b0" lower="0xa9985904"><header ptr="0xa9985904" next="0xa8995240" prev="(nil)" upper="0xa9996e84" lower="0xa88ee6c4"><txt ptr="0xa88ee6c4" next="(nil)" prev="(nil)" upper="0xa9985904" lower="(nil)"><Finish/></txt></header><body ptr="0xa8995240" next="0xa9986904" prev="0xa9985904" upper="0xa9996e84" lower="0xa894bb8c"><section ptr="0xa894bb8c" next="(nil)" prev="(nil)" upper="0xa8995240" lower="0xa99af5e0" follow="0xa894ba8c" precede="0xa894be0c"><column ptr="0xa99af5e0" next="0xa99af57c" prev="(nil)" upper="0xa894bb8c" lower="0xa89892b4"><body ptr="0xa89892b4" next="(nil)" prev="(nil)" upper="0xa99af5e0" lower="0xa99c6a44"><txt ptr="0xa99c6a44" next="0xa99c6ad4" prev="(nil)" upper="0xa89892b4" lower="(nil)">pick定理<Finish/></txt><txt ptr="0xa99c6ad4" next="0xa99c6b64" prev="0xa99c6a44" upper="0xa89892b4" lower="(nil)">如果顶点都为整数坐标点，面积=边点/2+内点-1<Finish/></txt><txt ptr="0xa99c6b64" next="0xa99c6bf4" prev="0xa99c6ad4" upper="0xa89892b4" lower="(nil)"><Finish/></txt><txt ptr="0xa99c6bf4" next="0xa99c6c84" prev="0xa99c6b64" upper="0xa89892b4" lower="(nil)">catalan数<Finish/></txt><txt ptr="0xa99c6c84" next="0xa99c6d14" prev="0xa99c6bf4" upper="0xa89892b4" lower="(nil)">卡特兰数前几项<Finish/></txt><txt ptr="0xa99c6d14" next="0xa99c6da4" prev="0xa99c6c84" upper="0xa89892b4" lower="(nil)">1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324 <Finish/></txt><txt ptr="0xa99c6da4" next="0xa99c6e34" prev="0xa99c6d14" upper="0xa89892b4" lower="(nil)">定义<Finish/></txt><txt ptr="0xa99c6e34" next="0xa99c6ec4" prev="0xa99c6da4" upper="0xa89892b4" lower="(nil)">h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (n&gt;=2)<Finish/></txt><txt ptr="0xa99c6ec4" next="0xa99c6f54" prev="0xa99c6e34" upper="0xa89892b4" lower="(nil)">h(n)=h(n-1)*(4*n-2)/(n+1)<Finish/></txt><txt ptr="0xa99c6f54" next="0xa99c7028" prev="0xa99c6ec4" upper="0xa89892b4" lower="(nil)">h(n)=C(2n,n)/(n+1) (n=1,2,3,...)<Finish/></txt><txt ptr="0xa99c7028" next="0xa99c70b8" prev="0xa99c6f54" upper="0xa89892b4" lower="(nil)">h(n)=c(2n,n)-c(2n,n+1)(n=1,2,3,...)<Finish/></txt><txt ptr="0xa99c70b8" next="0xa99c7418" prev="0xa99c7028" upper="0xa89892b4" lower="(nil)">H(n+1) = 2(2n+1)/(n+2) * H(n)<Finish/></txt><txt ptr="0xa99c7418" next="0xa99c74a8" prev="0xa99c70b8" upper="0xa89892b4" lower="(nil)">H(n+1)=sum(H(i)*H(n-i)) (0&lt;=i&lt;=n)<Finish/></txt><txt ptr="0xa99c74a8" next="0xa99c7538" prev="0xa99c7418" upper="0xa89892b4" lower="(nil)">H(n) = sum( C(n,i) * C(n,i) ) /(n+1) (0&lt;=i&lt;=n)<Finish/></txt><txt ptr="0xa99c7538" next="0xa99c75c8" prev="0xa99c74a8" upper="0xa89892b4" lower="(nil)">H(n) ~= 4^n/(n^1.5 * sqrt(pi))<Finish/></txt><txt ptr="0xa99c75c8" next="0xa99c7658" prev="0xa99c7538" upper="0xa89892b4" lower="(nil)">应用<Finish/></txt><txt ptr="0xa99c7658" next="0xa99c76e8" prev="0xa99c75c8" upper="0xa89892b4" lower="(nil)">1.n个数的不同出栈序列<Finish/></txt><txt ptr="0xa99c76e8" next="0xa99c7778" prev="0xa99c7658" upper="0xa89892b4" lower="(nil)">2.N个+1和n个-1构成2n项a1a2...an，其部分和满足a1+a2+a3+...+an&gt;=0，0&lt;=k&lt;=2n。满足这个序列的个数等于第n个catakan数。<Finish/></txt><txt ptr="0xa99c7778" next="0xa99c7808" prev="0xa99c76e8" upper="0xa89892b4" lower="(nil)">3.括号匹配的合法个数<Finish/></txt><txt ptr="0xa99c7808" next="(nil)" prev="0xa99c7778" upper="0xa89892b4" lower="(nil)">4.连乘的选择个数<Finish/></txt></body></column><column ptr="0xa99af57c" next="0xa99af518" prev="0xa99af5e0" upper="0xa894bb8c" lower="0xa8989074"><body ptr="0xa8989074" next="(nil)" prev="(nil)" upper="0xa99af57c" lower="0xa99c7898"><txt ptr="0xa99c7898" next="0xa99c7928" prev="(nil)" upper="0xa8989074" lower="(nil)">5.n个节点的二叉树的树的形态的个数。<Finish/></txt><txt ptr="0xa99c7928" next="0xa99c79b8" prev="0xa99c7898" upper="0xa8989074" lower="(nil)">6.n个非叶子节点的满二叉树的形态数。<Finish/></txt><txt ptr="0xa99c79b8" next="0xa99c7a48" prev="0xa99c7928" upper="0xa8989074" lower="(nil)">7.n*n的矩阵中，从右下角到左上角的走法。<Finish/></txt><txt ptr="0xa99c7a48" next="0xa99c7ad8" prev="0xa99c79b8" upper="0xa8989074" lower="(nil)">8.凸n+2边形进行三角分割数。<Finish/></txt><txt ptr="0xa99c7ad8" next="0xa99c7b68" prev="0xa99c7a48" upper="0xa8989074" lower="(nil)">9.n层的阶梯切割为n个矩阵的切割法数。<Finish/></txt><txt ptr="0xa99c7b68" next="0xa99c7bf8" prev="0xa99c7ad8" upper="0xa8989074" lower="(nil)">10.在一个2*n的格子中填入1到2n这些数字，使每个格子内的数值都比其右边和上边的所有数值都小的情况数。<Finish/></txt><txt ptr="0xa99c7bf8" next="0xa99c7c88" prev="0xa99c7b68" upper="0xa8989074" lower="(nil)">随机函数<Finish/></txt><txt ptr="0xa99c7c88" next="0xa99c7d18" prev="0xa99c7bf8" upper="0xa8989074" lower="(nil)">int rands() {<Finish/></txt><txt ptr="0xa99c7d18" next="0xa99c7da8" prev="0xa99c7c88" upper="0xa8989074" lower="(nil)">    static int x=1364684679;<Finish/></txt><txt ptr="0xa99c7da8" next="0xa99c7e38" prev="0xa99c7d18" upper="0xa8989074" lower="(nil)">    x+=(x&lt;&lt;2)+1;<Finish/></txt><txt ptr="0xa99c7e38" next="0xa99c7ec8" prev="0xa99c7da8" upper="0xa8989074" lower="(nil)">    return x;<Finish/></txt><txt ptr="0xa99c7ec8" next="0xa99c7f58" prev="0xa99c7e38" upper="0xa8989074" lower="(nil)">}<Finish/></txt><txt ptr="0xa99c7f58" next="0xa99c9000" prev="0xa99c7ec8" upper="0xa8989074" lower="(nil)"><Finish/></txt><txt ptr="0xa99c9000" next="0xa99c9090" prev="0xa99c7f58" upper="0xa8989074" lower="(nil)">积性函数<Finish/></txt><txt ptr="0xa99c9090" next="0xa99c9120" prev="0xa99c9000" upper="0xa8989074" lower="(nil)">对于正整数n的一个函数f(n),当中f(1)=1且当a,b互质时，f(a,b)=f(a) * f(b);<Finish/></txt><txt ptr="0xa99c9120" next="0xa99c91b0" prev="0xa99c9090" upper="0xa8989074" lower="(nil)">若某函数f(n)富符合f(1)=1,且就算a,b不互质,f(a,b)=f(a) * f(b),则称它为完全积性函数。<Finish/></txt><txt ptr="0xa99c91b0" next="0xa99c9240" prev="0xa99c9120" upper="0xa8989074" lower="(nil)">积性函数有：<Finish/></txt><txt ptr="0xa99c9240" next="0xa99c92d0" prev="0xa99c91b0" upper="0xa8989074" lower="(nil)">欧拉函数：计算与n互质的小于n的正整数的个数<Finish/></txt><txt ptr="0xa99c92d0" next="0xa99c9360" prev="0xa99c9240" upper="0xa8989074" lower="(nil)">莫比乌斯函数:关于非平方数的质数因子的数目<Finish/></txt><txt ptr="0xa99c9360" next="0xa99c93f0" prev="0xa99c92d0" upper="0xa8989074" lower="(nil)">gcd(n,k)：最大公因子,k固定<Finish/></txt><txt ptr="0xa99c93f0" next="(nil)" prev="0xa99c9360" upper="0xa8989074" lower="(nil)">d(n):n的正因子数目，n的所有正因子之和<Finish/></txt></body></column><column ptr="0xa99af518" next="(nil)" prev="0xa99af57c" upper="0xa894bb8c" lower="0xa8989014"><body ptr="0xa8989014" next="(nil)" prev="(nil)" upper="0xa99af518" lower="0xa99c9480"><txt ptr="0xa99c9480" next="0xa99c9510" prev="(nil)" upper="0xa8989014" lower="(nil)">三分算法<Finish/></txt><txt ptr="0xa99c9510" next="0xa99c95a0" prev="0xa99c9480" upper="0xa8989014" lower="(nil)">typedef double Type;<Finish/></txt><txt ptr="0xa99c95a0" next="0xa99c9630" prev="0xa99c9510" upper="0xa8989014" lower="(nil)">double const eps = 1e-6;<Finish/></txt><txt ptr="0xa99c9630" next="0xa99c9990" prev="0xa99c95a0" upper="0xa8989014" lower="(nil)">double const scale = (sqrt(5.0) - 1) / 2;<Finish/></txt><txt ptr="0xa99c9990" next="0xa99c9a20" prev="0xa99c9630" upper="0xa8989014" lower="(nil)">double Calc(Type a) {<Finish/></txt><txt ptr="0xa99c9a20" next="0xa99c9ab0" prev="0xa99c9990" upper="0xa8989014" lower="(nil)">    /* 根据题目的意思计算 */<Finish/></txt><txt ptr="0xa99c9ab0" next="0xa99c9b40" prev="0xa99c9a20" upper="0xa8989014" lower="(nil)">}<Finish/></txt><txt ptr="0xa99c9b40" next="0xa99c9bd0" prev="0xa99c9ab0" upper="0xa8989014" lower="(nil)">void Solve(double left, double right) {<Finish/></txt><txt ptr="0xa99c9bd0" next="0xa99c9c60" prev="0xa99c9b40" upper="0xa8989014" lower="(nil)">    double mid_left, mid_right;<Finish/></txt><txt ptr="0xa99c9c60" next="0xa99c9cf0" prev="0xa99c9bd0" upper="0xa8989014" lower="(nil)">    double mid_left_value, mid_right_value;<Finish/></txt><txt ptr="0xa99c9cf0" next="0xa99c9d80" prev="0xa99c9c60" upper="0xa8989014" lower="(nil)">    double Golden_Section ,len, tmp;<Finish/></txt><txt ptr="0xa99c9d80" next="0xa99c9e10" prev="0xa99c9cf0" upper="0xa8989014" lower="(nil)"><Finish/></txt><txt ptr="0xa99c9e10" next="0xa99c9ea0" prev="0xa99c9d80" upper="0xa8989014" lower="(nil)">    bool left_scale = true;<Finish/></txt><txt ptr="0xa99c9ea0" next="0xa99c9f30" prev="0xa99c9e10" upper="0xa8989014" lower="(nil)"><Finish/></txt><txt ptr="0xa99c9f30" next="0xa99ab004" prev="0xa99c9ea0" upper="0xa8989014" lower="(nil)">    len = right - left;<Finish/></txt><txt ptr="0xa99ab004" next="0xa99ab094" prev="0xa99c9f30" upper="0xa8989014" lower="(nil)">    Golden_Section = scale * len;<Finish/></txt><txt ptr="0xa99ab094" next="0xa99ab124" prev="0xa99ab004" upper="0xa8989014" lower="(nil)"><Finish/></txt><txt ptr="0xa99ab124" next="0xa99ab1b4" prev="0xa99ab094" upper="0xa8989014" lower="(nil)">    mid_left = right - Golden_Section;<Finish/></txt><txt ptr="0xa99ab1b4" next="0xa99ab244" prev="0xa99ab124" upper="0xa8989014" lower="(nil)">    mid_left_value = Calc(mid_left);<Finish/></txt><txt ptr="0xa99ab244" next="0xa99ab2d4" prev="0xa99ab1b4" upper="0xa8989014" lower="(nil)"><Finish/></txt><txt ptr="0xa99ab2d4" next="0xa99ab364" prev="0xa99ab244" upper="0xa8989014" lower="(nil)">    while (left + eps &lt; right) {<Finish/></txt><txt ptr="0xa99ab364" next="0xa99ab3f4" prev="0xa99ab2d4" upper="0xa8989014" lower="(nil)">        if(left_scale) {<Finish/></txt><txt ptr="0xa99ab3f4" next="0xa99ab484" prev="0xa99ab364" upper="0xa8989014" lower="(nil)">            mid_right = left + Golden_Section;<Finish/></txt><txt ptr="0xa99ab484" next="0xa99ab514" prev="0xa99ab3f4" upper="0xa8989014" lower="(nil)">            mid_right_value = Calc(mid_right);<Finish/></txt><txt ptr="0xa99ab514" next="0xa99ab5a4" prev="0xa99ab484" upper="0xa8989014" lower="(nil)">        } else {<Finish/></txt><txt ptr="0xa99ab5a4" next="0xa99ab634" prev="0xa99ab514" upper="0xa8989014" lower="(nil)">            mid_left = right - Golden_Section;<Finish/></txt><txt ptr="0xa99ab634" next="(nil)" prev="0xa99ab5a4" upper="0xa8989014" lower="(nil)">            mid_left_value = Calc(mid_left);<Finish/></txt></body></column></section></body><footer ptr="0xa9986904" next="(nil)" prev="0xa8995240" upper="0xa9996e84" lower="0xa8997360"><txt ptr="0xa8997360" next="0xa89187f4" prev="(nil)" upper="0xa9986904" lower="(nil)"><anchored><fly ptr="0xa502300" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa8919c78"><txt ptr="0xa8919c78" next="0xa89973f0" prev="(nil)" upper="0xa502300" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa89973f0" next="(nil)" prev="0xa8919c78" upper="0xa502300" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="4"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa89187f4" next="(nil)" prev="0xa8997360" upper="0xa9986904" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa89930e8" next="0xa89931d0" prev="0xa9996e84" upper="0xb0726b0" lower="0xa8996060"><header ptr="0xa8996060" next="0xa89952a0" prev="(nil)" upper="0xa89930e8" lower="0xa89976c0"><txt ptr="0xa89976c0" next="(nil)" prev="(nil)" upper="0xa8996060" lower="(nil)"><Finish/></txt></header><body ptr="0xa89952a0" next="0xa8998060" prev="0xa8996060" upper="0xa89930e8" lower="0xa894ba8c"><section ptr="0xa894ba8c" next="(nil)" prev="(nil)" upper="0xa89952a0" lower="0xa99af4b4" follow="0xa99bc380" precede="0xa894bb8c"><column ptr="0xa99af4b4" next="0xa99af324" prev="(nil)" upper="0xa894ba8c" lower="0xa9983f70"><body ptr="0xa9983f70" next="(nil)" prev="(nil)" upper="0xa99af4b4" lower="0xa99ab6c4"><txt ptr="0xa99ab6c4" next="0xa99ab754" prev="(nil)" upper="0xa9983f70" lower="(nil)">        }<Finish/></txt><txt ptr="0xa99ab754" next="0xa99ab7e4" prev="0xa99ab6c4" upper="0xa9983f70" lower="(nil)"><Finish/></txt><txt ptr="0xa99ab7e4" next="0xa99ab874" prev="0xa99ab754" upper="0xa9983f70" lower="(nil)">        tmp = len;<Finish/></txt><txt ptr="0xa99ab874" next="0xa99ab904" prev="0xa99ab7e4" upper="0xa9983f70" lower="(nil)">        len = Golden_Section;<Finish/></txt><txt ptr="0xa99ab904" next="0xa99ab994" prev="0xa99ab874" upper="0xa9983f70" lower="(nil)">        Golden_Section = tmp - Golden_Section;<Finish/></txt><txt ptr="0xa99ab994" next="0xa99aba24" prev="0xa99ab904" upper="0xa9983f70" lower="(nil)"><Finish/></txt><txt ptr="0xa99aba24" next="0xa99abab4" prev="0xa99ab994" upper="0xa9983f70" lower="(nil)">        if (mid_left_value &gt;= mid_right_value) {<Finish/></txt><txt ptr="0xa99abab4" next="0xa99abb44" prev="0xa99aba24" upper="0xa9983f70" lower="(nil)">            left = mid_left;<Finish/></txt><txt ptr="0xa99abb44" next="0xa99abbd4" prev="0xa99abab4" upper="0xa9983f70" lower="(nil)">            left_scale = true;<Finish/></txt><txt ptr="0xa99abbd4" next="0xa99abf34" prev="0xa99abb44" upper="0xa9983f70" lower="(nil)"><Finish/></txt><txt ptr="0xa99abf34" next="0xa99ac008" prev="0xa99abbd4" upper="0xa9983f70" lower="(nil)">            mid_left = mid_right;<Finish/></txt><txt ptr="0xa99ac008" next="0xa99ac098" prev="0xa99abf34" upper="0xa9983f70" lower="(nil)">            mid_left_value = mid_right_value;<Finish/></txt><txt ptr="0xa99ac098" next="0xa99ac128" prev="0xa99ac008" upper="0xa9983f70" lower="(nil)">        } else {<Finish/></txt><txt ptr="0xa99ac128" next="0xa99ac1b8" prev="0xa99ac098" upper="0xa9983f70" lower="(nil)">            right = mid_right;<Finish/></txt><txt ptr="0xa99ac1b8" next="0xa99ac248" prev="0xa99ac128" upper="0xa9983f70" lower="(nil)">            left_scale = false;<Finish/></txt><txt ptr="0xa99ac248" next="0xa99ac2d8" prev="0xa99ac1b8" upper="0xa9983f70" lower="(nil)"><Finish/></txt><txt ptr="0xa99ac2d8" next="0xa99ac368" prev="0xa99ac248" upper="0xa9983f70" lower="(nil)">            mid_right = mid_left;<Finish/></txt><txt ptr="0xa99ac368" next="0xa99ac3f8" prev="0xa99ac2d8" upper="0xa9983f70" lower="(nil)">            mid_right_value = mid_left_value;<Finish/></txt><txt ptr="0xa99ac3f8" next="0xa99ac488" prev="0xa99ac368" upper="0xa9983f70" lower="(nil)">        }<Finish/></txt><txt ptr="0xa99ac488" next="0xa99ac518" prev="0xa99ac3f8" upper="0xa9983f70" lower="(nil)">    }<Finish/></txt><txt ptr="0xa99ac518" next="0xa99ac5a8" prev="0xa99ac488" upper="0xa9983f70" lower="(nil)">}<Finish/></txt><txt ptr="0xa99ac5a8" next="0xa99ac638" prev="0xa99ac518" upper="0xa9983f70" lower="(nil)"><Finish/></txt><txt ptr="0xa99ac638" next="0xa99ac6c8" prev="0xa99ac5a8" upper="0xa9983f70" lower="(nil)">位操作<Finish/></txt><txt ptr="0xa99ac6c8" next="0xa99ac758" prev="0xa99ac638" upper="0xa9983f70" lower="(nil)">与操作 &amp;<Finish/></txt><txt ptr="0xa99ac758" next="0xa99ac7e8" prev="0xa99ac6c8" upper="0xa9983f70" lower="(nil)">i. 用以取出一个数的某些二进制位<Finish/></txt><txt ptr="0xa99ac7e8" next="(nil)" prev="0xa99ac758" upper="0xa9983f70" lower="(nil)">ii. 取出一个数二进制中的最后一个 1：x&amp;-x<Finish/></txt></body></column><column ptr="0xa99af324" next="0xa99af2c0" prev="0xa99af4b4" upper="0xa894ba8c" lower="0xa9983eb0"><body ptr="0xa9983eb0" next="(nil)" prev="(nil)" upper="0xa99af324" lower="0xa99ac878"><txt ptr="0xa99ac878" next="0xa99ac908" prev="(nil)" upper="0xa9983eb0" lower="(nil)">或操作 |<Finish/></txt><txt ptr="0xa99ac908" next="0xa99ac998" prev="0xa99ac878" upper="0xa9983eb0" lower="(nil)">用以将一个数的某些位设为1<Finish/></txt><txt ptr="0xa99ac998" next="0xa99aca28" prev="0xa99ac908" upper="0xa9983eb0" lower="(nil)">非操作 ~<Finish/></txt><txt ptr="0xa99aca28" next="0xa99acab8" prev="0xa99ac998" upper="0xa9983eb0" lower="(nil)">用以间接构造一些数：~0u=4294967295=232-1<Finish/></txt><txt ptr="0xa99acab8" next="0xa99acb48" prev="0xa99aca28" upper="0xa9983eb0" lower="(nil)">异或操作 ^<Finish/></txt><txt ptr="0xa99acb48" next="0xa99acbd8" prev="0xa99acab8" upper="0xa9983eb0" lower="(nil)">i. 不使用中间变量交换两个数：a=a^b;b=a^b;a=a^b;<Finish/></txt><txt ptr="0xa99acbd8" next="0xa99acc68" prev="0xa99acb48" upper="0xa9983eb0" lower="(nil)">ii. 将一个数的某些位取反<Finish/></txt><txt ptr="0xa99acc68" next="0xa99accf8" prev="0xa99acbd8" upper="0xa9983eb0" lower="(nil)"><Finish/></txt><txt ptr="0xa99accf8" next="0xa99acd88" prev="0xa99acc68" upper="0xa9983eb0" lower="(nil)">矩阵<Finish/></txt><txt ptr="0xa99acd88" next="0xa99ace18" prev="0xa99accf8" upper="0xa9983eb0" lower="(nil)">#define TT __int64<Finish/></txt><txt ptr="0xa99ace18" next="0xa99acea8" prev="0xa99acd88" upper="0xa9983eb0" lower="(nil)">const int N=12;<Finish/></txt><txt ptr="0xa99acea8" next="0xa99acf38" prev="0xa99ace18" upper="0xa9983eb0" lower="(nil)">const int MOD=2008512;<Finish/></txt><txt ptr="0xa99acf38" next="0xa99ad00c" prev="0xa99acea8" upper="0xa9983eb0" lower="(nil)">const int sz=10;<Finish/></txt><txt ptr="0xa99ad00c" next="0xa99ad09c" prev="0xa99acf38" upper="0xa9983eb0" lower="(nil)">struct Matrix{<Finish/></txt><txt ptr="0xa99ad09c" next="0xa99ad12c" prev="0xa99ad00c" upper="0xa9983eb0" lower="(nil)">**TT a[N][N];*<Finish/></txt><txt ptr="0xa99ad12c" next="0xa99ad1bc" prev="0xa99ad09c" upper="0xa9983eb0" lower="(nil)">**Matrix(){memset(a,0,sizeof(a));}<Finish/></txt><txt ptr="0xa99ad1bc" next="0xa99ad51c" prev="0xa99ad12c" upper="0xa9983eb0" lower="(nil)">**void _union(){int l=sz;while(l--)a[l][l]=1; }<Finish/></txt><txt ptr="0xa99ad51c" next="0xa99ad5ac" prev="0xa99ad1bc" upper="0xa9983eb0" lower="(nil)">**Matrix operator*(Matrix&amp; B);<Finish/></txt><txt ptr="0xa99ad5ac" next="0xa99ad63c" prev="0xa99ad51c" upper="0xa9983eb0" lower="(nil)">**Matrix pow(TT k); <Finish/></txt><txt ptr="0xa99ad63c" next="0xa99ad6cc" prev="0xa99ad5ac" upper="0xa9983eb0" lower="(nil)">}; <Finish/></txt><txt ptr="0xa99ad6cc" next="0xa99ad75c" prev="0xa99ad63c" upper="0xa9983eb0" lower="(nil)">矩阵相乘<Finish/></txt><txt ptr="0xa99ad75c" next="0xa99ad7ec" prev="0xa99ad6cc" upper="0xa9983eb0" lower="(nil)">Matrix Matrix::operator*(Matrix&amp; B){<Finish/></txt><txt ptr="0xa99ad7ec" next="0xa99ad87c" prev="0xa99ad75c" upper="0xa9983eb0" lower="(nil)">*Matrix ret;<Finish/></txt><txt ptr="0xa99ad87c" next="0xa99ad90c" prev="0xa99ad7ec" upper="0xa9983eb0" lower="(nil)">*for(int i=0;i&lt;sz;i++)<Finish/></txt><txt ptr="0xa99ad90c" next="0xa99ad99c" prev="0xa99ad87c" upper="0xa9983eb0" lower="(nil)">*for(int j=0;j&lt;sz;j++)<Finish/></txt><txt ptr="0xa99ad99c" next="0xa99ada2c" prev="0xa99ad90c" upper="0xa9983eb0" lower="(nil)">*for(int k=0;k&lt;sz;k++)<Finish/></txt><txt ptr="0xa99ada2c" next="(nil)" prev="0xa99ad99c" upper="0xa9983eb0" lower="(nil)">*ret.a[i][j]=(ret.a[i][j]+a[i][k]*B.a[k][j]) %MOD;<Finish/></txt></body></column><column ptr="0xa99af2c0" next="(nil)" prev="0xa99af324" upper="0xa894ba8c" lower="0xa9983e50"><body ptr="0xa9983e50" next="(nil)" prev="(nil)" upper="0xa99af2c0" lower="0xa99adabc"><txt ptr="0xa99adabc" next="0xa99adb4c" prev="(nil)" upper="0xa9983e50" lower="(nil)">*return ret;  } <Finish/></txt><txt ptr="0xa99adb4c" next="0xa99adbdc" prev="0xa99adabc" upper="0xa9983e50" lower="(nil)">矩阵幂乘<Finish/></txt><txt ptr="0xa99adbdc" next="0xa99adc6c" prev="0xa99adb4c" upper="0xa9983e50" lower="(nil)">Matrix Matrix::pow(TT k){<Finish/></txt><txt ptr="0xa99adc6c" next="0xa99adcfc" prev="0xa99adbdc" upper="0xa9983e50" lower="(nil)">*Matrix ret;<Finish/></txt><txt ptr="0xa99adcfc" next="0xa99add8c" prev="0xa99adc6c" upper="0xa9983e50" lower="(nil)">*Matrix A=*this;<Finish/></txt><txt ptr="0xa99add8c" next="0xa99ade1c" prev="0xa99adcfc" upper="0xa9983e50" lower="(nil)">*ret._union();<Finish/></txt><txt ptr="0xa99ade1c" next="0xa99adeac" prev="0xa99add8c" upper="0xa9983e50" lower="(nil)">*while(k){<Finish/></txt><txt ptr="0xa99adeac" next="0xa99adf3c" prev="0xa99ade1c" upper="0xa9983e50" lower="(nil)">**if(k&amp;1)ret=ret*A;<Finish/></txt><txt ptr="0xa99adf3c" next="0xa99b0010" prev="0xa99adeac" upper="0xa9983e50" lower="(nil)">**A=A*A;<Finish/></txt><txt ptr="0xa99b0010" next="0xa99b00a0" prev="0xa99adf3c" upper="0xa9983e50" lower="(nil)">**k&gt;&gt;=1; <Finish/></txt><txt ptr="0xa99b00a0" next="0xa99b0130" prev="0xa99b0010" upper="0xa9983e50" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99b0130" next="0xa99b01c0" prev="0xa99b00a0" upper="0xa9983e50" lower="(nil)">*return ret; <Finish/></txt><txt ptr="0xa99b01c0" next="0xa99b0250" prev="0xa99b0130" upper="0xa9983e50" lower="(nil)">}<Finish/></txt><txt ptr="0xa99b0250" next="0xa99b02e0" prev="0xa99b01c0" upper="0xa9983e50" lower="(nil)">判断A * B == C<Finish/></txt><txt ptr="0xa99b02e0" next="0xa99b0370" prev="0xa99b0250" upper="0xa9983e50" lower="(nil)">随机算法<Finish/></txt><txt ptr="0xa99b0370" next="0xa99b0400" prev="0xa99b02e0" upper="0xa9983e50" lower="(nil)">bool eq(int i,int j,int sz){<Finish/></txt><txt ptr="0xa99b0400" next="0xa99b0490" prev="0xa99b0370" upper="0xa9983e50" lower="(nil)">    int tmp=0,k;<Finish/></txt><txt ptr="0xa99b0490" next="0xa99b0520" prev="0xa99b0400" upper="0xa9983e50" lower="(nil)">    for(k=0;k&lt;sz;k++){<Finish/></txt><txt ptr="0xa99b0520" next="0xa99b05b0" prev="0xa99b0490" upper="0xa9983e50" lower="(nil)">        tmp += A[i][k]*B[k][j];<Finish/></txt><txt ptr="0xa99b05b0" next="0xa99b0640" prev="0xa99b0520" upper="0xa9983e50" lower="(nil)">    }<Finish/></txt><txt ptr="0xa99b0640" next="0xa99b06d0" prev="0xa99b05b0" upper="0xa9983e50" lower="(nil)">    return tmp == C[i][j];<Finish/></txt><txt ptr="0xa99b06d0" next="0xa99b0760" prev="0xa99b0640" upper="0xa9983e50" lower="(nil)">}<Finish/></txt><txt ptr="0xa99b0760" next="0xa99b0ac0" prev="0xa99b06d0" upper="0xa9983e50" lower="(nil)"><Finish/></txt><txt ptr="0xa99b0ac0" next="0xa99b0b50" prev="0xa99b0760" upper="0xa9983e50" lower="(nil)">const int L = 10000;<Finish/></txt><txt ptr="0xa99b0b50" next="0xa99b0be0" prev="0xa99b0ac0" upper="0xa9983e50" lower="(nil)">bool randTest(int sz){<Finish/></txt><txt ptr="0xa99b0be0" next="0xa99b0c70" prev="0xa99b0b50" upper="0xa9983e50" lower="(nil)">    int i,j,k;<Finish/></txt><txt ptr="0xa99b0c70" next="0xa99b0d00" prev="0xa99b0be0" upper="0xa9983e50" lower="(nil)">    for(k=0;k&lt;L;k++){<Finish/></txt><txt ptr="0xa99b0d00" next="(nil)" prev="0xa99b0c70" upper="0xa9983e50" lower="(nil)">        i = rand()%sz;<Finish/></txt></body></column></section></body><footer ptr="0xa8998060" next="(nil)" prev="0xa89952a0" upper="0xa89930e8" lower="0xa8997630"><txt ptr="0xa8997630" next="0xa8997510" prev="(nil)" upper="0xa8998060" lower="(nil)"><anchored><fly ptr="0xb583730" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa8997480"><txt ptr="0xa8997480" next="0xa89975a0" prev="(nil)" upper="0xb583730" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa89975a0" next="(nil)" prev="0xa8997480" upper="0xb583730" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="5"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa8997510" next="(nil)" prev="0xa8997630" upper="0xa8998060" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa89931d0" next="0xa8993244" prev="0xa89930e8" upper="0xb0726b0" lower="0xa8996120"><header ptr="0xa8996120" next="0xa8995600" prev="(nil)" upper="0xa89931d0" lower="0xa99bdea4"><txt ptr="0xa99bdea4" next="(nil)" prev="(nil)" upper="0xa8996120" lower="(nil)"><Finish/></txt></header><body ptr="0xa8995600" next="0xa8998120" prev="0xa8996120" upper="0xa89931d0" lower="0xa99bc380"><section ptr="0xa99bc380" next="(nil)" prev="(nil)" upper="0xa8995600" lower="0xa99a53f0" follow="0xa99bca00" precede="0xa894ba8c"><column ptr="0xa99a53f0" next="0xa99a538c" prev="(nil)" upper="0xa99bc380" lower="0xa999cd28"><body ptr="0xa999cd28" next="(nil)" prev="(nil)" upper="0xa99a53f0" lower="0xa99b0d90"><txt ptr="0xa99b0d90" next="0xa99b0e20" prev="(nil)" upper="0xa999cd28" lower="(nil)">        j = rand()%sz;<Finish/></txt><txt ptr="0xa99b0e20" next="0xa99b0eb0" prev="0xa99b0d90" upper="0xa999cd28" lower="(nil)">        if(!eq(i,j,sz))return false;<Finish/></txt><txt ptr="0xa99b0eb0" next="0xa99b0f40" prev="0xa99b0e20" upper="0xa999cd28" lower="(nil)">    }<Finish/></txt><txt ptr="0xa99b0f40" next="0xa99b1014" prev="0xa99b0eb0" upper="0xa999cd28" lower="(nil)"><Finish/></txt><txt ptr="0xa99b1014" next="0xa99b10a4" prev="0xa99b0f40" upper="0xa999cd28" lower="(nil)">    return true;<Finish/></txt><txt ptr="0xa99b10a4" next="0xa99b1134" prev="0xa99b1014" upper="0xa999cd28" lower="(nil)">}<Finish/></txt><txt ptr="0xa99b1134" next="0xa99b11c4" prev="0xa99b10a4" upper="0xa999cd28" lower="(nil)">伪随机算法<Finish/></txt><txt ptr="0xa99b11c4" next="0xa99b1254" prev="0xa99b1134" upper="0xa999cd28" lower="(nil)">A*B的复杂度是O(n^3)，A是一维的话，复杂度就是O(n^2)了。<Finish/></txt><txt ptr="0xa99b1254" next="0xa99b12e4" prev="0xa99b11c4" upper="0xa999cd28" lower="(nil)">所以A*B == C 可以近似的转化为1 * A * B == 1 * C<Finish/></txt><txt ptr="0xa99b12e4" next="0xa99b1374" prev="0xa99b1254" upper="0xa999cd28" lower="(nil)">1是一维的向量。<Finish/></txt><txt ptr="0xa99b1374" next="0xa99b1404" prev="0xa99b12e4" upper="0xa999cd28" lower="(nil)">矩阵幂相加<Finish/></txt><txt ptr="0xa99b1404" next="0xa99b1494" prev="0xa99b1374" upper="0xa999cd28" lower="(nil)">给定矩阵A，求A + A^2 + A^3 + ... + A^k的结果（两个矩阵相加就是对应位置分别相加）。输出的数据mod m。k&lt;=10^9。<Finish/></txt><txt ptr="0xa99b1494" next="0xa99b1524" prev="0xa99b1404" upper="0xa999cd28" lower="(nil)">    这道题两次二分，相当经典。首先我们知道，A^i可以二分求出。然后我们需要对整个题目的数据规模k进行二分。比如，当k=6时，有：<Finish/></txt><txt ptr="0xa99b1524" next="0xa99b15b4" prev="0xa99b1494" upper="0xa999cd28" lower="(nil)">    A + A^2 + A^3 + A^4 + A^5 + A^6 =(A + A^2 + A^3) + A^3*(A + A^2 + A^3)<Finish/></txt><txt ptr="0xa99b15b4" next="0xa99b1644" prev="0xa99b1524" upper="0xa999cd28" lower="(nil)">    应用这个式子后，规模k减小了一半。我们二分求出A^3后再递归地计算A + A^2 + A^3，即可得到原问题的答案。<Finish/></txt><txt ptr="0xa99b1644" next="0xa99b16d4" prev="0xa99b15b4" upper="0xa999cd28" lower="(nil)"><Finish/></txt><txt ptr="0xa99b16d4" next="0xa99b1764" prev="0xa99b1644" upper="0xa999cd28" lower="(nil)">构造矩阵<Finish/></txt><txt ptr="0xa99b1764" next="0xa99b17f4" prev="0xa99b16d4" upper="0xa999cd28" lower="(nil)">求第n个Fibonacci数mod p<Finish/></txt><txt ptr="0xa99b17f4" next="(nil)" prev="0xa99b1764" upper="0xa999cd28" lower="(nil)"> 给定n和p，求第n个Fibonacci数mod p的值，n不超过2^31<Finish/></txt></body></column><column ptr="0xa99a538c" next="0xa99a5328" prev="0xa99a53f0" upper="0xa99bc380" lower="0xa999ccc8"><body ptr="0xa999ccc8" next="(nil)" prev="(nil)" upper="0xa99a538c" lower="0xa99b1884"><txt ptr="0xa99b1884" next="0xa99b1914" prev="(nil)" upper="0xa999ccc8" lower="(nil)"><anchored><fly ptr="0xa52d128" next="(nil)" prev="(nil)" upper="(nil)" lower="0xb34dda0"><txt ptr="0xb34dda0" next="(nil)" prev="(nil)" upper="0xa52d128" lower="(nil)"/></fly></anchored>现在我们需要构造一个2 x 2的矩阵，使得它乘以(a,b)得到的结果是(b,a+b)。每多乘一次这个矩阵，这两个数就会多迭代一次。那么，我们把这个2 x 2的矩阵自乘n次，再乘以(0,1)就可以得到第n个Fibonacci数了。不用多想，这个2 x 2的矩阵很容易构造出来：<Finish/></txt><txt ptr="0xa99b1914" next="0xa99b19a4" prev="0xa99b1884" upper="0xa999ccc8" lower="(nil)">求有向图中A走k步到B的方案数<Finish/></txt><txt ptr="0xa99b19a4" next="0xa99b1a34" prev="0xa99b1914" upper="0xa999ccc8" lower="(nil)">给定一个有向图，问从A点恰好走k步（允许重复经过边）到达B点的方案数mod p的值<Finish/></txt><txt ptr="0xa99b1a34" next="0xa99b1ac4" prev="0xa99b19a4" upper="0xa999ccc8" lower="(nil)">  把给定的图转为邻接矩阵，即A(i,j)=1当且仅当存在一条边i-&gt;j。令C=A*A，那么C(i,j)=ΣA(i,k)*A(k,j)，实际上就等于从点i到点j恰好经过2条边的路径数（枚举k为中转点）。类似地，C*A的第i行第j列就表示从i到j经过3条边的路径数。同理，如果要求经过k步的路径数，我们只需要二分求出A^k即可。<Finish/></txt><txt ptr="0xa99b1ac4" next="0xa99b1b54" prev="0xa99b1a34" upper="0xa999ccc8" lower="(nil)">用1 x 2的矩阵填充 M x N 的矩阵的方案数。<Finish/></txt><txt ptr="0xa99b1b54" next="0xa99b1be4" prev="0xa99b1ac4" upper="0xa999ccc8" lower="(nil)">用1 x 2的多米诺骨牌填满M x N的矩形有多少种方案，M&lt;=5，N&lt;2^31，输出答案mod p的结果<Finish/></txt><txt ptr="0xa99b1be4" next="0xa99b1c74" prev="0xa99b1b54" upper="0xa999ccc8" lower="(nil)">高斯消元法<Finish/></txt><txt ptr="0xa99b1c74" next="0xa99b1d04" prev="0xa99b1be4" upper="0xa999ccc8" lower="(nil)">class Gauss{<Finish/></txt><txt ptr="0xa99b1d04" next="0xa99b20a8" prev="0xa99b1c74" upper="0xa999ccc8" lower="(nil)">*int var,equ;//有equ个方程，var个变元。<Finish/></txt><txt ptr="0xa99b20a8" next="0xa99b2138" prev="0xa99b1d04" upper="0xa999ccc8" lower="(nil)">*int matrix[N][N],free_x[N],ans[N];// matrix为增广矩阵，ans为解集,free_x判断是否是不确定的变元.<Finish/></txt><txt ptr="0xa99b2138" next="(nil)" prev="0xa99b20a8" upper="0xa999ccc8" lower="(nil)">*public:<Finish/></txt></body></column><column ptr="0xa99a5328" next="(nil)" prev="0xa99a538c" upper="0xa99bc380" lower="0xa999cc68"><body ptr="0xa999cc68" next="(nil)" prev="(nil)" upper="0xa99a5328" lower="0xa99b21c8"><txt ptr="0xa99b21c8" next="0xa99b2258" prev="(nil)" upper="0xa999cc68" lower="(nil)">*void init(int n,int m);<Finish/></txt><txt ptr="0xa99b2258" next="0xa99b22e8" prev="0xa99b21c8" upper="0xa999cc68" lower="(nil)">*int getanswer();<Finish/></txt><txt ptr="0xa99b22e8" next="0xa99b2378" prev="0xa99b2258" upper="0xa999cc68" lower="(nil)">//高斯消元法解方程组(Gauss-Jordan elimination).<Finish/></txt><txt ptr="0xa99b2378" next="0xa99b2408" prev="0xa99b22e8" upper="0xa999cc68" lower="(nil)">//(-2表示有浮点数解，但无整数解，-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)<Finish/></txt><txt ptr="0xa99b2408" next="0xa99b2498" prev="0xa99b2378" upper="0xa999cc68" lower="(nil)">};<Finish/></txt><txt ptr="0xa99b2498" next="0xa99b2528" prev="0xa99b2408" upper="0xa999cc68" lower="(nil)">void Gauss::init(int n,int m){ <Finish/></txt><txt ptr="0xa99b2528" next="0xa99b25b8" prev="0xa99b2498" upper="0xa999cc68" lower="(nil)">this-&gt;equ=m;<Finish/></txt><txt ptr="0xa99b25b8" next="0xa99b2648" prev="0xa99b2528" upper="0xa999cc68" lower="(nil)">this-&gt;var=n;<Finish/></txt><txt ptr="0xa99b2648" next="0xa99b26d8" prev="0xa99b25b8" upper="0xa999cc68" lower="(nil)">memset(matrix,0,sizeof(matrix));<Finish/></txt><txt ptr="0xa99b26d8" next="0xa99b2768" prev="0xa99b2648" upper="0xa999cc68" lower="(nil)">}<Finish/></txt><txt ptr="0xa99b2768" next="0xa99b27f8" prev="0xa99b26d8" upper="0xa999cc68" lower="(nil)">int Gauss::getanswer(){<Finish/></txt><txt ptr="0xa99b27f8" next="0xa99b2888" prev="0xa99b2768" upper="0xa999cc68" lower="(nil)">*int tmp;<Finish/></txt><txt ptr="0xa99b2888" next="0xa99b2918" prev="0xa99b27f8" upper="0xa999cc68" lower="(nil)">*int max_r,ta,tb,k,col=0;<Finish/></txt><txt ptr="0xa99b2918" next="0xa99b29a8" prev="0xa99b2888" upper="0xa999cc68" lower="(nil)">*// 转换为阶梯阵.<Finish/></txt><txt ptr="0xa99b29a8" next="0xa99b2a38" prev="0xa99b2918" upper="0xa999cc68" lower="(nil)">*for(k=0;k&lt;equ &amp;&amp; col&lt;var ;k++,col++){<Finish/></txt><txt ptr="0xa99b2a38" next="0xa99b2ac8" prev="0xa99b29a8" upper="0xa999cc68" lower="(nil)">**max_r=k;<Finish/></txt><txt ptr="0xa99b2ac8" next="0xa99b2b58" prev="0xa99b2a38" upper="0xa999cc68" lower="(nil)">//找到该col列元素绝对值最大的那行与第k行交换<Finish/></txt><txt ptr="0xa99b2b58" next="0xa99b2be8" prev="0xa99b2ac8" upper="0xa999cc68" lower="(nil)">for(int i=k+1;i&lt;equ;i++)<Finish/></txt><txt ptr="0xa99b2be8" next="0xa99b2c78" prev="0xa99b2b58" upper="0xa999cc68" lower="(nil)">if(abs(matrix[i][col])&gt; abs(matrix[max_r][col]))max_r=i;<Finish/></txt><txt ptr="0xa99b2c78" next="0xa99b2d08" prev="0xa99b2be8" upper="0xa999cc68" lower="(nil)">*<Finish/></txt><txt ptr="0xa99b2d08" next="0xa99b2d98" prev="0xa99b2c78" upper="0xa999cc68" lower="(nil)">if(max_r != k){// 与第k行交换<Finish/></txt><txt ptr="0xa99b2d98" next="0xa99b2e28" prev="0xa99b2d08" upper="0xa999cc68" lower="(nil)">for(intj=k;j&lt;var+1;j++)<Finish/></txt><txt ptr="0xa99b2e28" next="0xa99b2eb8" prev="0xa99b2d98" upper="0xa999cc68" lower="(nil)">swap(matrix[k][j],matrix[max_r][j]);<Finish/></txt><txt ptr="0xa99b2eb8" next="0xa99b2f48" prev="0xa99b2e28" upper="0xa999cc68" lower="(nil)">}<Finish/></txt><txt ptr="0xa99b2f48" next="0xa99b301c" prev="0xa99b2eb8" upper="0xa999cc68" lower="(nil)">// 说明col列第k行以下全是0了，则处理下一列 <Finish/></txt><txt ptr="0xa99b301c" next="(nil)" prev="0xa99b2f48" upper="0xa999cc68" lower="(nil)">**if(matrix[k][col] == 0){k--;continue;}<Finish/></txt></body></column></section></body><footer ptr="0xa8998120" next="(nil)" prev="0xa8995600" upper="0xa89931d0" lower="0xa99bdf34"><txt ptr="0xa99bdf34" next="0xa99be128" prev="(nil)" upper="0xa8998120" lower="(nil)"><anchored><fly ptr="0xb289448" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99be008"><txt ptr="0xa99be008" next="0xa99be098" prev="(nil)" upper="0xb289448" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99be098" next="(nil)" prev="0xa99be008" upper="0xb289448" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="6"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99be128" next="(nil)" prev="0xa99bdf34" upper="0xa8998120" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993244" next="0xa89932b8" prev="0xa89931d0" upper="0xb0726b0" lower="0xa8996180"><header ptr="0xa8996180" next="0xa8995780" prev="(nil)" upper="0xa8993244" lower="0xa99bf48c"><txt ptr="0xa99bf48c" next="(nil)" prev="(nil)" upper="0xa8996180" lower="(nil)"><Finish/></txt></header><body ptr="0xa8995780" next="0xa8998180" prev="0xa8996180" upper="0xa8993244" lower="0xa99bca00"><section ptr="0xa99bca00" next="(nil)" prev="(nil)" upper="0xa8995780" lower="0xa99af838" follow="0xa99bc100" precede="0xa99bc380"><column ptr="0xa99af838" next="0xa99af6a8" prev="(nil)" upper="0xa99bca00" lower="0xa89957e0"><body ptr="0xa89957e0" next="(nil)" prev="(nil)" upper="0xa99af838" lower="0xa99b30ac"><txt ptr="0xa99b30ac" next="0xa99b313c" prev="(nil)" upper="0xa89957e0" lower="(nil)">**ta=matrix[k][col];<Finish/></txt><txt ptr="0xa99b313c" next="0xa99b31cc" prev="0xa99b30ac" upper="0xa89957e0" lower="(nil)">**//之后列的要化为0 <Finish/></txt><txt ptr="0xa99b31cc" next="0xa99b325c" prev="0xa99b313c" upper="0xa89957e0" lower="(nil)">**for(int i=k+1; i&lt;equ ;i++){<Finish/></txt><txt ptr="0xa99b325c" next="0xa99b32ec" prev="0xa99b31cc" upper="0xa89957e0" lower="(nil)">***if(matrix[i][col] != 0){<Finish/></txt><txt ptr="0xa99b32ec" next="0xa99b364c" prev="0xa99b325c" upper="0xa89957e0" lower="(nil)">****tb=matrix[i][col];<Finish/></txt><txt ptr="0xa99b364c" next="0xa99b36dc" prev="0xa99b32ec" upper="0xa89957e0" lower="(nil)">*for(int j=col;j&lt;=var;j++)<Finish/></txt><txt ptr="0xa99b36dc" next="0xa99b376c" prev="0xa99b364c" upper="0xa89957e0" lower="(nil)">**matrix[i][j]=matrix[i][j]*ta-matrix[k][j]*tb;<Finish/></txt><txt ptr="0xa99b376c" next="0xa99b37fc" prev="0xa99b36dc" upper="0xa89957e0" lower="(nil)">***}<Finish/></txt><txt ptr="0xa99b37fc" next="0xa99b388c" prev="0xa99b376c" upper="0xa89957e0" lower="(nil)">**}<Finish/></txt><txt ptr="0xa99b388c" next="0xa99b391c" prev="0xa99b37fc" upper="0xa89957e0" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99b391c" next="0xa99b39ac" prev="0xa99b388c" upper="0xa89957e0" lower="(nil)">// 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0). <Finish/></txt><txt ptr="0xa99b39ac" next="0xa99b3a3c" prev="0xa99b391c" upper="0xa89957e0" lower="(nil)">*for(int i=k;i&lt;equ;i++){<Finish/></txt><txt ptr="0xa99b3a3c" next="0xa99b3acc" prev="0xa99b39ac" upper="0xa89957e0" lower="(nil)">**if(matrix[i][var]!=0)return -1;//无解 <Finish/></txt><txt ptr="0xa99b3acc" next="0xa99b3b5c" prev="0xa99b3a3c" upper="0xa89957e0" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99b3b5c" next="0xa99b3bec" prev="0xa99b3acc" upper="0xa89957e0" lower="(nil)">// 无穷解的情况:<Finish/></txt><txt ptr="0xa99b3bec" next="0xa99b3c7c" prev="0xa99b3b5c" upper="0xa89957e0" lower="(nil)">if(k!=col || col&lt;var){<Finish/></txt><txt ptr="0xa99b3c7c" next="0xa99b3d0c" prev="0xa99b3bec" upper="0xa89957e0" lower="(nil)">*int free_x_num=0,free_index;<Finish/></txt><txt ptr="0xa99b3d0c" next="0xa99b3d9c" prev="0xa99b3c7c" upper="0xa89957e0" lower="(nil)">for(int i=k-1;i&gt;=0;i--,free_x_num=0){<Finish/></txt><txt ptr="0xa99b3d9c" next="0xa99b3e2c" prev="0xa99b3d0c" upper="0xa89957e0" lower="(nil)">for(int j=0;j&lt;var;j++){<Finish/></txt><txt ptr="0xa99b3e2c" next="0xa99b3ebc" prev="0xa99b3d9c" upper="0xa89957e0" lower="(nil)">if(matrix[i][j]&amp;&amp;free_x[j]) <Finish/></txt><txt ptr="0xa99b3ebc" next="0xa99b3f4c" prev="0xa99b3e2c" upper="0xa89957e0" lower="(nil)">free_x_num++,free_index=j;<Finish/></txt><txt ptr="0xa99b3f4c" next="0xa99b5020" prev="0xa99b3ebc" upper="0xa89957e0" lower="(nil)">}*<Finish/></txt><txt ptr="0xa99b5020" next="0xa99b50b0" prev="0xa99b3f4c" upper="0xa89957e0" lower="(nil)">if(free_x_num&gt;1)continue;<Finish/></txt><txt ptr="0xa99b50b0" next="0xa99b5140" prev="0xa99b5020" upper="0xa89957e0" lower="(nil)">tmp=matrix[i][var];<Finish/></txt><txt ptr="0xa99b5140" next="0xa99b51d0" prev="0xa99b50b0" upper="0xa89957e0" lower="(nil)">for(int j=0;j&lt;var;j++){<Finish/></txt><txt ptr="0xa99b51d0" next="0xa99b5260" prev="0xa99b5140" upper="0xa89957e0" lower="(nil)">if(matrix[i][j]&amp;&amp; j!=free_index)<Finish/></txt><txt ptr="0xa99b5260" next="(nil)" prev="0xa99b51d0" upper="0xa89957e0" lower="(nil)">tmp-=matrix[i][j]*ans[j];<Finish/></txt></body></column><column ptr="0xa99af6a8" next="0xa99af644" prev="0xa99af838" upper="0xa99bca00" lower="0xa89895b4"><body ptr="0xa89895b4" next="(nil)" prev="(nil)" upper="0xa99af6a8" lower="0xa99b52f0"><txt ptr="0xa99b52f0" next="0xa99b5380" prev="(nil)" upper="0xa89895b4" lower="(nil)">}**<Finish/></txt><txt ptr="0xa99b5380" next="0xa99b5410" prev="0xa99b52f0" upper="0xa89895b4" lower="(nil)">ans[free_index]=tmp/matrix[i][free_index];*<Finish/></txt><txt ptr="0xa99b5410" next="0xa99b54a0" prev="0xa99b5380" upper="0xa89895b4" lower="(nil)">free_x[free_index]=0;**<Finish/></txt><txt ptr="0xa99b54a0" next="0xa99b5530" prev="0xa99b5410" upper="0xa89895b4" lower="(nil)">}<Finish/></txt><txt ptr="0xa99b5530" next="0xa99b55c0" prev="0xa99b54a0" upper="0xa89895b4" lower="(nil)">return var - k;// 自由变元有var - k个.<Finish/></txt><txt ptr="0xa99b55c0" next="0xa99b5650" prev="0xa99b5530" upper="0xa89895b4" lower="(nil)">}<Finish/></txt><txt ptr="0xa99b5650" next="0xa99b56e0" prev="0xa99b55c0" upper="0xa89895b4" lower="(nil)">// 3. 唯一解: 在增广阵中形成严格的上三角阵.    <Finish/></txt><txt ptr="0xa99b56e0" next="0xa99b5770" prev="0xa99b5650" upper="0xa89895b4" lower="(nil)">*for(int i=var-1;i&gt;=0;i--){<Finish/></txt><txt ptr="0xa99b5770" next="0xa99b5800" prev="0xa99b56e0" upper="0xa89895b4" lower="(nil)">**tmp=matrix[i][var];<Finish/></txt><txt ptr="0xa99b5800" next="0xa99b5890" prev="0xa99b5770" upper="0xa89895b4" lower="(nil)">**for(int j=i+1;j&lt;var;j++){<Finish/></txt><txt ptr="0xa99b5890" next="0xa99b5bf0" prev="0xa99b5800" upper="0xa89895b4" lower="(nil)">***tmp-=matrix[i][j]*ans[j];<Finish/></txt><txt ptr="0xa99b5bf0" next="0xa99b5c80" prev="0xa99b5890" upper="0xa89895b4" lower="(nil)">**}<Finish/></txt><txt ptr="0xa99b5c80" next="0xa99b5d10" prev="0xa99b5bf0" upper="0xa89895b4" lower="(nil)">if(tmp % matrix[i][i])return -1;// 说明有浮点数解**ans[i]=tmp/matrix[i][i];<Finish/></txt><txt ptr="0xa99b5d10" next="0xa99b5da0" prev="0xa99b5c80" upper="0xa89895b4" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99b5da0" next="0xa99b5e30" prev="0xa99b5d10" upper="0xa89895b4" lower="(nil)">*return 0;*<Finish/></txt><txt ptr="0xa99b5e30" next="0xa99b5ec0" prev="0xa99b5da0" upper="0xa89895b4" lower="(nil)">}<Finish/></txt><txt ptr="0xa99b5ec0" next="0xa99b5f50" prev="0xa99b5e30" upper="0xa89895b4" lower="(nil)">母函数<Finish/></txt><txt ptr="0xa99b5f50" next="0xa99b6024" prev="0xa99b5ec0" upper="0xa89895b4" lower="(nil)">母函数（整数拆分）<Finish/></txt><txt ptr="0xa99b6024" next="0xa99b60b4" prev="0xa99b5f50" upper="0xa89895b4" lower="(nil)">*while(~scanf(&quot;%d&quot;,&amp;n)){<Finish/></txt><txt ptr="0xa99b60b4" next="0xa99b6144" prev="0xa99b6024" upper="0xa89895b4" lower="(nil)">**memset(second,0,sizeof(second));<Finish/></txt><txt ptr="0xa99b6144" next="0xa99b61d4" prev="0xa99b60b4" upper="0xa89895b4" lower="(nil)">**first[0]=1;_max=0;<Finish/></txt><txt ptr="0xa99b61d4" next="0xa99b6264" prev="0xa99b6144" upper="0xa89895b4" lower="(nil)">**for(i=1;i&lt;=n;i++){<Finish/></txt><txt ptr="0xa99b6264" next="0xa99b62f4" prev="0xa99b61d4" upper="0xa89895b4" lower="(nil)">***_maxtmp=_max;<Finish/></txt><txt ptr="0xa99b62f4" next="0xa99b6384" prev="0xa99b6264" upper="0xa89895b4" lower="(nil)">***for(j=0;j&lt;=_max;j++){<Finish/></txt><txt ptr="0xa99b6384" next="0xa99b6414" prev="0xa99b62f4" upper="0xa89895b4" lower="(nil)">****for(k=0; k+j&lt;=n;k+=i){<Finish/></txt><txt ptr="0xa99b6414" next="(nil)" prev="0xa99b6384" upper="0xa89895b4" lower="(nil)">*****second[k+j]+=first[j];<Finish/></txt></body></column><column ptr="0xa99af644" next="(nil)" prev="0xa99af6a8" upper="0xa99bca00" lower="0xa998e18c"><body ptr="0xa998e18c" next="(nil)" prev="(nil)" upper="0xa99af644" lower="0xa99b64a4"><txt ptr="0xa99b64a4" next="0xa99b6534" prev="(nil)" upper="0xa998e18c" lower="(nil)">**if(k+j&gt;_maxtmp &amp;&amp; k+j&lt;=n)_maxtmp=k+j;<Finish/></txt><txt ptr="0xa99b6534" next="0xa99b65c4" prev="0xa99b64a4" upper="0xa998e18c" lower="(nil)">****}<Finish/></txt><txt ptr="0xa99b65c4" next="0xa99b6654" prev="0xa99b6534" upper="0xa998e18c" lower="(nil)">***}<Finish/></txt><txt ptr="0xa99b6654" next="0xa99b66e4" prev="0xa99b65c4" upper="0xa998e18c" lower="(nil)">***_max=_maxtmp;<Finish/></txt><txt ptr="0xa99b66e4" next="0xa99b6774" prev="0xa99b6654" upper="0xa998e18c" lower="(nil)">***for(j=0;j&lt;=_max;j++){<Finish/></txt><txt ptr="0xa99b6774" next="0xa99b6804" prev="0xa99b66e4" upper="0xa998e18c" lower="(nil)">****first[j]=second[j];<Finish/></txt><txt ptr="0xa99b6804" next="0xa99b6894" prev="0xa99b6774" upper="0xa998e18c" lower="(nil)">****second[j]=0;<Finish/></txt><txt ptr="0xa99b6894" next="0xa99b6924" prev="0xa99b6804" upper="0xa998e18c" lower="(nil)">***}<Finish/></txt><txt ptr="0xa99b6924" next="0xa99b69b4" prev="0xa99b6894" upper="0xa998e18c" lower="(nil)">**}<Finish/></txt><txt ptr="0xa99b69b4" next="0xa99b6a44" prev="0xa99b6924" upper="0xa998e18c" lower="(nil)">**printf(&quot;%d\n&quot;,first[n]);<Finish/></txt><txt ptr="0xa99b6a44" next="0xa99b6ad4" prev="0xa99b69b4" upper="0xa998e18c" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99b6ad4" next="0xa99b6b64" prev="0xa99b6a44" upper="0xa998e18c" lower="(nil)"><Finish/></txt><txt ptr="0xa99b6b64" next="0xa99b6bf4" prev="0xa99b6ad4" upper="0xa998e18c" lower="(nil)">指数型母函数<Finish/></txt><txt ptr="0xa99b6bf4" next="0xa99b6c84" prev="0xa99b6b64" upper="0xa998e18c" lower="(nil)">G(x) =<Finish/></txt><txt ptr="0xa99b6c84" next="0xa99b6d14" prev="0xa99b6bf4" upper="0xa998e18c" lower="(nil)"> (1+x^1/1!+x^2/2!+…+x^n1/(n1)!)* <Finish/></txt><txt ptr="0xa99b6d14" next="0xa99b6da4" prev="0xa99b6c84" upper="0xa998e18c" lower="(nil)">(1+x^1/1! +x^2/2!+ …+x^n2/(n2)!)*<Finish/></txt><txt ptr="0xa99b6da4" next="0xa99b6e34" prev="0xa99b6d14" upper="0xa998e18c" lower="(nil)">…<Finish/></txt><txt ptr="0xa99b6e34" next="0xa99b71d8" prev="0xa99b6da4" upper="0xa998e18c" lower="(nil)">*(1+x^1/1!+x^2/2!+…+x^nk/(nk!))。 <Finish/></txt><txt ptr="0xa99b71d8" next="0xa99b7268" prev="0xa99b6e34" upper="0xa998e18c" lower="(nil)">约瑟夫问题<Finish/></txt><txt ptr="0xa99b7268" next="0xa99b72f8" prev="0xa99b71d8" upper="0xa998e18c" lower="(nil)">N个人，从1开始报数，报到m的人退出<Finish/></txt><txt ptr="0xa99b72f8" next="0xa99b7388" prev="0xa99b7268" upper="0xa998e18c" lower="(nil)">模拟方法就不说了，这里主要说数学方法<Finish/></txt><txt ptr="0xa99b7388" next="0xa99b7418" prev="0xa99b72f8" upper="0xa998e18c" lower="(nil)">  令f表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n].*  递推公式:*  f[1]=0;*  f[i]=(f[i-1]+m)%i; (i&gt;1)<Finish/></txt><txt ptr="0xa99b7418" next="(nil)" prev="0xa99b7388" upper="0xa998e18c" lower="(nil)">int fun(int n,int m){<Finish/></txt></body></column></section></body><footer ptr="0xa8998180" next="(nil)" prev="0xa8995780" upper="0xa8993244" lower="0xa99bf51c"><txt ptr="0xa99bf51c" next="0xa99bf6cc" prev="(nil)" upper="0xa8998180" lower="(nil)"><anchored><fly ptr="0xb2c7b70" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99bf5ac"><txt ptr="0xa99bf5ac" next="0xa99bf63c" prev="(nil)" upper="0xb2c7b70" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99bf63c" next="(nil)" prev="0xa99bf5ac" upper="0xb2c7b70" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="7"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99bf6cc" next="(nil)" prev="0xa99bf51c" upper="0xa8998180" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa89932b8" next="0xa899332c" prev="0xa8993244" upper="0xb0726b0" lower="0xa89961e0"><header ptr="0xa89961e0" next="0xa8995900" prev="(nil)" upper="0xa89932b8" lower="0xa99c0a30"><txt ptr="0xa99c0a30" next="(nil)" prev="(nil)" upper="0xa89961e0" lower="(nil)"><Finish/></txt></header><body ptr="0xa8995900" next="0xa89981e0" prev="0xa89961e0" upper="0xa89932b8" lower="0xa99bc100"><section ptr="0xa99bc100" next="(nil)" prev="(nil)" upper="0xa8995900" lower="0xa88ef474" follow="0xa99bc080" precede="0xa99bca00"><column ptr="0xa88ef474" next="0xa88ef4d8" prev="(nil)" upper="0xa99bc100" lower="0xa8995b40"><body ptr="0xa8995b40" next="(nil)" prev="(nil)" upper="0xa88ef474" lower="0xa99b74a8"><txt ptr="0xa99b74a8" next="0xa99b7538" prev="(nil)" upper="0xa8995b40" lower="(nil)">*int ans=0;<Finish/></txt><txt ptr="0xa99b7538" next="0xa99b75c8" prev="0xa99b74a8" upper="0xa8995b40" lower="(nil)">*for(int i=2;i&lt;=n;i++)ans=(ans+m)%i;<Finish/></txt><txt ptr="0xa99b75c8" next="0xa99b7658" prev="0xa99b7538" upper="0xa8995b40" lower="(nil)">*return ans+1;<Finish/></txt><txt ptr="0xa99b7658" next="0xa99b76e8" prev="0xa99b75c8" upper="0xa8995b40" lower="(nil)">}<Finish/></txt><txt ptr="0xa99b76e8" next="0xa99b7778" prev="0xa99b7658" upper="0xa8995b40" lower="(nil)">汉诺塔升级版<Finish/></txt><txt ptr="0xa99b7778" next="0xa99b7808" prev="0xa99b76e8" upper="0xa8995b40" lower="(nil)">用n个盘子，最后全放在第二个,调用hanio(2,n-1)<Finish/></txt><txt ptr="0xa99b7808" next="0xa99b7898" prev="0xa99b7778" upper="0xa8995b40" lower="(nil)">int pos[66];<Finish/></txt><txt ptr="0xa99b7898" next="0xa99b7928" prev="0xa99b7808" upper="0xa8995b40" lower="(nil)">__int64 hanio(int b,int m){<Finish/></txt><txt ptr="0xa99b7928" next="0xa99b79b8" prev="0xa99b7898" upper="0xa8995b40" lower="(nil)">*if(m==0) return pos[m]!=b;<Finish/></txt><txt ptr="0xa99b79b8" next="0xa99b7a48" prev="0xa99b7928" upper="0xa8995b40" lower="(nil)">*if(pos[m] == b)return hanio(b,m-1);<Finish/></txt><txt ptr="0xa99b7a48" next="0xa99b7ad8" prev="0xa99b79b8" upper="0xa8995b40" lower="(nil)">*return hanio(6-b-pos[m],m-1)+((__int64)1&lt;&lt;m);<Finish/></txt><txt ptr="0xa99b7ad8" next="0xa99b7b68" prev="0xa99b7a48" upper="0xa8995b40" lower="(nil)">}<Finish/></txt><txt ptr="0xa99b7b68" next="0xa99b7bf8" prev="0xa99b7ad8" upper="0xa8995b40" lower="(nil)">快速排序<Finish/></txt><txt ptr="0xa99b7bf8" next="0xa99b7c88" prev="0xa99b7b68" upper="0xa8995b40" lower="(nil)">//调用ksort(0,n,s) <Finish/></txt><txt ptr="0xa99b7c88" next="0xa99b7d18" prev="0xa99b7bf8" upper="0xa8995b40" lower="(nil)">void ksort(int l, int h, int a[]){<Finish/></txt><txt ptr="0xa99b7d18" next="0xa99b7da8" prev="0xa99b7c88" upper="0xa8995b40" lower="(nil)">*if (h &lt; l + 2) return;<Finish/></txt><txt ptr="0xa99b7da8" next="0xa99b7e38" prev="0xa99b7d18" upper="0xa8995b40" lower="(nil)">*int e = h, p = l;<Finish/></txt><txt ptr="0xa99b7e38" next="0xa99b7ec8" prev="0xa99b7da8" upper="0xa8995b40" lower="(nil)">*while (l &lt; h) {<Finish/></txt><txt ptr="0xa99b7ec8" next="0xa99b7f58" prev="0xa99b7e38" upper="0xa8995b40" lower="(nil)">**while (++l &lt; e &amp;&amp; a[l] &lt;= a[p]);<Finish/></txt><txt ptr="0xa99b7f58" next="0xa99b8000" prev="0xa99b7ec8" upper="0xa8995b40" lower="(nil)">**while (--h &gt; p &amp;&amp; a[h] &gt;= a[p]);<Finish/></txt><txt ptr="0xa99b8000" next="0xa99b8090" prev="0xa99b7f58" upper="0xa8995b40" lower="(nil)">**if (l &lt; h) swap(a[l], a[h]);<Finish/></txt><txt ptr="0xa99b8090" next="0xa99b8120" prev="0xa99b8000" upper="0xa8995b40" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99b8120" next="0xa99b81b0" prev="0xa99b8090" upper="0xa8995b40" lower="(nil)">*swap(a[h], a[p]);<Finish/></txt><txt ptr="0xa99b81b0" next="0xa99b8240" prev="0xa99b8120" upper="0xa8995b40" lower="(nil)">*ksort(p, h, a); ksort(l, e, a);<Finish/></txt><txt ptr="0xa99b8240" next="(nil)" prev="0xa99b81b0" upper="0xa8995b40" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa88ef4d8" next="0xa88ef53c" prev="0xa88ef474" upper="0xa99bc100" lower="0xa8995ba0"><body ptr="0xa8995ba0" next="(nil)" prev="(nil)" upper="0xa88ef4d8" lower="0xa99b82d0"><txt ptr="0xa99b82d0" next="0xa99b8360" prev="(nil)" upper="0xa8995ba0" lower="(nil)">堆<Finish/></txt><txt ptr="0xa99b8360" next="0xa99b83f0" prev="0xa99b82d0" upper="0xa8995ba0" lower="(nil)">const int maxn = 10000;<Finish/></txt><txt ptr="0xa99b83f0" next="0xa99b8750" prev="0xa99b8360" upper="0xa8995ba0" lower="(nil)"> <Finish/></txt><txt ptr="0xa99b8750" next="0xa99b87e0" prev="0xa99b83f0" upper="0xa8995ba0" lower="(nil)">struct Heap{<Finish/></txt><txt ptr="0xa99b87e0" next="0xa99b8870" prev="0xa99b8750" upper="0xa8995ba0" lower="(nil)">    int size;<Finish/></txt><txt ptr="0xa99b8870" next="0xa99b8900" prev="0xa99b87e0" upper="0xa8995ba0" lower="(nil)">    int array[maxn];<Finish/></txt><txt ptr="0xa99b8900" next="0xa99b8990" prev="0xa99b8870" upper="0xa8995ba0" lower="(nil)">    void bulid();<Finish/></txt><txt ptr="0xa99b8990" next="0xa99b8a20" prev="0xa99b8900" upper="0xa8995ba0" lower="(nil)">    void insert(int val);<Finish/></txt><txt ptr="0xa99b8a20" next="0xa99b8ab0" prev="0xa99b8990" upper="0xa8995ba0" lower="(nil)">    int top();<Finish/></txt><txt ptr="0xa99b8ab0" next="0xa99b8b40" prev="0xa99b8a20" upper="0xa8995ba0" lower="(nil)">    void pop();<Finish/></txt><txt ptr="0xa99b8b40" next="0xa99b8bd0" prev="0xa99b8ab0" upper="0xa8995ba0" lower="(nil)">    bool empty();<Finish/></txt><txt ptr="0xa99b8bd0" next="0xa99b8c60" prev="0xa99b8b40" upper="0xa8995ba0" lower="(nil)">    void push_down(int pre);<Finish/></txt><txt ptr="0xa99b8c60" next="0xa99b8cf0" prev="0xa99b8bd0" upper="0xa8995ba0" lower="(nil)">    void push_up(int son);<Finish/></txt><txt ptr="0xa99b8cf0" next="0xa99b8d80" prev="0xa99b8c60" upper="0xa8995ba0" lower="(nil)">    bool compare(int pre,int son);<Finish/></txt><txt ptr="0xa99b8d80" next="0xa99b8e10" prev="0xa99b8cf0" upper="0xa8995ba0" lower="(nil)">};<Finish/></txt><txt ptr="0xa99b8e10" next="0xa99b8ea0" prev="0xa99b8d80" upper="0xa8995ba0" lower="(nil)"><Finish/></txt><txt ptr="0xa99b8ea0" next="0xa99b8f30" prev="0xa99b8e10" upper="0xa8995ba0" lower="(nil)">void Heap::bulid(){<Finish/></txt><txt ptr="0xa99b8f30" next="0xa999a004" prev="0xa99b8ea0" upper="0xa8995ba0" lower="(nil)">    size = 0;<Finish/></txt><txt ptr="0xa999a004" next="0xa999a094" prev="0xa99b8f30" upper="0xa8995ba0" lower="(nil)">}<Finish/></txt><txt ptr="0xa999a094" next="0xa999a124" prev="0xa999a004" upper="0xa8995ba0" lower="(nil)"><Finish/></txt><txt ptr="0xa999a124" next="0xa999a1b4" prev="0xa999a094" upper="0xa8995ba0" lower="(nil)">void Heap::insert(int val){<Finish/></txt><txt ptr="0xa999a1b4" next="0xa999a244" prev="0xa999a124" upper="0xa8995ba0" lower="(nil)">    array[++size] = val;<Finish/></txt><txt ptr="0xa999a244" next="0xa999a2d4" prev="0xa999a1b4" upper="0xa8995ba0" lower="(nil)">    push_up(size);<Finish/></txt><txt ptr="0xa999a2d4" next="0xa999a364" prev="0xa999a244" upper="0xa8995ba0" lower="(nil)">}<Finish/></txt><txt ptr="0xa999a364" next="0xa999a3f4" prev="0xa999a2d4" upper="0xa8995ba0" lower="(nil)"><Finish/></txt><txt ptr="0xa999a3f4" next="0xa999a484" prev="0xa999a364" upper="0xa8995ba0" lower="(nil)">int Heap::top(){<Finish/></txt><txt ptr="0xa999a484" next="(nil)" prev="0xa999a3f4" upper="0xa8995ba0" lower="(nil)">    return array[1];<Finish/></txt></body></column><column ptr="0xa88ef53c" next="(nil)" prev="0xa88ef4d8" upper="0xa99bc100" lower="0xa8995de0"><body ptr="0xa8995de0" next="(nil)" prev="(nil)" upper="0xa88ef53c" lower="0xa999a514"><txt ptr="0xa999a514" next="0xa999a5a4" prev="(nil)" upper="0xa8995de0" lower="(nil)">}*<Finish/></txt><txt ptr="0xa999a5a4" next="0xa999a634" prev="0xa999a514" upper="0xa8995de0" lower="(nil)"><Finish/></txt><txt ptr="0xa999a634" next="0xa999a6c4" prev="0xa999a5a4" upper="0xa8995de0" lower="(nil)">void Heap::pop(){<Finish/></txt><txt ptr="0xa999a6c4" next="0xa999a754" prev="0xa999a634" upper="0xa8995de0" lower="(nil)">    array[1] = array[size--];<Finish/></txt><txt ptr="0xa999a754" next="0xa999a7e4" prev="0xa999a6c4" upper="0xa8995de0" lower="(nil)">    push_down(1);<Finish/></txt><txt ptr="0xa999a7e4" next="0xa999a874" prev="0xa999a754" upper="0xa8995de0" lower="(nil)">}<Finish/></txt><txt ptr="0xa999a874" next="0xa999a904" prev="0xa999a7e4" upper="0xa8995de0" lower="(nil)"><Finish/></txt><txt ptr="0xa999a904" next="0xa999a994" prev="0xa999a874" upper="0xa8995de0" lower="(nil)">bool Heap::empty(){<Finish/></txt><txt ptr="0xa999a994" next="0xa999acf4" prev="0xa999a904" upper="0xa8995de0" lower="(nil)">    return size == 0;<Finish/></txt><txt ptr="0xa999acf4" next="0xa999ad84" prev="0xa999a994" upper="0xa8995de0" lower="(nil)">}<Finish/></txt><txt ptr="0xa999ad84" next="0xa999ae14" prev="0xa999acf4" upper="0xa8995de0" lower="(nil)">void Heap::push_down_loop(int pre){<Finish/></txt><txt ptr="0xa999ae14" next="0xa999aea4" prev="0xa999ad84" upper="0xa8995de0" lower="(nil)">    while(true){<Finish/></txt><txt ptr="0xa999aea4" next="0xa999af34" prev="0xa999ae14" upper="0xa8995de0" lower="(nil)">       if((pre&lt;&lt;1|1)&lt;= size &amp;&amp; compare(pre&lt;&lt;1|1,pre) <Finish/></txt><txt ptr="0xa999af34" next="0xa999b008" prev="0xa999aea4" upper="0xa8995de0" lower="(nil)">&amp;&amp; compare(pre&lt;&lt;1|1,pre&lt;&lt;1)){<Finish/></txt><txt ptr="0xa999b008" next="0xa999b098" prev="0xa999af34" upper="0xa8995de0" lower="(nil)">            //判断右儿子是否是父亲<Finish/></txt><txt ptr="0xa999b098" next="0xa999b128" prev="0xa999b008" upper="0xa8995de0" lower="(nil)">            swap(array[pre],array[pre&lt;&lt;1|1]);<Finish/></txt><txt ptr="0xa999b128" next="0xa999b1b8" prev="0xa999b098" upper="0xa8995de0" lower="(nil)">            pre = pre&lt;&lt;1|1;<Finish/></txt><txt ptr="0xa999b1b8" next="0xa999b248" prev="0xa999b128" upper="0xa8995de0" lower="(nil)">   }else if((pre&lt;&lt;1) &lt;= size &amp;&amp; compare(pre&lt;&lt;1,pre)){<Finish/></txt><txt ptr="0xa999b248" next="0xa999b2d8" prev="0xa999b1b8" upper="0xa8995de0" lower="(nil)">            //判断左儿子是否是父亲<Finish/></txt><txt ptr="0xa999b2d8" next="0xa999b368" prev="0xa999b248" upper="0xa8995de0" lower="(nil)">            swap(array[pre],array[pre&lt;&lt;1]);<Finish/></txt><txt ptr="0xa999b368" next="0xa999b3f8" prev="0xa999b2d8" upper="0xa8995de0" lower="(nil)">             pre = pre&lt;&lt;1;<Finish/></txt><txt ptr="0xa999b3f8" next="0xa999b488" prev="0xa999b368" upper="0xa8995de0" lower="(nil)">        }else{<Finish/></txt><txt ptr="0xa999b488" next="0xa999b518" prev="0xa999b3f8" upper="0xa8995de0" lower="(nil)">            break;<Finish/></txt><txt ptr="0xa999b518" next="0xa999b5a8" prev="0xa999b488" upper="0xa8995de0" lower="(nil)">        }<Finish/></txt><txt ptr="0xa999b5a8" next="0xa999b638" prev="0xa999b518" upper="0xa8995de0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa999b638" next="0xa999b6c8" prev="0xa999b5a8" upper="0xa8995de0" lower="(nil)">}<Finish/></txt><txt ptr="0xa999b6c8" next="0xa999b758" prev="0xa999b638" upper="0xa8995de0" lower="(nil)">void Heap::push_up(int son){<Finish/></txt><txt ptr="0xa999b758" next="(nil)" prev="0xa999b6c8" upper="0xa8995de0" lower="(nil)">    if(son == 1)return ;<Finish/></txt></body></column></section></body><footer ptr="0xa89981e0" next="(nil)" prev="0xa8995900" upper="0xa89932b8" lower="0xa99c0ac0"><txt ptr="0xa99c0ac0" next="0xa99c0c70" prev="(nil)" upper="0xa89981e0" lower="(nil)"><anchored><fly ptr="0xb2fb488" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99c0b50"><txt ptr="0xa99c0b50" next="0xa99c0be0" prev="(nil)" upper="0xb2fb488" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99c0be0" next="(nil)" prev="0xa99c0b50" upper="0xb2fb488" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="8"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99c0c70" next="(nil)" prev="0xa99c0ac0" upper="0xa89981e0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa899332c" next="0xa89933a0" prev="0xa89932b8" upper="0xb0726b0" lower="0xa8996240"><header ptr="0xa8996240" next="0xa8995a80" prev="(nil)" upper="0xa899332c" lower="0xa99c3018"><txt ptr="0xa99c3018" next="(nil)" prev="(nil)" upper="0xa8996240" lower="(nil)"><Finish/></txt></header><body ptr="0xa8995a80" next="0xa8998240" prev="0xa8996240" upper="0xa899332c" lower="0xa99bc080"><section ptr="0xa99bc080" next="(nil)" prev="(nil)" upper="0xa8995a80" lower="0xa88ef5a0" follow="0xa998c504" precede="0xa99bc100"><column ptr="0xa88ef5a0" next="0xa88ef604" prev="(nil)" upper="0xa99bc080" lower="0xa998e48c"><body ptr="0xa998e48c" next="(nil)" prev="(nil)" upper="0xa88ef5a0" lower="0xa999b7e8"><txt ptr="0xa999b7e8" next="0xa999b878" prev="(nil)" upper="0xa998e48c" lower="(nil)">    int pre = son&gt;&gt;1;<Finish/></txt><txt ptr="0xa999b878" next="0xa999b908" prev="0xa999b7e8" upper="0xa998e48c" lower="(nil)">    if(!compare(pre,son)){<Finish/></txt><txt ptr="0xa999b908" next="0xa999b998" prev="0xa999b878" upper="0xa998e48c" lower="(nil)">        swap(array[pre],array[son]);<Finish/></txt><txt ptr="0xa999b998" next="0xa999ba28" prev="0xa999b908" upper="0xa998e48c" lower="(nil)">        push_up(pre);<Finish/></txt><txt ptr="0xa999ba28" next="0xa999bab8" prev="0xa999b998" upper="0xa998e48c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa999bab8" next="0xa999bb48" prev="0xa999ba28" upper="0xa998e48c" lower="(nil)">}<Finish/></txt><txt ptr="0xa999bb48" next="0xa999bbd8" prev="0xa999bab8" upper="0xa998e48c" lower="(nil)">//堆的性质返回true<Finish/></txt><txt ptr="0xa999bbd8" next="0xa999bc68" prev="0xa999bb48" upper="0xa998e48c" lower="(nil)">//也就是儿子不大于父亲返回true<Finish/></txt><txt ptr="0xa999bc68" next="0xa999bcf8" prev="0xa999bbd8" upper="0xa998e48c" lower="(nil)">bool Heap::compare(int pre,int son){<Finish/></txt><txt ptr="0xa999bcf8" next="0xa999bd88" prev="0xa999bc68" upper="0xa998e48c" lower="(nil)">    return array[pre] &gt;= array[son];//最大堆<Finish/></txt><txt ptr="0xa999bd88" next="0xa999be18" prev="0xa999bcf8" upper="0xa998e48c" lower="(nil)">   // return array[pre] &lt;= array[son];//最小堆<Finish/></txt><txt ptr="0xa999be18" next="0xa999bea8" prev="0xa999bd88" upper="0xa998e48c" lower="(nil)">}<Finish/></txt><txt ptr="0xa999bea8" next="0xa999bf38" prev="0xa999be18" upper="0xa998e48c" lower="(nil)"><Finish/></txt><txt ptr="0xa999bf38" next="0xa999d2dc" prev="0xa999bea8" upper="0xa998e48c" lower="(nil)">最大堆<Finish/></txt><txt ptr="0xa999d2dc" next="0xa999d36c" prev="0xa999bf38" upper="0xa998e48c" lower="(nil)">const int MAXSIZE=10000;<Finish/></txt><txt ptr="0xa999d36c" next="0xa999d3fc" prev="0xa999d2dc" upper="0xa998e48c" lower="(nil)">class MaxHeap{<Finish/></txt><txt ptr="0xa999d3fc" next="0xa999d48c" prev="0xa999d36c" upper="0xa998e48c" lower="(nil)">public:<Finish/></txt><txt ptr="0xa999d48c" next="0xa999d51c" prev="0xa999d3fc" upper="0xa998e48c" lower="(nil)">*MaxHeap(){size=0; } <Finish/></txt><txt ptr="0xa999d51c" next="0xa999d5ac" prev="0xa999d48c" upper="0xa998e48c" lower="(nil)">*void push(int val){<Finish/></txt><txt ptr="0xa999d5ac" next="0xa999d63c" prev="0xa999d51c" upper="0xa998e48c" lower="(nil)">**a[++size]=val;<Finish/></txt><txt ptr="0xa999d63c" next="0xa999d6cc" prev="0xa999d5ac" upper="0xa998e48c" lower="(nil)">**pushup(size);<Finish/></txt><txt ptr="0xa999d6cc" next="0xa999d75c" prev="0xa999d63c" upper="0xa998e48c" lower="(nil)">*} <Finish/></txt><txt ptr="0xa999d75c" next="0xa999d7ec" prev="0xa999d6cc" upper="0xa998e48c" lower="(nil)">*void pop(){<Finish/></txt><txt ptr="0xa999d7ec" next="0xa999d87c" prev="0xa999d75c" upper="0xa998e48c" lower="(nil)">**a[1]=a[size--];<Finish/></txt><txt ptr="0xa999d87c" next="0xa999d90c" prev="0xa999d7ec" upper="0xa998e48c" lower="(nil)">**pushdown(1);<Finish/></txt><txt ptr="0xa999d90c" next="0xa999d99c" prev="0xa999d87c" upper="0xa998e48c" lower="(nil)">*}<Finish/></txt><txt ptr="0xa999d99c" next="(nil)" prev="0xa999d90c" upper="0xa998e48c" lower="(nil)">*int top(){return a[1];}<Finish/></txt></body></column><column ptr="0xa88ef604" next="0xa88ef668" prev="0xa88ef5a0" upper="0xa99bc080" lower="0xa8995ea0"><body ptr="0xa8995ea0" next="(nil)" prev="(nil)" upper="0xa88ef604" lower="0xa999da2c"><txt ptr="0xa999da2c" next="0xa999dabc" prev="(nil)" upper="0xa8995ea0" lower="(nil)">*bool empty(){return !size;}<Finish/></txt><txt ptr="0xa999dabc" next="0xa999db4c" prev="0xa999da2c" upper="0xa8995ea0" lower="(nil)">*<Finish/></txt><txt ptr="0xa999db4c" next="0xa999dbdc" prev="0xa999dabc" upper="0xa8995ea0" lower="(nil)">*private:<Finish/></txt><txt ptr="0xa999dbdc" next="0xa999dc6c" prev="0xa999db4c" upper="0xa8995ea0" lower="(nil)">*int a[MAXSIZE];<Finish/></txt><txt ptr="0xa999dc6c" next="0xa999dcfc" prev="0xa999dbdc" upper="0xa8995ea0" lower="(nil)">*int size;<Finish/></txt><txt ptr="0xa999dcfc" next="0xa999dd8c" prev="0xa999dc6c" upper="0xa8995ea0" lower="(nil)">*void pushdown(int now){<Finish/></txt><txt ptr="0xa999dd8c" next="0xa999de1c" prev="0xa999dcfc" upper="0xa8995ea0" lower="(nil)">**int l=now&lt;&lt;1;<Finish/></txt><txt ptr="0xa999de1c" next="0xa999deac" prev="0xa999dd8c" upper="0xa8995ea0" lower="(nil)">**int r=l+1;<Finish/></txt><txt ptr="0xa999deac" next="0xa999df3c" prev="0xa999de1c" upper="0xa8995ea0" lower="(nil)">**if(l==size){<Finish/></txt><txt ptr="0xa999df3c" next="0xa999e010" prev="0xa999deac" upper="0xa8995ea0" lower="(nil)">***if(com(a[now],a[l]))<Finish/></txt><txt ptr="0xa999e010" next="0xa999e0a0" prev="0xa999df3c" upper="0xa8995ea0" lower="(nil)">****swap(a[now],a[l]);<Finish/></txt><txt ptr="0xa999e0a0" next="0xa999e130" prev="0xa999e010" upper="0xa8995ea0" lower="(nil)">**}else if(r&lt;=size){<Finish/></txt><txt ptr="0xa999e130" next="0xa999e1c0" prev="0xa999e0a0" upper="0xa8995ea0" lower="(nil)">***int tmp=a[l]&gt;a[r]?l:r;<Finish/></txt><txt ptr="0xa999e1c0" next="0xa999e250" prev="0xa999e130" upper="0xa8995ea0" lower="(nil)">***if(com(a[now],a[tmp])){<Finish/></txt><txt ptr="0xa999e250" next="0xa999e2e0" prev="0xa999e1c0" upper="0xa8995ea0" lower="(nil)">****swap(a[now],a[tmp]);<Finish/></txt><txt ptr="0xa999e2e0" next="0xa999e370" prev="0xa999e250" upper="0xa8995ea0" lower="(nil)">****pushdown(tmp);<Finish/></txt><txt ptr="0xa999e370" next="0xa999e400" prev="0xa999e2e0" upper="0xa8995ea0" lower="(nil)">***}<Finish/></txt><txt ptr="0xa999e400" next="0xa999e490" prev="0xa999e370" upper="0xa8995ea0" lower="(nil)">**}<Finish/></txt><txt ptr="0xa999e490" next="0xa999e520" prev="0xa999e400" upper="0xa8995ea0" lower="(nil)">*}<Finish/></txt><txt ptr="0xa999e520" next="0xa999e880" prev="0xa999e490" upper="0xa8995ea0" lower="(nil)">*void pushup(int now){<Finish/></txt><txt ptr="0xa999e880" next="0xa999e910" prev="0xa999e520" upper="0xa8995ea0" lower="(nil)">**int pre=now&gt;&gt;1; <Finish/></txt><txt ptr="0xa999e910" next="0xa999e9a0" prev="0xa999e880" upper="0xa8995ea0" lower="(nil)">**if(pre &amp;&amp; com(a[pre],a[now])){<Finish/></txt><txt ptr="0xa999e9a0" next="0xa999ea30" prev="0xa999e910" upper="0xa8995ea0" lower="(nil)">***swap(a[pre],a[now]);<Finish/></txt><txt ptr="0xa999ea30" next="0xa999eac0" prev="0xa999e9a0" upper="0xa8995ea0" lower="(nil)">***pushup(pre);<Finish/></txt><txt ptr="0xa999eac0" next="0xa999eb50" prev="0xa999ea30" upper="0xa8995ea0" lower="(nil)">**} <Finish/></txt><txt ptr="0xa999eb50" next="0xa999ebe0" prev="0xa999eac0" upper="0xa8995ea0" lower="(nil)">*}<Finish/></txt><txt ptr="0xa999ebe0" next="0xa999ec70" prev="0xa999eb50" upper="0xa8995ea0" lower="(nil)">*bool com(int aa,int bb){return aa&lt;bb;}<Finish/></txt><txt ptr="0xa999ec70" next="(nil)" prev="0xa999ebe0" upper="0xa8995ea0" lower="(nil)">};<Finish/></txt></body></column><column ptr="0xa88ef668" next="(nil)" prev="0xa88ef604" upper="0xa99bc080" lower="0xa99c8124"><body ptr="0xa99c8124" next="(nil)" prev="(nil)" upper="0xa88ef668" lower="0xa999ed00"><txt ptr="0xa999ed00" next="0xa999ed90" prev="(nil)" upper="0xa99c8124" lower="(nil)"><Finish/></txt><txt ptr="0xa999ed90" next="0xa999ee20" prev="0xa999ed00" upper="0xa99c8124" lower="(nil)">堆排序<Finish/></txt><txt ptr="0xa999ee20" next="0xa999eeb0" prev="0xa999ed90" upper="0xa99c8124" lower="(nil)">const int MAXSIZE=10000;<Finish/></txt><txt ptr="0xa999eeb0" next="0xa999ef40" prev="0xa999ee20" upper="0xa99c8124" lower="(nil)">int a[MAXSIZE],size; <Finish/></txt><txt ptr="0xa999ef40" next="0xa999f014" prev="0xa999eeb0" upper="0xa99c8124" lower="(nil)">void PushDown(int now){<Finish/></txt><txt ptr="0xa999f014" next="0xa999f0a4" prev="0xa999ef40" upper="0xa99c8124" lower="(nil)">*int l=now&lt;&lt;1;<Finish/></txt><txt ptr="0xa999f0a4" next="0xa999f134" prev="0xa999f014" upper="0xa99c8124" lower="(nil)">*int r=l+1;<Finish/></txt><txt ptr="0xa999f134" next="0xa999f1c4" prev="0xa999f0a4" upper="0xa99c8124" lower="(nil)">*if(l==size){<Finish/></txt><txt ptr="0xa999f1c4" next="0xa999f254" prev="0xa999f134" upper="0xa99c8124" lower="(nil)">**if(a[now]&lt;a[l])<Finish/></txt><txt ptr="0xa999f254" next="0xa999f2e4" prev="0xa999f1c4" upper="0xa99c8124" lower="(nil)">***swap(a[now],a[l]);<Finish/></txt><txt ptr="0xa999f2e4" next="0xa999f374" prev="0xa999f254" upper="0xa99c8124" lower="(nil)">*}else if(r&lt;=size){<Finish/></txt><txt ptr="0xa999f374" next="0xa999f404" prev="0xa999f2e4" upper="0xa99c8124" lower="(nil)">**int tmp=a[l]&gt;a[r]?l:r;<Finish/></txt><txt ptr="0xa999f404" next="0xa999f494" prev="0xa999f374" upper="0xa99c8124" lower="(nil)">**if(a[now]&lt;a[tmp]){<Finish/></txt><txt ptr="0xa999f494" next="0xa999f524" prev="0xa999f404" upper="0xa99c8124" lower="(nil)">***swap(a[now],a[tmp]);<Finish/></txt><txt ptr="0xa999f524" next="0xa999f5b4" prev="0xa999f494" upper="0xa99c8124" lower="(nil)">***PushDown(tmp);<Finish/></txt><txt ptr="0xa999f5b4" next="0xa999f644" prev="0xa999f524" upper="0xa99c8124" lower="(nil)">**}<Finish/></txt><txt ptr="0xa999f644" next="0xa999f6d4" prev="0xa999f5b4" upper="0xa99c8124" lower="(nil)">*}<Finish/></txt><txt ptr="0xa999f6d4" next="0xa999f764" prev="0xa999f644" upper="0xa99c8124" lower="(nil)">}<Finish/></txt><txt ptr="0xa999f764" next="0xa999f7f4" prev="0xa999f6d4" upper="0xa99c8124" lower="(nil)">void BuildMaxHeap(){<Finish/></txt><txt ptr="0xa999f7f4" next="0xa999f884" prev="0xa999f764" upper="0xa99c8124" lower="(nil)">*for(int i=size&gt;&gt;1;i;i--)PushDown(i);<Finish/></txt><txt ptr="0xa999f884" next="0xa999f914" prev="0xa999f7f4" upper="0xa99c8124" lower="(nil)">}<Finish/></txt><txt ptr="0xa999f914" next="0xa999f9a4" prev="0xa999f884" upper="0xa99c8124" lower="(nil)">void HeapSort(int n){<Finish/></txt><txt ptr="0xa999f9a4" next="0xa999fa34" prev="0xa999f914" upper="0xa99c8124" lower="(nil)">*size=n;<Finish/></txt><txt ptr="0xa999fa34" next="0xa999fac4" prev="0xa999f9a4" upper="0xa99c8124" lower="(nil)">*BuildMaxHeap();<Finish/></txt><txt ptr="0xa999fac4" next="0xa999fe24" prev="0xa999fa34" upper="0xa99c8124" lower="(nil)">*for(int i=size;i;i--){<Finish/></txt><txt ptr="0xa999fe24" next="0xa999feb4" prev="0xa999fac4" upper="0xa99c8124" lower="(nil)">**swap(a[i],a[1]);<Finish/></txt><txt ptr="0xa999feb4" next="0xa999ff44" prev="0xa999fe24" upper="0xa99c8124" lower="(nil)">**size--;<Finish/></txt><txt ptr="0xa999ff44" next="(nil)" prev="0xa999feb4" upper="0xa99c8124" lower="(nil)">**PushDown(1);<Finish/></txt></body></column></section></body><footer ptr="0xa8998240" next="(nil)" prev="0xa8995a80" upper="0xa899332c" lower="0xa99c30a8"><txt ptr="0xa99c30a8" next="0xa99c3258" prev="(nil)" upper="0xa8998240" lower="(nil)"><anchored><fly ptr="0xac5e4c0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99c3138"><txt ptr="0xa99c3138" next="0xa99c31c8" prev="(nil)" upper="0xac5e4c0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99c31c8" next="(nil)" prev="0xa99c3138" upper="0xac5e4c0" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="9"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99c3258" next="(nil)" prev="0xa99c30a8" upper="0xa8998240" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa89933a0" next="0xa8993414" prev="0xa899332c" upper="0xb0726b0" lower="0xa89962a0"><header ptr="0xa89962a0" next="0xa8995c00" prev="(nil)" upper="0xa89933a0" lower="0xa99c45bc"><txt ptr="0xa99c45bc" next="(nil)" prev="(nil)" upper="0xa89962a0" lower="(nil)"><Finish/></txt></header><body ptr="0xa8995c00" next="0xa89982a0" prev="0xa89962a0" upper="0xa89933a0" lower="0xa998c504"><section ptr="0xa998c504" next="(nil)" prev="(nil)" upper="0xa8995c00" lower="0xa997e070" follow="0xa998c604" precede="0xa99bc080"><column ptr="0xa997e070" next="0xa997e0d4" prev="(nil)" upper="0xa998c504" lower="0xa998ed2c"><body ptr="0xa998ed2c" next="(nil)" prev="(nil)" upper="0xa997e070" lower="0xa99a0018"><txt ptr="0xa99a0018" next="0xa99a00a8" prev="(nil)" upper="0xa998ed2c" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99a00a8" next="0xa99a0138" prev="0xa99a0018" upper="0xa998ed2c" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a0138" next="0xa99a01c8" prev="0xa99a00a8" upper="0xa998ed2c" lower="(nil)">归并排序求逆序数<Finish/></txt><txt ptr="0xa99a01c8" next="0xa99a0258" prev="0xa99a0138" upper="0xa998ed2c" lower="(nil)">int cnt=0;<Finish/></txt><txt ptr="0xa99a0258" next="0xa99a02e8" prev="0xa99a01c8" upper="0xa998ed2c" lower="(nil)">int str[N],tmp[N];<Finish/></txt><txt ptr="0xa99a02e8" next="0xa99a0378" prev="0xa99a0258" upper="0xa998ed2c" lower="(nil)">//调用 MergeSort（0，n） <Finish/></txt><txt ptr="0xa99a0378" next="0xa99a0408" prev="0xa99a02e8" upper="0xa998ed2c" lower="(nil)">void Merger(int l,int mid,int r){<Finish/></txt><txt ptr="0xa99a0408" next="0xa99a0498" prev="0xa99a0378" upper="0xa998ed2c" lower="(nil)">*int i, j, tmpnum=l;<Finish/></txt><txt ptr="0xa99a0498" next="0xa99a0528" prev="0xa99a0408" upper="0xa998ed2c" lower="(nil)"><Finish/></txt><txt ptr="0xa99a0528" next="0xa99a05b8" prev="0xa99a0498" upper="0xa998ed2c" lower="(nil)">*for( i=l, j=mid; i &lt; mid &amp;&amp; j &lt; r; ){<Finish/></txt><txt ptr="0xa99a05b8" next="0xa99a0648" prev="0xa99a0528" upper="0xa998ed2c" lower="(nil)">**if( str[i] &gt; str[j] ){<Finish/></txt><txt ptr="0xa99a0648" next="0xa99a06d8" prev="0xa99a05b8" upper="0xa998ed2c" lower="(nil)">***tmp[tmpnum++] = str[j++];<Finish/></txt><txt ptr="0xa99a06d8" next="0xa99a0768" prev="0xa99a0648" upper="0xa998ed2c" lower="(nil)">***cnt += mid-i; <Finish/></txt><txt ptr="0xa99a0768" next="0xa99a07f8" prev="0xa99a06d8" upper="0xa998ed2c" lower="(nil)">**}<Finish/></txt><txt ptr="0xa99a07f8" next="0xa99a0888" prev="0xa99a0768" upper="0xa998ed2c" lower="(nil)">**else tmp[tmpnum++] = str[i++];<Finish/></txt><txt ptr="0xa99a0888" next="0xa99a0918" prev="0xa99a07f8" upper="0xa998ed2c" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99a0918" next="0xa99a09a8" prev="0xa99a0888" upper="0xa998ed2c" lower="(nil)">*if( j &lt; r ) for( ; j &lt; r; ++j ) tmp[tmpnum++] = str[j];<Finish/></txt><txt ptr="0xa99a09a8" next="0xa99a0a38" prev="0xa99a0918" upper="0xa998ed2c" lower="(nil)">*else for( ; i &lt; mid; ++i ) tmp[tmpnum++] = str[i];<Finish/></txt><txt ptr="0xa99a0a38" next="0xa99a0ac8" prev="0xa99a09a8" upper="0xa998ed2c" lower="(nil)">*for ( i=l; i &lt; r; ++i ) str[i] = tmp[i];*<Finish/></txt><txt ptr="0xa99a0ac8" next="0xa99a0b58" prev="0xa99a0a38" upper="0xa998ed2c" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a0b58" next="0xa99a0be8" prev="0xa99a0ac8" upper="0xa998ed2c" lower="(nil)">void MergeSort(int l, int r){<Finish/></txt><txt ptr="0xa99a0be8" next="0xa99a0c78" prev="0xa99a0b58" upper="0xa998ed2c" lower="(nil)">*int mid;<Finish/></txt><txt ptr="0xa99a0c78" next="0xa99a0d08" prev="0xa99a0be8" upper="0xa998ed2c" lower="(nil)">*if( r &gt; l+1 ){<Finish/></txt><txt ptr="0xa99a0d08" next="0xa99a0d98" prev="0xa99a0c78" upper="0xa998ed2c" lower="(nil)">**int mid = (l+r)/2;<Finish/></txt><txt ptr="0xa99a0d98" next="0xa99a0e28" prev="0xa99a0d08" upper="0xa998ed2c" lower="(nil)">**MergeSort(l, mid);<Finish/></txt><txt ptr="0xa99a0e28" next="0xa99a0eb8" prev="0xa99a0d98" upper="0xa998ed2c" lower="(nil)">**MergeSort(mid, r);<Finish/></txt><txt ptr="0xa99a0eb8" next="(nil)" prev="0xa99a0e28" upper="0xa998ed2c" lower="(nil)">**Merger(l,mid,r);<Finish/></txt></body></column><column ptr="0xa997e0d4" next="0xa997e138" prev="0xa997e070" upper="0xa998c504" lower="0xa998ed8c"><body ptr="0xa998ed8c" next="(nil)" prev="(nil)" upper="0xa997e0d4" lower="0xa99a0f48"><txt ptr="0xa99a0f48" next="0xa99a101c" prev="(nil)" upper="0xa998ed8c" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99a101c" next="0xa99a10ac" prev="0xa99a0f48" upper="0xa998ed8c" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a10ac" next="0xa99a140c" prev="0xa99a101c" upper="0xa998ed8c" lower="(nil)">取第k 个元素<Finish/></txt><txt ptr="0xa99a140c" next="0xa99a149c" prev="0xa99a10ac" upper="0xa998ed8c" lower="(nil)"> sum=SUM( |ai - k| ),使sum最小<Finish/></txt><txt ptr="0xa99a149c" next="0xa99a152c" prev="0xa99a140c" upper="0xa998ed8c" lower="(nil)">int kth_element(int n,int* str,int k){<Finish/></txt><txt ptr="0xa99a152c" next="0xa99a15bc" prev="0xa99a149c" upper="0xa998ed8c" lower="(nil)">*int t,key;<Finish/></txt><txt ptr="0xa99a15bc" next="0xa99a164c" prev="0xa99a152c" upper="0xa998ed8c" lower="(nil)">*int l=0,r=n-1,i,j;<Finish/></txt><txt ptr="0xa99a164c" next="0xa99a16dc" prev="0xa99a15bc" upper="0xa998ed8c" lower="(nil)">*while (l&lt;r){<Finish/></txt><txt ptr="0xa99a16dc" next="0xa99a176c" prev="0xa99a164c" upper="0xa998ed8c" lower="(nil)">**for (key=str[((i=l-1)+(j=r+1))&gt;&gt;1];i&lt;j;){<Finish/></txt><txt ptr="0xa99a176c" next="0xa99a17fc" prev="0xa99a16dc" upper="0xa998ed8c" lower="(nil)">***for (j--;key&lt;str[j];j--);<Finish/></txt><txt ptr="0xa99a17fc" next="0xa99a188c" prev="0xa99a176c" upper="0xa998ed8c" lower="(nil)">***for (i++;str[i]&lt;key;i++);<Finish/></txt><txt ptr="0xa99a188c" next="0xa99a191c" prev="0xa99a17fc" upper="0xa998ed8c" lower="(nil)">***if (i&lt;j) t=str[i],str[i]=str[j],str[j]=t;<Finish/></txt><txt ptr="0xa99a191c" next="0xa99a19ac" prev="0xa99a188c" upper="0xa998ed8c" lower="(nil)">**}<Finish/></txt><txt ptr="0xa99a19ac" next="0xa99a1a3c" prev="0xa99a191c" upper="0xa998ed8c" lower="(nil)">**if (k&gt;j) l=j+1;<Finish/></txt><txt ptr="0xa99a1a3c" next="0xa99a1acc" prev="0xa99a19ac" upper="0xa998ed8c" lower="(nil)">**else r=j;<Finish/></txt><txt ptr="0xa99a1acc" next="0xa99a1b5c" prev="0xa99a1a3c" upper="0xa998ed8c" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99a1b5c" next="0xa99a1bec" prev="0xa99a1acc" upper="0xa998ed8c" lower="(nil)">*return str[k];<Finish/></txt><txt ptr="0xa99a1bec" next="0xa99a1c7c" prev="0xa99a1b5c" upper="0xa998ed8c" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a1c7c" next="0xa99a1d0c" prev="0xa99a1bec" upper="0xa998ed8c" lower="(nil)">Pell 方程<Finish/></txt><txt ptr="0xa99a1d0c" next="0xa99a1d9c" prev="0xa99a1c7c" upper="0xa998ed8c" lower="(nil)">X^2-d*Y^2=1<Finish/></txt><txt ptr="0xa99a1d9c" next="0xa99a1e2c" prev="0xa99a1d0c" upper="0xa998ed8c" lower="(nil)">若d不是完全平方数,则该方程有无穷多组（X,Y）解<Finish/></txt><txt ptr="0xa99a1e2c" next="0xa99a1ebc" prev="0xa99a1d9c" upper="0xa998ed8c" lower="(nil)"><Finish/></txt><txt ptr="0xa99a1ebc" next="0xa99a1f4c" prev="0xa99a1e2c" upper="0xa998ed8c" lower="(nil)">区间合并<Finish/></txt><txt ptr="0xa99a1f4c" next="0xa99a2020" prev="0xa99a1ebc" upper="0xa998ed8c" lower="(nil)">可以先对区间排序；然后简单合并即可<Finish/></txt><txt ptr="0xa99a2020" next="(nil)" prev="0xa99a1f4c" upper="0xa998ed8c" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa997e138" next="(nil)" prev="0xa997e0d4" upper="0xa998c504" lower="0xa998edec"><body ptr="0xa998edec" next="(nil)" prev="(nil)" upper="0xa997e138" lower="0xa99a20b0"><txt ptr="0xa99a20b0" next="0xa99a2140" prev="(nil)" upper="0xa998edec" lower="(nil)">星期几<Finish/></txt><txt ptr="0xa99a2140" next="0xa99a21d0" prev="0xa99a20b0" upper="0xa998edec" lower="(nil)">//返回1~7 <Finish/></txt><txt ptr="0xa99a21d0" next="0xa99a2260" prev="0xa99a2140" upper="0xa998edec" lower="(nil)">int getday(int y,int m,int d){*<Finish/></txt><txt ptr="0xa99a2260" next="0xa99a22f0" prev="0xa99a21d0" upper="0xa998edec" lower="(nil)">*// 1月2月当作前一年的13,14月<Finish/></txt><txt ptr="0xa99a22f0" next="0xa99a2380" prev="0xa99a2260" upper="0xa998edec" lower="(nil)">*if (m == 1 || m == 2) { m += 12; y--; }<Finish/></txt><txt ptr="0xa99a2380" next="0xa99a2410" prev="0xa99a22f0" upper="0xa998edec" lower="(nil)">*<Finish/></txt><txt ptr="0xa99a2410" next="0xa99a24a0" prev="0xa99a2380" upper="0xa998edec" lower="(nil)">*int ansa= d + 2*m + 3*(m+1)/5 + y + y/4;<Finish/></txt><txt ptr="0xa99a24a0" next="0xa99a2530" prev="0xa99a2410" upper="0xa998edec" lower="(nil)">*int ansb= (ansa - y/100 + y/400)%7 +1;<Finish/></txt><txt ptr="0xa99a2530" next="0xa99a25c0" prev="0xa99a24a0" upper="0xa998edec" lower="(nil)">*ansa= (ansa+5)%7 +1; <Finish/></txt><txt ptr="0xa99a25c0" next="0xa99a2650" prev="0xa99a2530" upper="0xa998edec" lower="(nil)">*<Finish/></txt><txt ptr="0xa99a2650" next="0xa99a29b0" prev="0xa99a25c0" upper="0xa998edec" lower="(nil)">*if(y&lt;1752)return ansa; <Finish/></txt><txt ptr="0xa99a29b0" next="0xa99a2a40" prev="0xa99a2650" upper="0xa998edec" lower="(nil)">*if(y == 1752 &amp;&amp; m &lt; 9)return ansa; <Finish/></txt><txt ptr="0xa99a2a40" next="0xa99a2ad0" prev="0xa99a29b0" upper="0xa998edec" lower="(nil)">*if(y == 1752 &amp;&amp; m == 9 &amp;&amp; d &lt; 3)return ansa; <Finish/></txt><txt ptr="0xa99a2ad0" next="0xa99a2b60" prev="0xa99a2a40" upper="0xa998edec" lower="(nil)">*return ansb;*<Finish/></txt><txt ptr="0xa99a2b60" next="0xa99a2bf0" prev="0xa99a2ad0" upper="0xa998edec" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a2bf0" next="0xa99a2c80" prev="0xa99a2b60" upper="0xa998edec" lower="(nil)">线段树<Finish/></txt><txt ptr="0xa99a2c80" next="0xa99a2d10" prev="0xa99a2bf0" upper="0xa998edec" lower="(nil)">单点更新<Finish/></txt><txt ptr="0xa99a2d10" next="0xa99a2da0" prev="0xa99a2c80" upper="0xa998edec" lower="(nil)">最最基础的线段树,只更新叶子节点,然后把信息用PushUP(int r)这个函数更新上来<Finish/></txt><txt ptr="0xa99a2da0" next="0xa99a2e30" prev="0xa99a2d10" upper="0xa998edec" lower="(nil)">//1.bulid();<Finish/></txt><txt ptr="0xa99a2e30" next="0xa99a2ec0" prev="0xa99a2da0" upper="0xa998edec" lower="(nil)">//2.query(a,b)<Finish/></txt><txt ptr="0xa99a2ec0" next="0xa99a2f50" prev="0xa99a2e30" upper="0xa998edec" lower="(nil)">//3.update(a,b)<Finish/></txt><txt ptr="0xa99a2f50" next="0xa99a3024" prev="0xa99a2ec0" upper="0xa998edec" lower="(nil)">#define lson l , m , rt &lt;&lt; 1<Finish/></txt><txt ptr="0xa99a3024" next="0xa99a30b4" prev="0xa99a2f50" upper="0xa998edec" lower="(nil)">#define rson m + 1 , r , rt &lt;&lt; 1 | 1<Finish/></txt><txt ptr="0xa99a30b4" next="0xa99a3144" prev="0xa99a3024" upper="0xa998edec" lower="(nil)">const int maxn = 55555;<Finish/></txt><txt ptr="0xa99a3144" next="(nil)" prev="0xa99a30b4" upper="0xa998edec" lower="(nil)">int sum[maxn&lt;&lt;2];<Finish/></txt></body></column></section></body><footer ptr="0xa89982a0" next="(nil)" prev="0xa8995c00" upper="0xa89933a0" lower="0xa99c464c"><txt ptr="0xa99c464c" next="0xa99c47fc" prev="(nil)" upper="0xa89982a0" lower="(nil)"><anchored><fly ptr="0xb3843c0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99c46dc"><txt ptr="0xa99c46dc" next="0xa99c476c" prev="(nil)" upper="0xb3843c0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99c476c" next="(nil)" prev="0xa99c46dc" upper="0xb3843c0" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="1"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="0"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99c47fc" next="(nil)" prev="0xa99c464c" upper="0xa89982a0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993414" next="0xa8993488" prev="0xa89933a0" upper="0xb0726b0" lower="0xa8996300"><header ptr="0xa8996300" next="0xa8995d80" prev="(nil)" upper="0xa8993414" lower="0xa99c5b60"><txt ptr="0xa99c5b60" next="(nil)" prev="(nil)" upper="0xa8996300" lower="(nil)"><Finish/></txt></header><body ptr="0xa8995d80" next="0xa8998300" prev="0xa8996300" upper="0xa8993414" lower="0xa998c604"><section ptr="0xa998c604" next="(nil)" prev="(nil)" upper="0xa8995d80" lower="0xa997e2c8" follow="0xa99bce00" precede="0xa998c504"><column ptr="0xa997e2c8" next="0xa997e32c" prev="(nil)" upper="0xa998c604" lower="0xa9983070"><body ptr="0xa9983070" next="(nil)" prev="(nil)" upper="0xa997e2c8" lower="0xa99a31d4"><txt ptr="0xa99a31d4" next="0xa99a3264" prev="(nil)" upper="0xa9983070" lower="(nil)">int n;<Finish/></txt><txt ptr="0xa99a3264" next="0xa99a32f4" prev="0xa99a31d4" upper="0xa9983070" lower="(nil)">//根据题意做相关修改，询问时的操作 <Finish/></txt><txt ptr="0xa99a32f4" next="0xa99a3384" prev="0xa99a3264" upper="0xa9983070" lower="(nil)">int operate(int a,int b){<Finish/></txt><txt ptr="0xa99a3384" next="0xa99a3414" prev="0xa99a32f4" upper="0xa9983070" lower="(nil)">return a+b;<Finish/></txt><txt ptr="0xa99a3414" next="0xa99a34a4" prev="0xa99a3384" upper="0xa9983070" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a34a4" next="0xa99a3534" prev="0xa99a3414" upper="0xa9983070" lower="(nil)">void PushUp(int rt){<Finish/></txt><txt ptr="0xa99a3534" next="0xa99a35c4" prev="0xa99a34a4" upper="0xa9983070" lower="(nil)">sum[rt]=operate(sum[rt&lt;&lt;1],sum[rt&lt;&lt;1|1]);<Finish/></txt><txt ptr="0xa99a35c4" next="0xa99a3654" prev="0xa99a3534" upper="0xa9983070" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a3654" next="0xa99a36e4" prev="0xa99a35c4" upper="0xa9983070" lower="(nil)">void bulid(int l=1,int r=n,int rt=1){<Finish/></txt><txt ptr="0xa99a36e4" next="0xa99a3774" prev="0xa99a3654" upper="0xa9983070" lower="(nil)">*if(l==r){// 据题意做相关修改<Finish/></txt><txt ptr="0xa99a3774" next="0xa99a3804" prev="0xa99a36e4" upper="0xa9983070" lower="(nil)">**scanf(&quot;%d&quot;,&amp;sum[rt]);return ;<Finish/></txt><txt ptr="0xa99a3804" next="0xa99a3894" prev="0xa99a3774" upper="0xa9983070" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99a3894" next="0xa99a3924" prev="0xa99a3804" upper="0xa9983070" lower="(nil)">*int m=(l+r)&gt;&gt;1;<Finish/></txt><txt ptr="0xa99a3924" next="0xa99a39b4" prev="0xa99a3894" upper="0xa9983070" lower="(nil)">*bulid(lson);<Finish/></txt><txt ptr="0xa99a39b4" next="0xa99a3a44" prev="0xa99a3924" upper="0xa9983070" lower="(nil)">*bulid(rson);<Finish/></txt><txt ptr="0xa99a3a44" next="0xa99a3ad4" prev="0xa99a39b4" upper="0xa9983070" lower="(nil)">*PushUp(rt);<Finish/></txt><txt ptr="0xa99a3ad4" next="0xa99a3b64" prev="0xa99a3a44" upper="0xa9983070" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a3b64" next="0xa99a3bf4" prev="0xa99a3ad4" upper="0xa9983070" lower="(nil)">void update(int p,int add,int l=1,int r=n,int rt=1){<Finish/></txt><txt ptr="0xa99a3bf4" next="0xa99a3f54" prev="0xa99a3b64" upper="0xa9983070" lower="(nil)">*if(l==r){// 据题意做相关修改<Finish/></txt><txt ptr="0xa99a3f54" next="0xa99a6028" prev="0xa99a3bf4" upper="0xa9983070" lower="(nil)">***sum[rt]+=add;return ;<Finish/></txt><txt ptr="0xa99a6028" next="0xa99a60b8" prev="0xa99a3f54" upper="0xa9983070" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99a60b8" next="0xa99a6148" prev="0xa99a6028" upper="0xa9983070" lower="(nil)">*int m=(l+r)&gt;&gt;1;<Finish/></txt><txt ptr="0xa99a6148" next="0xa99a61d8" prev="0xa99a60b8" upper="0xa9983070" lower="(nil)">*if(p&lt;=m)update(p,add,lson);<Finish/></txt><txt ptr="0xa99a61d8" next="0xa99a6268" prev="0xa99a6148" upper="0xa9983070" lower="(nil)">*else update(p,add,rson);<Finish/></txt><txt ptr="0xa99a6268" next="0xa99a62f8" prev="0xa99a61d8" upper="0xa9983070" lower="(nil)">*PushUp(rt);<Finish/></txt><txt ptr="0xa99a62f8" next="0xa99a6388" prev="0xa99a6268" upper="0xa9983070" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a6388" next="0xa99a6418" prev="0xa99a62f8" upper="0xa9983070" lower="(nil)"><Finish/></txt><txt ptr="0xa99a6418" next="(nil)" prev="0xa99a6388" upper="0xa9983070" lower="(nil)">int query(int L,int R,int l=1,int r=n,int rt=1){<Finish/></txt></body></column><column ptr="0xa997e32c" next="0xa997e390" prev="0xa997e2c8" upper="0xa998c604" lower="0xa99830d0"><body ptr="0xa99830d0" next="(nil)" prev="(nil)" upper="0xa997e32c" lower="0xa99a64a8"><txt ptr="0xa99a64a8" next="0xa99a6538" prev="(nil)" upper="0xa99830d0" lower="(nil)">*if(L&lt;=l &amp;&amp; r&lt;=R){<Finish/></txt><txt ptr="0xa99a6538" next="0xa99a65c8" prev="0xa99a64a8" upper="0xa99830d0" lower="(nil)">**return sum[rt];<Finish/></txt><txt ptr="0xa99a65c8" next="0xa99a6658" prev="0xa99a6538" upper="0xa99830d0" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99a6658" next="0xa99a66e8" prev="0xa99a65c8" upper="0xa99830d0" lower="(nil)">*int m=(l+r)&gt;&gt;1;<Finish/></txt><txt ptr="0xa99a66e8" next="0xa99a6778" prev="0xa99a6658" upper="0xa99830d0" lower="(nil)">*int ret=0;<Finish/></txt><txt ptr="0xa99a6778" next="0xa99a6808" prev="0xa99a66e8" upper="0xa99830d0" lower="(nil)">*if(L&lt;=m)ret=operate(ret,query(L,R,lson));<Finish/></txt><txt ptr="0xa99a6808" next="0xa99a6898" prev="0xa99a6778" upper="0xa99830d0" lower="(nil)">*if(R&gt; m)ret=operate(ret,query(L,R,rson));<Finish/></txt><txt ptr="0xa99a6898" next="0xa99a6928" prev="0xa99a6808" upper="0xa99830d0" lower="(nil)">*return ret;<Finish/></txt><txt ptr="0xa99a6928" next="0xa99a69b8" prev="0xa99a6898" upper="0xa99830d0" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a69b8" next="0xa99a6a48" prev="0xa99a6928" upper="0xa99830d0" lower="(nil)">成段更新<Finish/></txt><txt ptr="0xa99a6a48" next="0xa99a6ad8" prev="0xa99a69b8" upper="0xa99830d0" lower="(nil)">//1.bulid();2.query(a,b)；3.update(a,b)<Finish/></txt><txt ptr="0xa99a6ad8" next="0xa99a6b68" prev="0xa99a6a48" upper="0xa99830d0" lower="(nil)"><Finish/></txt><txt ptr="0xa99a6b68" next="0xa99a6bf8" prev="0xa99a6ad8" upper="0xa99830d0" lower="(nil)">#define lson l , m , rt &lt;&lt; 1<Finish/></txt><txt ptr="0xa99a6bf8" next="0xa99a6c88" prev="0xa99a6b68" upper="0xa99830d0" lower="(nil)">#define rson m + 1 , r , rt &lt;&lt; 1 | 1<Finish/></txt><txt ptr="0xa99a6c88" next="0xa99a6d18" prev="0xa99a6bf8" upper="0xa99830d0" lower="(nil)">typedef long long LL;<Finish/></txt><txt ptr="0xa99a6d18" next="0xa99a6da8" prev="0xa99a6c88" upper="0xa99830d0" lower="(nil)">const int maxn = 100055;<Finish/></txt><txt ptr="0xa99a6da8" next="0xa99a6e38" prev="0xa99a6d18" upper="0xa99830d0" lower="(nil)">LL sign[maxn&lt;&lt;2];//标记<Finish/></txt><txt ptr="0xa99a6e38" next="0xa99a6ec8" prev="0xa99a6da8" upper="0xa99830d0" lower="(nil)">LL sum[maxn&lt;&lt;2];<Finish/></txt><txt ptr="0xa99a6ec8" next="0xa99a6f58" prev="0xa99a6e38" upper="0xa99830d0" lower="(nil)">int n;<Finish/></txt><txt ptr="0xa99a6f58" next="0xa99a7000" prev="0xa99a6ec8" upper="0xa99830d0" lower="(nil)">LL operate(LL a,LL b){<Finish/></txt><txt ptr="0xa99a7000" next="0xa99a7090" prev="0xa99a6f58" upper="0xa99830d0" lower="(nil)">*return a+b;//根据题意做相关修改，询问时的操作 <Finish/></txt><txt ptr="0xa99a7090" next="0xa99a7120" prev="0xa99a7000" upper="0xa99830d0" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a7120" next="0xa99a71b0" prev="0xa99a7090" upper="0xa99830d0" lower="(nil)">void PushUp(int rt){<Finish/></txt><txt ptr="0xa99a71b0" next="0xa99a7510" prev="0xa99a7120" upper="0xa99830d0" lower="(nil)">*sum[rt]=operate(sum[rt&lt;&lt;1],sum[rt&lt;&lt;1|1]);<Finish/></txt><txt ptr="0xa99a7510" next="0xa99a75a0" prev="0xa99a71b0" upper="0xa99830d0" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a75a0" next="0xa99a7630" prev="0xa99a7510" upper="0xa99830d0" lower="(nil)">void PushDown(int rt,int m) {<Finish/></txt><txt ptr="0xa99a7630" next="0xa99a76c0" prev="0xa99a75a0" upper="0xa99830d0" lower="(nil)">*if (sign[rt]) {<Finish/></txt><txt ptr="0xa99a76c0" next="(nil)" prev="0xa99a7630" upper="0xa99830d0" lower="(nil)">**sign[rt&lt;&lt;1]   += sign[rt];<Finish/></txt></body></column><column ptr="0xa997e390" next="(nil)" prev="0xa997e32c" upper="0xa998c604" lower="0xa9983130"><body ptr="0xa9983130" next="(nil)" prev="(nil)" upper="0xa997e390" lower="0xa99a7750"><txt ptr="0xa99a7750" next="0xa99a77e0" prev="(nil)" upper="0xa9983130" lower="(nil)">**sign[rt&lt;&lt;1|1] += sign[rt];<Finish/></txt><txt ptr="0xa99a77e0" next="0xa99a7870" prev="0xa99a7750" upper="0xa9983130" lower="(nil)">**sum[rt&lt;&lt;1] += (m - (m &gt;&gt; 1)) * sign[rt];<Finish/></txt><txt ptr="0xa99a7870" next="0xa99a7900" prev="0xa99a77e0" upper="0xa9983130" lower="(nil)">**sum[rt&lt;&lt;1|1] += (m &gt;&gt; 1) * sign[rt];<Finish/></txt><txt ptr="0xa99a7900" next="0xa99a7990" prev="0xa99a7870" upper="0xa9983130" lower="(nil)">**sign[rt] = 0;<Finish/></txt><txt ptr="0xa99a7990" next="0xa99a7a20" prev="0xa99a7900" upper="0xa9983130" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99a7a20" next="0xa99a7ab0" prev="0xa99a7990" upper="0xa9983130" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a7ab0" next="0xa99a7b40" prev="0xa99a7a20" upper="0xa9983130" lower="(nil)">void bulid(int l=1,int r=n,int rt=1){<Finish/></txt><txt ptr="0xa99a7b40" next="0xa99a7bd0" prev="0xa99a7ab0" upper="0xa9983130" lower="(nil)">*sign[rt] = 0;<Finish/></txt><txt ptr="0xa99a7bd0" next="0xa99a7c60" prev="0xa99a7b40" upper="0xa9983130" lower="(nil)">*if(l==r){// 据题意做相关修改<Finish/></txt><txt ptr="0xa99a7c60" next="0xa99a7cf0" prev="0xa99a7bd0" upper="0xa9983130" lower="(nil)">**scanf(&quot;%lld&quot;,&amp;sum[rt]);return ;<Finish/></txt><txt ptr="0xa99a7cf0" next="0xa99a7d80" prev="0xa99a7c60" upper="0xa9983130" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99a7d80" next="0xa99a7e10" prev="0xa99a7cf0" upper="0xa9983130" lower="(nil)">*int m=(l+r)&gt;&gt;1;<Finish/></txt><txt ptr="0xa99a7e10" next="0xa99a7ea0" prev="0xa99a7d80" upper="0xa9983130" lower="(nil)">*bulid(lson);<Finish/></txt><txt ptr="0xa99a7ea0" next="0xa99a7f30" prev="0xa99a7e10" upper="0xa9983130" lower="(nil)">*bulid(rson);<Finish/></txt><txt ptr="0xa99a7f30" next="0xa99a8004" prev="0xa99a7ea0" upper="0xa9983130" lower="(nil)">*PushUp(rt);<Finish/></txt><txt ptr="0xa99a8004" next="0xa99a8094" prev="0xa99a7f30" upper="0xa9983130" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a8094" next="0xa99a8124" prev="0xa99a8004" upper="0xa9983130" lower="(nil)">void update(int L,int R,int add,int l=1,int r=n,int rt=1){<Finish/></txt><txt ptr="0xa99a8124" next="0xa99a81b4" prev="0xa99a8094" upper="0xa9983130" lower="(nil)">*if(L&lt;=l &amp;&amp; r&lt;=R){// 据题意做相关修改<Finish/></txt><txt ptr="0xa99a81b4" next="0xa99a8244" prev="0xa99a8124" upper="0xa9983130" lower="(nil)">**sign[rt]+=add;<Finish/></txt><txt ptr="0xa99a8244" next="0xa99a82d4" prev="0xa99a81b4" upper="0xa9983130" lower="(nil)">**sum[rt]+=(LL)add*(r-l+1);return ;<Finish/></txt><txt ptr="0xa99a82d4" next="0xa99a8364" prev="0xa99a8244" upper="0xa9983130" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99a8364" next="0xa99a83f4" prev="0xa99a82d4" upper="0xa9983130" lower="(nil)">*PushDown(rt,r-l+1);<Finish/></txt><txt ptr="0xa99a83f4" next="0xa99a8484" prev="0xa99a8364" upper="0xa9983130" lower="(nil)">*int m = (l + r) &gt;&gt; 1;<Finish/></txt><txt ptr="0xa99a8484" next="0xa99a8514" prev="0xa99a83f4" upper="0xa9983130" lower="(nil)">*if (L &lt;= m) update(L , R , add , lson);<Finish/></txt><txt ptr="0xa99a8514" next="0xa99a85a4" prev="0xa99a8484" upper="0xa9983130" lower="(nil)">*if (R &gt; m) update(L , R , add , rson);<Finish/></txt><txt ptr="0xa99a85a4" next="0xa99a8634" prev="0xa99a8514" upper="0xa9983130" lower="(nil)">*PushUp(rt);<Finish/></txt><txt ptr="0xa99a8634" next="0xa99a86c4" prev="0xa99a85a4" upper="0xa9983130" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a86c4" next="(nil)" prev="0xa99a8634" upper="0xa9983130" lower="(nil)">LL query(int L,int R,int l=1,int r=n,int rt=1) {<Finish/></txt></body></column></section></body><footer ptr="0xa8998300" next="(nil)" prev="0xa8995d80" upper="0xa8993414" lower="0xa99c5bf0"><txt ptr="0xa99c5bf0" next="0xa99c5da0" prev="(nil)" upper="0xa8998300" lower="(nil)"><anchored><fly ptr="0xb3880d0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99c5c80"><txt ptr="0xa99c5c80" next="0xa99c5d10" prev="(nil)" upper="0xb3880d0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99c5d10" next="(nil)" prev="0xa99c5c80" upper="0xb3880d0" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="1"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="1"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99c5da0" next="(nil)" prev="0xa99c5bf0" upper="0xa8998300" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993488" next="0xa89934fc" prev="0xa8993414" upper="0xb0726b0" lower="0xa8996360"><header ptr="0xa8996360" next="0xa8995f00" prev="(nil)" upper="0xa8993488" lower="0xa99c7148"><txt ptr="0xa99c7148" next="(nil)" prev="(nil)" upper="0xa8996360" lower="(nil)"><Finish/></txt></header><body ptr="0xa8995f00" next="0xa8998360" prev="0xa8996360" upper="0xa8993488" lower="0xa99bce00"><section ptr="0xa99bce00" next="(nil)" prev="(nil)" upper="0xa8995f00" lower="0xa88efb7c" follow="0xa894b58c" precede="0xa998c604"><column ptr="0xa88efb7c" next="0xa88efbe0" prev="(nil)" upper="0xa99bce00" lower="0xa99c8c04"><body ptr="0xa99c8c04" next="(nil)" prev="(nil)" upper="0xa88efb7c" lower="0xa99a8754"><txt ptr="0xa99a8754" next="0xa99a8ab4" prev="(nil)" upper="0xa99c8c04" lower="(nil)">*if (L &lt;= l &amp;&amp; r &lt;= R) {<Finish/></txt><txt ptr="0xa99a8ab4" next="0xa99a8b44" prev="0xa99a8754" upper="0xa99c8c04" lower="(nil)">**return sum[rt];<Finish/></txt><txt ptr="0xa99a8b44" next="0xa99a8bd4" prev="0xa99a8ab4" upper="0xa99c8c04" lower="(nil)">*}<Finish/></txt><txt ptr="0xa99a8bd4" next="0xa99a8c64" prev="0xa99a8b44" upper="0xa99c8c04" lower="(nil)">*PushDown(rt , r - l + 1);<Finish/></txt><txt ptr="0xa99a8c64" next="0xa99a8cf4" prev="0xa99a8bd4" upper="0xa99c8c04" lower="(nil)">*int m = (l + r) &gt;&gt; 1;<Finish/></txt><txt ptr="0xa99a8cf4" next="0xa99a8d84" prev="0xa99a8c64" upper="0xa99c8c04" lower="(nil)">*LL ret = 0;<Finish/></txt><txt ptr="0xa99a8d84" next="0xa99a8e14" prev="0xa99a8cf4" upper="0xa99c8c04" lower="(nil)">*if (L &lt;= m) ret += query(L , R , lson);<Finish/></txt><txt ptr="0xa99a8e14" next="0xa99a8ea4" prev="0xa99a8d84" upper="0xa99c8c04" lower="(nil)">*if (m &lt; R) ret += query(L , R , rson);<Finish/></txt><txt ptr="0xa99a8ea4" next="0xa99a8f34" prev="0xa99a8e14" upper="0xa99c8c04" lower="(nil)">*return ret;<Finish/></txt><txt ptr="0xa99a8f34" next="0xa99a9008" prev="0xa99a8ea4" upper="0xa99c8c04" lower="(nil)">}<Finish/></txt><txt ptr="0xa99a9008" next="0xa99a9098" prev="0xa99a8f34" upper="0xa99c8c04" lower="(nil)">应用<Finish/></txt><txt ptr="0xa99a9098" next="0xa99a9128" prev="0xa99a9008" upper="0xa99c8c04" lower="(nil)">可以用来求区间合并，区间求和，区间最值等。<Finish/></txt><txt ptr="0xa99a9128" next="0xa99a91b8" prev="0xa99a9098" upper="0xa99c8c04" lower="(nil)">实际应用：矩阵并的周长和面积。<Finish/></txt><txt ptr="0xa99a91b8" next="0xa99a9248" prev="0xa99a9128" upper="0xa99c8c04" lower="(nil)">利用线段树求体积<Finish/></txt><txt ptr="0xa99a9248" next="0xa99a92d8" prev="0xa99a91b8" upper="0xa99c8c04" lower="(nil)">POJ 1823  2352  1177  1151  1803 <Finish/></txt><txt ptr="0xa99a92d8" next="0xa99a9368" prev="0xa99a9248" upper="0xa99c8c04" lower="(nil)">离散化<Finish/></txt><txt ptr="0xa99a9368" next="0xa99a93f8" prev="0xa99a92d8" upper="0xa99c8c04" lower="(nil)">把竖线作为区间建立线段树，从左向右扫描的时候，遇到左竖边，插入线段树，右竖边从线段树中删除。<Finish/></txt><txt ptr="0xa99a93f8" next="0xa99a9488" prev="0xa99a9368" upper="0xa99c8c04" lower="(nil)">树套树<Finish/></txt><txt ptr="0xa99a9488" next="0xa99a9518" prev="0xa99a93f8" upper="0xa99c8c04" lower="(nil)">线段树套平衡树<Finish/></txt><txt ptr="0xa99a9518" next="0xa99a95a8" prev="0xa99a9488" upper="0xa99c8c04" lower="(nil)"><Finish/></txt><txt ptr="0xa99a95a8" next="0xa99a9638" prev="0xa99a9518" upper="0xa99c8c04" lower="(nil)">动态查询区间第k小，包括两个操作Q x y k和C i j，查询区间x y的第k小和把第i个数安替换成j。<Finish/></txt><txt ptr="0xa99a9638" next="0xa99a96c8" prev="0xa99a95a8" upper="0xa99c8c04" lower="(nil)"><Finish/></txt><txt ptr="0xa99a96c8" next="0xa99a9758" prev="0xa99a9638" upper="0xa99c8c04" lower="(nil)">const int N=50010;<Finish/></txt><txt ptr="0xa99a9758" next="0xa99a97e8" prev="0xa99a96c8" upper="0xa99c8c04" lower="(nil)">const int INF = 0x3f3f3f3f;<Finish/></txt><txt ptr="0xa99a97e8" next="(nil)" prev="0xa99a9758" upper="0xa99c8c04" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa88efbe0" next="0xa88efc44" prev="0xa88efb7c" upper="0xa99bce00" lower="0xa99c8c64"><body ptr="0xa99c8c64" next="(nil)" prev="(nil)" upper="0xa88efbe0" lower="0xa99a9878"><txt ptr="0xa99a9878" next="0xa99a9908" prev="(nil)" upper="0xa99c8c64" lower="(nil)">int tree[N&lt;&lt;1];<Finish/></txt><txt ptr="0xa99a9908" next="0xa99a9998" prev="0xa99a9878" upper="0xa99c8c64" lower="(nil)"><Finish/></txt><txt ptr="0xa99a9998" next="0xa99a9a28" prev="0xa99a9908" upper="0xa99c8c64" lower="(nil)">struct treap {<Finish/></txt><txt ptr="0xa99a9a28" next="0xa99a9ab8" prev="0xa99a9998" upper="0xa99c8c64" lower="(nil)">    int key,wht,count,sz,ch[2];<Finish/></txt><txt ptr="0xa99a9ab8" next="0xa99a9b48" prev="0xa99a9a28" upper="0xa99c8c64" lower="(nil)">} tp[N*20];<Finish/></txt><txt ptr="0xa99a9b48" next="0xa99a9bd8" prev="0xa99a9ab8" upper="0xa99c8c64" lower="(nil)"><Finish/></txt><txt ptr="0xa99a9bd8" next="0xa99a9c68" prev="0xa99a9b48" upper="0xa99c8c64" lower="(nil)">int nodecount;<Finish/></txt><txt ptr="0xa99a9c68" next="0xa99a9cf8" prev="0xa99a9bd8" upper="0xa99c8c64" lower="(nil)"><Finish/></txt><txt ptr="0xa99a9cf8" next="0xa998a09c" prev="0xa99a9c68" upper="0xa99c8c64" lower="(nil)">int id(int l,int r) {<Finish/></txt><txt ptr="0xa998a09c" next="0xa998a12c" prev="0xa99a9cf8" upper="0xa99c8c64" lower="(nil)">    return l+r | l!=r;<Finish/></txt><txt ptr="0xa998a12c" next="0xa998a1bc" prev="0xa998a09c" upper="0xa99c8c64" lower="(nil)">}<Finish/></txt><txt ptr="0xa998a1bc" next="0xa998a24c" prev="0xa998a12c" upper="0xa99c8c64" lower="(nil)"><Finish/></txt><txt ptr="0xa998a24c" next="0xa998a2dc" prev="0xa998a1bc" upper="0xa99c8c64" lower="(nil)">void init() {<Finish/></txt><txt ptr="0xa998a2dc" next="0xa998a36c" prev="0xa998a24c" upper="0xa99c8c64" lower="(nil)">    tp[0].sz=0;<Finish/></txt><txt ptr="0xa998a36c" next="0xa998a3fc" prev="0xa998a2dc" upper="0xa99c8c64" lower="(nil)">    tp[0].wht=-INF;<Finish/></txt><txt ptr="0xa998a3fc" next="0xa998a48c" prev="0xa998a36c" upper="0xa99c8c64" lower="(nil)">    tp[0].key=-1;<Finish/></txt><txt ptr="0xa998a48c" next="0xa998a51c" prev="0xa998a3fc" upper="0xa99c8c64" lower="(nil)">    nodecount=0;<Finish/></txt><txt ptr="0xa998a51c" next="0xa998a5ac" prev="0xa998a48c" upper="0xa99c8c64" lower="(nil)">}<Finish/></txt><txt ptr="0xa998a5ac" next="0xa998a63c" prev="0xa998a51c" upper="0xa99c8c64" lower="(nil)"><Finish/></txt><txt ptr="0xa998a63c" next="0xa998a6cc" prev="0xa998a5ac" upper="0xa99c8c64" lower="(nil)">//update this tree's size<Finish/></txt><txt ptr="0xa998a6cc" next="0xa998a75c" prev="0xa998a63c" upper="0xa99c8c64" lower="(nil)">void update(int x) {<Finish/></txt><txt ptr="0xa998a75c" next="0xa998a7ec" prev="0xa998a6cc" upper="0xa99c8c64" lower="(nil)">    tp[x].sz=tp[tp[x].ch[0]].sz+tp[x].count+tp[tp[x].ch[1]].sz;<Finish/></txt><txt ptr="0xa998a7ec" next="0xa998a87c" prev="0xa998a75c" upper="0xa99c8c64" lower="(nil)">}<Finish/></txt><txt ptr="0xa998a87c" next="0xa998a90c" prev="0xa998a7ec" upper="0xa99c8c64" lower="(nil)"><Finish/></txt><txt ptr="0xa998a90c" next="0xa998a99c" prev="0xa998a87c" upper="0xa99c8c64" lower="(nil)">void rotate(int &amp;x,int t) {<Finish/></txt><txt ptr="0xa998a99c" next="0xa998aa2c" prev="0xa998a90c" upper="0xa99c8c64" lower="(nil)">    int y=tp[x].ch[t];<Finish/></txt><txt ptr="0xa998aa2c" next="(nil)" prev="0xa998a99c" upper="0xa99c8c64" lower="(nil)">    tp[x].ch[t]=tp[y].ch[!t];<Finish/></txt></body></column><column ptr="0xa88efc44" next="(nil)" prev="0xa88efbe0" upper="0xa99bce00" lower="0xa99c8ea4"><body ptr="0xa99c8ea4" next="(nil)" prev="(nil)" upper="0xa88efc44" lower="0xa998aabc"><txt ptr="0xa998aabc" next="0xa998ab4c" prev="(nil)" upper="0xa99c8ea4" lower="(nil)">    tp[y].ch[!t]=x;<Finish/></txt><txt ptr="0xa998ab4c" next="0xa998abdc" prev="0xa998aabc" upper="0xa99c8ea4" lower="(nil)">    update(x);<Finish/></txt><txt ptr="0xa998abdc" next="0xa998ac6c" prev="0xa998ab4c" upper="0xa99c8ea4" lower="(nil)">    update(y);<Finish/></txt><txt ptr="0xa998ac6c" next="0xa998acfc" prev="0xa998abdc" upper="0xa99c8ea4" lower="(nil)">    x=y;<Finish/></txt><txt ptr="0xa998acfc" next="0xa998ad8c" prev="0xa998ac6c" upper="0xa99c8ea4" lower="(nil)">}<Finish/></txt><txt ptr="0xa998ad8c" next="0xa998ae1c" prev="0xa998acfc" upper="0xa99c8ea4" lower="(nil)"><Finish/></txt><txt ptr="0xa998ae1c" next="0xa998aeac" prev="0xa998ad8c" upper="0xa99c8ea4" lower="(nil)"><Finish/></txt><txt ptr="0xa998aeac" next="0xa998af3c" prev="0xa998ae1c" upper="0xa99c8ea4" lower="(nil)">void insert(int &amp;x,int t) {<Finish/></txt><txt ptr="0xa998af3c" next="0xa998b010" prev="0xa998aeac" upper="0xa99c8ea4" lower="(nil)">    if(!x) {<Finish/></txt><txt ptr="0xa998b010" next="0xa998b0a0" prev="0xa998af3c" upper="0xa99c8ea4" lower="(nil)">        x=++nodecount;<Finish/></txt><txt ptr="0xa998b0a0" next="0xa998b130" prev="0xa998b010" upper="0xa99c8ea4" lower="(nil)">        tp[x].key=t;<Finish/></txt><txt ptr="0xa998b130" next="0xa998b1c0" prev="0xa998b0a0" upper="0xa99c8ea4" lower="(nil)">        tp[x].wht=rand();<Finish/></txt><txt ptr="0xa998b1c0" next="0xa998b250" prev="0xa998b130" upper="0xa99c8ea4" lower="(nil)">        tp[x].count=1;<Finish/></txt><txt ptr="0xa998b250" next="0xa998b2e0" prev="0xa998b1c0" upper="0xa99c8ea4" lower="(nil)">        tp[x].ch[0]=tp[x].ch[1]=0;<Finish/></txt><txt ptr="0xa998b2e0" next="0xa998b640" prev="0xa998b250" upper="0xa99c8ea4" lower="(nil)">    } else if(tp[x].key==t) {<Finish/></txt><txt ptr="0xa998b640" next="0xa998b6d0" prev="0xa998b2e0" upper="0xa99c8ea4" lower="(nil)">        tp[x].count++;<Finish/></txt><txt ptr="0xa998b6d0" next="0xa998b760" prev="0xa998b640" upper="0xa99c8ea4" lower="(nil)">    } else {<Finish/></txt><txt ptr="0xa998b760" next="0xa998b7f0" prev="0xa998b6d0" upper="0xa99c8ea4" lower="(nil)">        int k=tp[x].key&lt;t;<Finish/></txt><txt ptr="0xa998b7f0" next="0xa998b880" prev="0xa998b760" upper="0xa99c8ea4" lower="(nil)">        insert(tp[x].ch[k],t);<Finish/></txt><txt ptr="0xa998b880" next="0xa998b910" prev="0xa998b7f0" upper="0xa99c8ea4" lower="(nil)">        if(tp[x].wht&lt;tp[tp[x].ch[k]].wht) {<Finish/></txt><txt ptr="0xa998b910" next="0xa998b9a0" prev="0xa998b880" upper="0xa99c8ea4" lower="(nil)">            rotate(x,k);<Finish/></txt><txt ptr="0xa998b9a0" next="0xa998ba30" prev="0xa998b910" upper="0xa99c8ea4" lower="(nil)">        }<Finish/></txt><txt ptr="0xa998ba30" next="0xa998bac0" prev="0xa998b9a0" upper="0xa99c8ea4" lower="(nil)">    }<Finish/></txt><txt ptr="0xa998bac0" next="0xa998bb50" prev="0xa998ba30" upper="0xa99c8ea4" lower="(nil)">    update(x);<Finish/></txt><txt ptr="0xa998bb50" next="0xa998bbe0" prev="0xa998bac0" upper="0xa99c8ea4" lower="(nil)">}<Finish/></txt><txt ptr="0xa998bbe0" next="0xa998bc70" prev="0xa998bb50" upper="0xa99c8ea4" lower="(nil)"><Finish/></txt><txt ptr="0xa998bc70" next="0xa998bd00" prev="0xa998bbe0" upper="0xa99c8ea4" lower="(nil)">void erase(int &amp;x,int t) {<Finish/></txt><txt ptr="0xa998bd00" next="(nil)" prev="0xa998bc70" upper="0xa99c8ea4" lower="(nil)">    if(tp[x].key==t) {<Finish/></txt></body></column></section></body><footer ptr="0xa8998360" next="(nil)" prev="0xa8995f00" upper="0xa8993488" lower="0xa99c71d8"><txt ptr="0xa99c71d8" next="0xa99c7388" prev="(nil)" upper="0xa8998360" lower="(nil)"><anchored><fly ptr="0xa511140" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99c7268"><txt ptr="0xa99c7268" next="0xa99c72f8" prev="(nil)" upper="0xa511140" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99c72f8" next="(nil)" prev="0xa99c7268" upper="0xa511140" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="1"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="2"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99c7388" next="(nil)" prev="0xa99c71d8" upper="0xa8998360" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa89934fc" next="0xa8993570" prev="0xa8993488" upper="0xb0726b0" lower="0xa89963c0"><header ptr="0xa89963c0" next="0xa99c80c4" prev="(nil)" upper="0xa89934fc" lower="0xa99c96c0"><txt ptr="0xa99c96c0" next="(nil)" prev="(nil)" upper="0xa89963c0" lower="(nil)"><Finish/></txt></header><body ptr="0xa99c80c4" next="0xa89983c0" prev="0xa89963c0" upper="0xa89934fc" lower="0xa894b58c"><section ptr="0xa894b58c" next="(nil)" prev="(nil)" upper="0xa99c80c4" lower="0xa88efdd4" follow="0xa998cb84" precede="0xa99bce00"><column ptr="0xa88efdd4" next="0xa88efe38" prev="(nil)" upper="0xa894b58c" lower="0xa999c0c8"><body ptr="0xa999c0c8" next="(nil)" prev="(nil)" upper="0xa88efdd4" lower="0xa998bd90"><txt ptr="0xa998bd90" next="0xa998be20" prev="(nil)" upper="0xa999c0c8" lower="(nil)">        if(tp[x].count==1) {<Finish/></txt><txt ptr="0xa998be20" next="0xa998beb0" prev="0xa998bd90" upper="0xa999c0c8" lower="(nil)">            if(! tp[x].ch[0] &amp;&amp; ! tp[x].ch[1]) {<Finish/></txt><txt ptr="0xa998beb0" next="0xa998bf40" prev="0xa998be20" upper="0xa999c0c8" lower="(nil)">                x=0;<Finish/></txt><txt ptr="0xa998bf40" next="0xa998d014" prev="0xa998beb0" upper="0xa999c0c8" lower="(nil)">                return;<Finish/></txt><txt ptr="0xa998d014" next="0xa998d0a4" prev="0xa998bf40" upper="0xa999c0c8" lower="(nil)">            }<Finish/></txt><txt ptr="0xa998d0a4" next="0xa998d134" prev="0xa998d014" upper="0xa999c0c8" lower="(nil)">            rotate(x,tp[tp[x].ch[0]].wht&lt;tp[tp[x].ch[1]].wht);<Finish/></txt><txt ptr="0xa998d134" next="0xa998d1c4" prev="0xa998d0a4" upper="0xa999c0c8" lower="(nil)">            erase(x,t);<Finish/></txt><txt ptr="0xa998d1c4" next="0xa998d254" prev="0xa998d134" upper="0xa999c0c8" lower="(nil)">        } else tp[x].count--;<Finish/></txt><txt ptr="0xa998d254" next="0xa998d2e4" prev="0xa998d1c4" upper="0xa999c0c8" lower="(nil)">    } else erase(tp[x].ch[tp[x].key&lt;t],t);<Finish/></txt><txt ptr="0xa998d2e4" next="0xa998d374" prev="0xa998d254" upper="0xa999c0c8" lower="(nil)">    update(x);<Finish/></txt><txt ptr="0xa998d374" next="0xa998d404" prev="0xa998d2e4" upper="0xa999c0c8" lower="(nil)">}<Finish/></txt><txt ptr="0xa998d404" next="0xa998d494" prev="0xa998d374" upper="0xa999c0c8" lower="(nil)"><Finish/></txt><txt ptr="0xa998d494" next="0xa998d524" prev="0xa998d404" upper="0xa999c0c8" lower="(nil)">int select(int x,int k) {<Finish/></txt><txt ptr="0xa998d524" next="0xa998d5b4" prev="0xa998d494" upper="0xa999c0c8" lower="(nil)">    if(! x) return 0;<Finish/></txt><txt ptr="0xa998d5b4" next="0xa998d644" prev="0xa998d524" upper="0xa999c0c8" lower="(nil)">    if(k&lt;tp[x].key) return select(tp[x].ch[0],k);<Finish/></txt><txt ptr="0xa998d644" next="0xa998d6d4" prev="0xa998d5b4" upper="0xa999c0c8" lower="(nil)">    int q=0,p=tp[tp[x].ch[0]].sz+tp[x].count;<Finish/></txt><txt ptr="0xa998d6d4" next="0xa998d764" prev="0xa998d644" upper="0xa999c0c8" lower="(nil)">    if(k&gt;tp[x].key) q=select(tp[x].ch[1],k);<Finish/></txt><txt ptr="0xa998d764" next="0xa998d7f4" prev="0xa998d6d4" upper="0xa999c0c8" lower="(nil)">    return p+q;<Finish/></txt><txt ptr="0xa998d7f4" next="0xa998d884" prev="0xa998d764" upper="0xa999c0c8" lower="(nil)">}<Finish/></txt><txt ptr="0xa998d884" next="0xa998dbe4" prev="0xa998d7f4" upper="0xa999c0c8" lower="(nil)"><Finish/></txt><txt ptr="0xa998dbe4" next="0xa998dc74" prev="0xa998d884" upper="0xa999c0c8" lower="(nil)">int a[N],n,m,ans;<Finish/></txt><txt ptr="0xa998dc74" next="0xa998dd04" prev="0xa998dbe4" upper="0xa999c0c8" lower="(nil)">void treeinsert(int l,int r,int i,int x) {<Finish/></txt><txt ptr="0xa998dd04" next="0xa998dd94" prev="0xa998dc74" upper="0xa999c0c8" lower="(nil)">    insert(tree[id(l,r)],x);<Finish/></txt><txt ptr="0xa998dd94" next="0xa998de24" prev="0xa998dd04" upper="0xa999c0c8" lower="(nil)">    if(l==r) return;<Finish/></txt><txt ptr="0xa998de24" next="0xa998deb4" prev="0xa998dd94" upper="0xa999c0c8" lower="(nil)">    int m=(l+r)&gt;&gt;1;<Finish/></txt><txt ptr="0xa998deb4" next="0xa998df44" prev="0xa998de24" upper="0xa999c0c8" lower="(nil)">    if(i&lt;=m) treeinsert(l,m,i,x);<Finish/></txt><txt ptr="0xa998df44" next="0xa998f018" prev="0xa998deb4" upper="0xa999c0c8" lower="(nil)">    if(i&gt;m) treeinsert(m+1,r,i,x);<Finish/></txt><txt ptr="0xa998f018" next="(nil)" prev="0xa998df44" upper="0xa999c0c8" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa88efe38" next="0xa88efe9c" prev="0xa88efdd4" upper="0xa894b58c" lower="0xa999c128"><body ptr="0xa999c128" next="(nil)" prev="(nil)" upper="0xa88efe38" lower="0xa998f0a8"><txt ptr="0xa998f0a8" next="0xa998f138" prev="(nil)" upper="0xa999c128" lower="(nil)"><Finish/></txt><txt ptr="0xa998f138" next="0xa998f1c8" prev="0xa998f0a8" upper="0xa999c128" lower="(nil)">void del(int l,int r,int i,int x) {<Finish/></txt><txt ptr="0xa998f1c8" next="0xa998f258" prev="0xa998f138" upper="0xa999c128" lower="(nil)">    erase(tree[id(l,r)],x);<Finish/></txt><txt ptr="0xa998f258" next="0xa998f2e8" prev="0xa998f1c8" upper="0xa999c128" lower="(nil)">    if(l==r) return;<Finish/></txt><txt ptr="0xa998f2e8" next="0xa998f378" prev="0xa998f258" upper="0xa999c128" lower="(nil)">    int m=(l+r)&gt;&gt;1;<Finish/></txt><txt ptr="0xa998f378" next="0xa998f408" prev="0xa998f2e8" upper="0xa999c128" lower="(nil)">    if(i&lt;=m) del(l,m,i,x);<Finish/></txt><txt ptr="0xa998f408" next="0xa998f498" prev="0xa998f378" upper="0xa999c128" lower="(nil)">    if(i&gt;m) del(m+1,r,i,x);<Finish/></txt><txt ptr="0xa998f498" next="0xa998f528" prev="0xa998f408" upper="0xa999c128" lower="(nil)">}<Finish/></txt><txt ptr="0xa998f528" next="0xa998f5b8" prev="0xa998f498" upper="0xa999c128" lower="(nil)"><Finish/></txt><txt ptr="0xa998f5b8" next="0xa998f648" prev="0xa998f528" upper="0xa999c128" lower="(nil)">void query(int l,int r,int L,int R,int x) {<Finish/></txt><txt ptr="0xa998f648" next="0xa998f6d8" prev="0xa998f5b8" upper="0xa999c128" lower="(nil)">    if(L&lt;=l &amp;&amp; R&gt;=r) {<Finish/></txt><txt ptr="0xa998f6d8" next="0xa998f768" prev="0xa998f648" upper="0xa999c128" lower="(nil)">        ans+=select(tree[id(l,r)],x);<Finish/></txt><txt ptr="0xa998f768" next="0xa998f7f8" prev="0xa998f6d8" upper="0xa999c128" lower="(nil)">        return;<Finish/></txt><txt ptr="0xa998f7f8" next="0xa998f888" prev="0xa998f768" upper="0xa999c128" lower="(nil)">    }<Finish/></txt><txt ptr="0xa998f888" next="0xa998f918" prev="0xa998f7f8" upper="0xa999c128" lower="(nil)">    int m=(l+r)&gt;&gt;1;<Finish/></txt><txt ptr="0xa998f918" next="0xa998f9a8" prev="0xa998f888" upper="0xa999c128" lower="(nil)">    if(L&lt;=m) query(l,m,L,R,x);<Finish/></txt><txt ptr="0xa998f9a8" next="0xa998fa38" prev="0xa998f918" upper="0xa999c128" lower="(nil)">    if(R&gt;m) query(m+1,r,L,R,x);<Finish/></txt><txt ptr="0xa998fa38" next="0xa998fac8" prev="0xa998f9a8" upper="0xa999c128" lower="(nil)">}<Finish/></txt><txt ptr="0xa998fac8" next="0xa998fb58" prev="0xa998fa38" upper="0xa999c128" lower="(nil)"><Finish/></txt><txt ptr="0xa998fb58" next="0xa998fbe8" prev="0xa998fac8" upper="0xa999c128" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa998fbe8" next="0xa998fc78" prev="0xa998fb58" upper="0xa999c128" lower="(nil)">    int tt;<Finish/></txt><txt ptr="0xa998fc78" next="0xa998fd08" prev="0xa998fbe8" upper="0xa999c128" lower="(nil)">    scanf(&quot;%d&quot;,&amp;tt);<Finish/></txt><txt ptr="0xa998fd08" next="0xa998fd98" prev="0xa998fc78" upper="0xa999c128" lower="(nil)">    while (tt--) {<Finish/></txt><txt ptr="0xa998fd98" next="0xa998fe28" prev="0xa998fd08" upper="0xa999c128" lower="(nil)">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);<Finish/></txt><txt ptr="0xa998fe28" next="0xa99901cc" prev="0xa998fd98" upper="0xa999c128" lower="(nil)">        init();<Finish/></txt><txt ptr="0xa99901cc" next="0xa999025c" prev="0xa998fe28" upper="0xa999c128" lower="(nil)">        memset(tree,0,sizeof(tree));<Finish/></txt><txt ptr="0xa999025c" next="0xa99902ec" prev="0xa99901cc" upper="0xa999c128" lower="(nil)">        for(int i=1; i&lt;=n; i++) {<Finish/></txt><txt ptr="0xa99902ec" next="(nil)" prev="0xa999025c" upper="0xa999c128" lower="(nil)">            scanf(&quot;%d&quot;,&amp;a[i]);<Finish/></txt></body></column><column ptr="0xa88efe9c" next="(nil)" prev="0xa88efe38" upper="0xa894b58c" lower="0xa999c368"><body ptr="0xa999c368" next="(nil)" prev="(nil)" upper="0xa88efe9c" lower="0xa999037c"><txt ptr="0xa999037c" next="0xa999040c" prev="(nil)" upper="0xa999c368" lower="(nil)">            treeinsert(1,n,i,a[i]);<Finish/></txt><txt ptr="0xa999040c" next="0xa999049c" prev="0xa999037c" upper="0xa999c368" lower="(nil)">        }<Finish/></txt><txt ptr="0xa999049c" next="0xa999052c" prev="0xa999040c" upper="0xa999c368" lower="(nil)">        while (m--) {<Finish/></txt><txt ptr="0xa999052c" next="0xa99905bc" prev="0xa999049c" upper="0xa999c368" lower="(nil)">            char s[5];<Finish/></txt><txt ptr="0xa99905bc" next="0xa999064c" prev="0xa999052c" upper="0xa999c368" lower="(nil)">            int x,y,c;<Finish/></txt><txt ptr="0xa999064c" next="0xa99906dc" prev="0xa99905bc" upper="0xa999c368" lower="(nil)">            scanf(&quot;%s&quot;,s);<Finish/></txt><txt ptr="0xa99906dc" next="0xa999076c" prev="0xa999064c" upper="0xa999c368" lower="(nil)">            if(s[0]=='C') {<Finish/></txt><txt ptr="0xa999076c" next="0xa99907fc" prev="0xa99906dc" upper="0xa999c368" lower="(nil)">                scanf(&quot;%d %d&quot;,&amp;x,&amp;y);<Finish/></txt><txt ptr="0xa99907fc" next="0xa999088c" prev="0xa999076c" upper="0xa999c368" lower="(nil)">                del(1,n,x,a[x]);<Finish/></txt><txt ptr="0xa999088c" next="0xa999091c" prev="0xa99907fc" upper="0xa999c368" lower="(nil)">                a[x]=y;<Finish/></txt><txt ptr="0xa999091c" next="0xa99909ac" prev="0xa999088c" upper="0xa999c368" lower="(nil)">                treeinsert(1,n,x,a[x]);<Finish/></txt><txt ptr="0xa99909ac" next="0xa9990a3c" prev="0xa999091c" upper="0xa999c368" lower="(nil)">            } else {<Finish/></txt><txt ptr="0xa9990a3c" next="0xa9990acc" prev="0xa99909ac" upper="0xa999c368" lower="(nil)">                scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;c);<Finish/></txt><txt ptr="0xa9990acc" next="0xa9990b5c" prev="0xa9990a3c" upper="0xa999c368" lower="(nil)">                int l=0,r=INF,mid;<Finish/></txt><txt ptr="0xa9990b5c" next="0xa9990bec" prev="0xa9990acc" upper="0xa999c368" lower="(nil)">                while (l&lt;r) {<Finish/></txt><txt ptr="0xa9990bec" next="0xa9990c7c" prev="0xa9990b5c" upper="0xa999c368" lower="(nil)">                    ans=0;<Finish/></txt><txt ptr="0xa9990c7c" next="0xa9990d0c" prev="0xa9990bec" upper="0xa999c368" lower="(nil)">                    mid=(l+r)&gt;&gt;1;<Finish/></txt><txt ptr="0xa9990d0c" next="0xa9990d9c" prev="0xa9990c7c" upper="0xa999c368" lower="(nil)">                    query(1,n,x,y,mid);<Finish/></txt><txt ptr="0xa9990d9c" next="0xa9990e2c" prev="0xa9990d0c" upper="0xa999c368" lower="(nil)">                    if(ans&lt;c) l=mid+1;<Finish/></txt><txt ptr="0xa9990e2c" next="0xa9990ebc" prev="0xa9990d9c" upper="0xa999c368" lower="(nil)">                    else r=mid;<Finish/></txt><txt ptr="0xa9990ebc" next="0xa9990f4c" prev="0xa9990e2c" upper="0xa999c368" lower="(nil)">                }<Finish/></txt><txt ptr="0xa9990f4c" next="0xa9992020" prev="0xa9990ebc" upper="0xa999c368" lower="(nil)">                printf(&quot;%d\n&quot;,l);<Finish/></txt><txt ptr="0xa9992020" next="0xa99920b0" prev="0xa9990f4c" upper="0xa999c368" lower="(nil)">            }<Finish/></txt><txt ptr="0xa99920b0" next="0xa9992140" prev="0xa9992020" upper="0xa999c368" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9992140" next="0xa99921d0" prev="0xa99920b0" upper="0xa999c368" lower="(nil)">    }<Finish/></txt><txt ptr="0xa99921d0" next="0xa9992260" prev="0xa9992140" upper="0xa999c368" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa9992260" next="0xa99922f0" prev="0xa99921d0" upper="0xa999c368" lower="(nil)">}<Finish/></txt><txt ptr="0xa99922f0" next="(nil)" prev="0xa9992260" upper="0xa999c368" lower="(nil)"><Finish/></txt></body></column></section></body><footer ptr="0xa89983c0" next="(nil)" prev="0xa99c80c4" upper="0xa89934fc" lower="0xa99c9750"><txt ptr="0xa99c9750" next="0xa99c9900" prev="(nil)" upper="0xa89983c0" lower="(nil)"><anchored><fly ptr="0xb44bd28" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99c97e0"><txt ptr="0xa99c97e0" next="0xa99c9870" prev="(nil)" upper="0xb44bd28" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99c9870" next="(nil)" prev="0xa99c97e0" upper="0xb44bd28" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="1"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="3"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99c9900" next="(nil)" prev="0xa99c9750" upper="0xa89983c0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993570" next="0xa89935e4" prev="0xa89934fc" upper="0xb0726b0" lower="0xa8996420"><header ptr="0xa8996420" next="0xa99c8244" prev="(nil)" upper="0xa8993570" lower="0xa99abc64"><txt ptr="0xa99abc64" next="(nil)" prev="(nil)" upper="0xa8996420" lower="(nil)"><Finish/></txt></header><body ptr="0xa99c8244" next="0xa8998420" prev="0xa8996420" upper="0xa8993570" lower="0xa998cb84"><section ptr="0xa998cb84" next="(nil)" prev="(nil)" upper="0xa99c8244" lower="0xa898b010" follow="0xa894b30c" precede="0xa894b58c"><column ptr="0xa898b010" next="0xa898b074" prev="(nil)" upper="0xa998cb84" lower="0xa8989134"><body ptr="0xa8989134" next="(nil)" prev="(nil)" upper="0xa898b010" lower="0xa9992380"><txt ptr="0xa9992380" next="0xa9992410" prev="(nil)" upper="0xa8989134" lower="(nil)">划分树<Finish/></txt><txt ptr="0xa9992410" next="0xa9992770" prev="0xa9992380" upper="0xa8989134" lower="(nil)">主要模拟归并排序。<Finish/></txt><txt ptr="0xa9992770" next="0xa9992800" prev="0xa9992410" upper="0xa8989134" lower="(nil)">求区间第K数时，判断这个的数进入左半部多少个，记为p，如果大于k，则第k数就在左半部，否则就在右半部，且为右半部的第k-p数。<Finish/></txt><txt ptr="0xa9992800" next="0xa9992890" prev="0xa9992770" upper="0xa8989134" lower="(nil)">这样递归下去就可以了。<Finish/></txt><txt ptr="0xa9992890" next="0xa9992920" prev="0xa9992800" upper="0xa8989134" lower="(nil)"><Finish/></txt><txt ptr="0xa9992920" next="0xa99929b0" prev="0xa9992890" upper="0xa8989134" lower="(nil)">input 输入的数据，下标从1开始，数据可以重复<Finish/></txt><txt ptr="0xa99929b0" next="0xa9992a40" prev="0xa9992920" upper="0xa8989134" lower="(nil)">sortedPos input的第几个位置的值应该在当前位置<Finish/></txt><txt ptr="0xa9992a40" next="0xa9992ad0" prev="0xa99929b0" upper="0xa8989134" lower="(nil)">val  input的当前值应该在那个位置<Finish/></txt><txt ptr="0xa9992ad0" next="0xa9992b60" prev="0xa9992a40" upper="0xa8989134" lower="(nil)"><Finish/></txt><txt ptr="0xa9992b60" next="0xa9992bf0" prev="0xa9992ad0" upper="0xa8989134" lower="(nil)">int n;<Finish/></txt><txt ptr="0xa9992bf0" next="0xa9992c80" prev="0xa9992b60" upper="0xa8989134" lower="(nil)">int arr[N];//原数据,下标从1开始<Finish/></txt><txt ptr="0xa9992c80" next="0xa9992d10" prev="0xa9992bf0" upper="0xa8989134" lower="(nil)">int sortedPos[N];//排序后<Finish/></txt><txt ptr="0xa9992d10" next="0xa9992da0" prev="0xa9992c80" upper="0xa8989134" lower="(nil)">int lfnum[20][N];//元素所在区间的当前位置进入左孩子的元素的个数<Finish/></txt><txt ptr="0xa9992da0" next="0xa9992e30" prev="0xa9992d10" upper="0xa8989134" lower="(nil)">int val[20][N];//记录第k层当前位置的元素的值<Finish/></txt><txt ptr="0xa9992e30" next="0xa9992ec0" prev="0xa9992da0" upper="0xa8989134" lower="(nil)">bool cmp(const int &amp;x,const int &amp;y) {<Finish/></txt><txt ptr="0xa9992ec0" next="0xa9992f50" prev="0xa9992e30" upper="0xa8989134" lower="(nil)">    return arr[x]&lt;arr[y];<Finish/></txt><txt ptr="0xa9992f50" next="0xa9993024" prev="0xa9992ec0" upper="0xa8989134" lower="(nil)">}<Finish/></txt><txt ptr="0xa9993024" next="0xa99930b4" prev="0xa9992f50" upper="0xa8989134" lower="(nil)">void build(int l,int r,int d) {<Finish/></txt><txt ptr="0xa99930b4" next="0xa9993144" prev="0xa9993024" upper="0xa8989134" lower="(nil)">    if(l==r) return;<Finish/></txt><txt ptr="0xa9993144" next="0xa99931d4" prev="0xa99930b4" upper="0xa8989134" lower="(nil)">    int mid=(l+r)&gt;&gt;1,p=0;<Finish/></txt><txt ptr="0xa99931d4" next="0xa9993264" prev="0xa9993144" upper="0xa8989134" lower="(nil)">    for(int i=l; i&lt;=r; i++) {<Finish/></txt><txt ptr="0xa9993264" next="0xa99932f4" prev="0xa99931d4" upper="0xa8989134" lower="(nil)">        if(val[d][i]&lt;=mid) {<Finish/></txt><txt ptr="0xa99932f4" next="0xa9993384" prev="0xa9993264" upper="0xa8989134" lower="(nil)">            val[d+1][l+p]=val[d][i];<Finish/></txt><txt ptr="0xa9993384" next="(nil)" prev="0xa99932f4" upper="0xa8989134" lower="(nil)">            lfnum[d][i]=++p;<Finish/></txt></body></column><column ptr="0xa898b074" next="0xa898b0d8" prev="0xa898b010" upper="0xa998cb84" lower="0xa8989194"><body ptr="0xa8989194" next="(nil)" prev="(nil)" upper="0xa898b074" lower="0xa9993414"><txt ptr="0xa9993414" next="0xa99934a4" prev="(nil)" upper="0xa8989194" lower="(nil)">        } else {<Finish/></txt><txt ptr="0xa99934a4" next="0xa9993534" prev="0xa9993414" upper="0xa8989194" lower="(nil)">            lfnum[d][i]=p;<Finish/></txt><txt ptr="0xa9993534" next="0xa99935c4" prev="0xa99934a4" upper="0xa8989194" lower="(nil)">            val[d+1][mid+i+1-l-p]=val[d][i];<Finish/></txt><txt ptr="0xa99935c4" next="0xa9993654" prev="0xa9993534" upper="0xa8989194" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9993654" next="0xa99936e4" prev="0xa99935c4" upper="0xa8989194" lower="(nil)">    }<Finish/></txt><txt ptr="0xa99936e4" next="0xa9993774" prev="0xa9993654" upper="0xa8989194" lower="(nil)">    build(l,mid,d+1);<Finish/></txt><txt ptr="0xa9993774" next="0xa9993804" prev="0xa99936e4" upper="0xa8989194" lower="(nil)">    build(mid+1,r,d+1);<Finish/></txt><txt ptr="0xa9993804" next="0xa9993894" prev="0xa9993774" upper="0xa8989194" lower="(nil)">}<Finish/></txt><txt ptr="0xa9993894" next="0xa9993924" prev="0xa9993804" upper="0xa8989194" lower="(nil)">//求区间[s,e]第k大的元素<Finish/></txt><txt ptr="0xa9993924" next="0xa99939b4" prev="0xa9993894" upper="0xa8989194" lower="(nil)">int query(int s,int e,int k,int l=1,int r=n,int d=0) {<Finish/></txt><txt ptr="0xa99939b4" next="0xa9993d14" prev="0xa9993924" upper="0xa8989194" lower="(nil)">    if(l==r) return l;<Finish/></txt><txt ptr="0xa9993d14" next="0xa9993da4" prev="0xa99939b4" upper="0xa8989194" lower="(nil)">    int mid=(l+r)&gt;&gt;1,ss,ee;<Finish/></txt><txt ptr="0xa9993da4" next="0xa9993e34" prev="0xa9993d14" upper="0xa8989194" lower="(nil)">    ss=(s==l?0:lfnum[d][s-1]);<Finish/></txt><txt ptr="0xa9993e34" next="0xa9993ec4" prev="0xa9993da4" upper="0xa8989194" lower="(nil)">    ee=lfnum[d][e];<Finish/></txt><txt ptr="0xa9993ec4" next="0xa9993f54" prev="0xa9993e34" upper="0xa8989194" lower="(nil)">    if(ee-ss&gt;=k) return query(l+ss,l+ee-1,k,l,mid,d+1);<Finish/></txt><txt ptr="0xa9993f54" next="0xa9995028" prev="0xa9993ec4" upper="0xa8989194" lower="(nil)">    return query(mid+1+(s-l-ss),mid+1+(e-l-ee),k-(ee-ss),mid+1,r,d+1);<Finish/></txt><txt ptr="0xa9995028" next="0xa99950b8" prev="0xa9993f54" upper="0xa8989194" lower="(nil)">}<Finish/></txt><txt ptr="0xa99950b8" next="0xa9995148" prev="0xa9995028" upper="0xa8989194" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa9995148" next="0xa99951d8" prev="0xa99950b8" upper="0xa8989194" lower="(nil)">    int cas=0,m,l,r,k;<Finish/></txt><txt ptr="0xa99951d8" next="0xa9995268" prev="0xa9995148" upper="0xa8989194" lower="(nil)">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) {<Finish/></txt><txt ptr="0xa9995268" next="0xa99952f8" prev="0xa99951d8" upper="0xa8989194" lower="(nil)">        for(int i=1; i&lt;=n; i++){<Finish/></txt><txt ptr="0xa99952f8" next="0xa9995388" prev="0xa9995268" upper="0xa8989194" lower="(nil)">            scanf(&quot;%d&quot;,arr+i),sortedPos[i]=i;<Finish/></txt><txt ptr="0xa9995388" next="0xa9995418" prev="0xa99952f8" upper="0xa8989194" lower="(nil)">        }               <Finish/></txt><txt ptr="0xa9995418" next="0xa99954a8" prev="0xa9995388" upper="0xa8989194" lower="(nil)">sort(sortedPos+1,sortedPos+n+1,cmp);<Finish/></txt><txt ptr="0xa99954a8" next="0xa9995538" prev="0xa9995418" upper="0xa8989194" lower="(nil)">        for(int i=1; i&lt;=n; i++){<Finish/></txt><txt ptr="0xa9995538" next="0xa99955c8" prev="0xa99954a8" upper="0xa8989194" lower="(nil)">            val[0][sortedPos[i]]=i;<Finish/></txt><txt ptr="0xa99955c8" next="(nil)" prev="0xa9995538" upper="0xa8989194" lower="(nil)">        }<Finish/></txt></body></column><column ptr="0xa898b0d8" next="(nil)" prev="0xa898b074" upper="0xa998cb84" lower="0xa89891f4"><body ptr="0xa89891f4" next="(nil)" prev="(nil)" upper="0xa898b0d8" lower="0xa9995658"><txt ptr="0xa9995658" next="0xa99956e8" prev="(nil)" upper="0xa89891f4" lower="(nil)">        build(1,n,0);<Finish/></txt><txt ptr="0xa99956e8" next="0xa9995778" prev="0xa9995658" upper="0xa89891f4" lower="(nil)">        while(m--) {<Finish/></txt><txt ptr="0xa9995778" next="0xa9995808" prev="0xa99956e8" upper="0xa89891f4" lower="(nil)">            scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k);<Finish/></txt><txt ptr="0xa9995808" next="0xa9995898" prev="0xa9995778" upper="0xa89891f4" lower="(nil)">           printf(&quot;%d\n&quot;,arr[sortedPos[query(l,r,k)]]);<Finish/></txt><txt ptr="0xa9995898" next="0xa9995928" prev="0xa9995808" upper="0xa89891f4" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9995928" next="0xa99959b8" prev="0xa9995898" upper="0xa89891f4" lower="(nil)">    }<Finish/></txt><txt ptr="0xa99959b8" next="0xa9995a48" prev="0xa9995928" upper="0xa89891f4" lower="(nil)">}<Finish/></txt><txt ptr="0xa9995a48" next="0xa9995ad8" prev="0xa99959b8" upper="0xa89891f4" lower="(nil)">左偏树<Finish/></txt><txt ptr="0xa9995ad8" next="0xa9995b68" prev="0xa9995a48" upper="0xa89891f4" lower="(nil)">左偏树(Leftist Tree)是一种可并堆的实现。<Finish/></txt><txt ptr="0xa9995b68" next="0xa9995bf8" prev="0xa9995ad8" upper="0xa89891f4" lower="(nil)"><Finish/></txt><txt ptr="0xa9995bf8" next="0xa9995c88" prev="0xa9995b68" upper="0xa89891f4" lower="(nil)">const int MAXN = 100010;<Finish/></txt><txt ptr="0xa9995c88" next="0xa9995d18" prev="0xa9995bf8" upper="0xa89891f4" lower="(nil)"><Finish/></txt><txt ptr="0xa9995d18" next="0xa9995da8" prev="0xa9995c88" upper="0xa89891f4" lower="(nil)">struct Node {<Finish/></txt><txt ptr="0xa9995da8" next="0xa9995e38" prev="0xa9995d18" upper="0xa89891f4" lower="(nil)">    int key, dist, lc, rc;<Finish/></txt><txt ptr="0xa9995e38" next="0xa9995ec8" prev="0xa9995da8" upper="0xa89891f4" lower="(nil)">    void init(int _dist = 0, int _key = 0) {<Finish/></txt><txt ptr="0xa9995ec8" next="0xa9995f58" prev="0xa9995e38" upper="0xa89891f4" lower="(nil)">        key = _key;<Finish/></txt><txt ptr="0xa9995f58" next="0xa99972d0" prev="0xa9995ec8" upper="0xa89891f4" lower="(nil)">        dist = _dist;<Finish/></txt><txt ptr="0xa99972d0" next="0xa9997360" prev="0xa9995f58" upper="0xa89891f4" lower="(nil)">        lc = rc = 0;<Finish/></txt><txt ptr="0xa9997360" next="0xa99973f0" prev="0xa99972d0" upper="0xa89891f4" lower="(nil)">    }<Finish/></txt><txt ptr="0xa99973f0" next="0xa9997480" prev="0xa9997360" upper="0xa89891f4" lower="(nil)"><Finish/></txt><txt ptr="0xa9997480" next="0xa9997510" prev="0xa99973f0" upper="0xa89891f4" lower="(nil)">} nodes[MAXN];<Finish/></txt><txt ptr="0xa9997510" next="0xa99975a0" prev="0xa9997480" upper="0xa89891f4" lower="(nil)">int memeryNode[MAXN];<Finish/></txt><txt ptr="0xa99975a0" next="0xa9997630" prev="0xa9997510" upper="0xa89891f4" lower="(nil)">int allocNode,allocMemery;<Finish/></txt><txt ptr="0xa9997630" next="0xa99976c0" prev="0xa99975a0" upper="0xa89891f4" lower="(nil)"><Finish/></txt><txt ptr="0xa99976c0" next="0xa9997750" prev="0xa9997630" upper="0xa89891f4" lower="(nil)">void initNode() {<Finish/></txt><txt ptr="0xa9997750" next="0xa99977e0" prev="0xa99976c0" upper="0xa89891f4" lower="(nil)">    nodes[0].init(-1);//0作为NULL节点<Finish/></txt><txt ptr="0xa99977e0" next="(nil)" prev="0xa9997750" upper="0xa89891f4" lower="(nil)">    allocNode = 1;<Finish/></txt></body></column></section></body><footer ptr="0xa8998420" next="(nil)" prev="0xa99c8244" upper="0xa8993570" lower="0xa99abcf4"><txt ptr="0xa99abcf4" next="0xa99abea4" prev="(nil)" upper="0xa8998420" lower="(nil)"><anchored><fly ptr="0xa5c64f0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99abd84"><txt ptr="0xa99abd84" next="0xa99abe14" prev="(nil)" upper="0xa5c64f0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99abe14" next="(nil)" prev="0xa99abd84" upper="0xa5c64f0" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="1"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="4"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99abea4" next="(nil)" prev="0xa99abcf4" upper="0xa8998420" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa89935e4" next="0xa8993658" prev="0xa8993570" upper="0xb0726b0" lower="0xa8996480"><header ptr="0xa8996480" next="0xa99c83c4" prev="(nil)" upper="0xa89935e4" lower="0xa99ad24c"><txt ptr="0xa99ad24c" next="(nil)" prev="(nil)" upper="0xa8996480" lower="(nil)"><Finish/></txt></header><body ptr="0xa99c83c4" next="0xa8998480" prev="0xa8996480" upper="0xa89935e4" lower="0xa894b30c"><section ptr="0xa894b30c" next="(nil)" prev="(nil)" upper="0xa99c83c4" lower="0xa6bff1bc" follow="0xa998ce84" precede="0xa998cb84"><column ptr="0xa6bff1bc" next="0xa6bff220" prev="(nil)" upper="0xa894b30c" lower="0xa999c848"><body ptr="0xa999c848" next="(nil)" prev="(nil)" upper="0xa6bff1bc" lower="0xa9997870"><txt ptr="0xa9997870" next="0xa9997900" prev="(nil)" upper="0xa999c848" lower="(nil)">    allocMemery = 0;<Finish/></txt><txt ptr="0xa9997900" next="0xa9997990" prev="0xa9997870" upper="0xa999c848" lower="(nil)">}<Finish/></txt><txt ptr="0xa9997990" next="0xa9997a20" prev="0xa9997900" upper="0xa999c848" lower="(nil)"><Finish/></txt><txt ptr="0xa9997a20" next="0xa9997ab0" prev="0xa9997990" upper="0xa999c848" lower="(nil)">int newNode(int x) {<Finish/></txt><txt ptr="0xa9997ab0" next="0xa9997b40" prev="0xa9997a20" upper="0xa999c848" lower="(nil)">    int tmp;<Finish/></txt><txt ptr="0xa9997b40" next="0xa9997bd0" prev="0xa9997ab0" upper="0xa999c848" lower="(nil)">    if(allocMemery) {<Finish/></txt><txt ptr="0xa9997bd0" next="0xa9997c60" prev="0xa9997b40" upper="0xa999c848" lower="(nil)">        tmp = memeryNode[--allocMemery];<Finish/></txt><txt ptr="0xa9997c60" next="0xa9997cf0" prev="0xa9997bd0" upper="0xa999c848" lower="(nil)">    } else {<Finish/></txt><txt ptr="0xa9997cf0" next="0xa9997d80" prev="0xa9997c60" upper="0xa999c848" lower="(nil)">        tmp = allocNode++;<Finish/></txt><txt ptr="0xa9997d80" next="0xa9997e10" prev="0xa9997cf0" upper="0xa999c848" lower="(nil)">    }<Finish/></txt><txt ptr="0xa9997e10" next="0xa9997ea0" prev="0xa9997d80" upper="0xa999c848" lower="(nil)">    nodes[tmp].init(0, x);<Finish/></txt><txt ptr="0xa9997ea0" next="0xa9997f30" prev="0xa9997e10" upper="0xa999c848" lower="(nil)">    return tmp;<Finish/></txt><txt ptr="0xa9997f30" next="0xa9998004" prev="0xa9997ea0" upper="0xa999c848" lower="(nil)">}<Finish/></txt><txt ptr="0xa9998004" next="0xa9998094" prev="0xa9997f30" upper="0xa999c848" lower="(nil)"><Finish/></txt><txt ptr="0xa9998094" next="0xa9998124" prev="0xa9998004" upper="0xa999c848" lower="(nil)">void deleteNode(int A) {<Finish/></txt><txt ptr="0xa9998124" next="0xa99981b4" prev="0xa9998094" upper="0xa999c848" lower="(nil)">    memeryNode[allocMemery++] = A;<Finish/></txt><txt ptr="0xa99981b4" next="0xa9998244" prev="0xa9998124" upper="0xa999c848" lower="(nil)">}<Finish/></txt><txt ptr="0xa9998244" next="0xa99982d4" prev="0xa99981b4" upper="0xa999c848" lower="(nil)"><Finish/></txt><txt ptr="0xa99982d4" next="0xa9998364" prev="0xa9998244" upper="0xa999c848" lower="(nil)">int merge(int A, int B) {<Finish/></txt><txt ptr="0xa9998364" next="0xa99983f4" prev="0xa99982d4" upper="0xa999c848" lower="(nil)">    if (A != 0 &amp;&amp; B != 0) {<Finish/></txt><txt ptr="0xa99983f4" next="0xa9998484" prev="0xa9998364" upper="0xa999c848" lower="(nil)">        if (nodes[A].key &lt; nodes[B].key) {<Finish/></txt><txt ptr="0xa9998484" next="0xa9998514" prev="0xa99983f4" upper="0xa999c848" lower="(nil)">            swap(A, B);<Finish/></txt><txt ptr="0xa9998514" next="0xa9998874" prev="0xa9998484" upper="0xa999c848" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9998874" next="0xa9998904" prev="0xa9998514" upper="0xa999c848" lower="(nil)">        nodes[A].rc = merge(nodes[A].rc, B);<Finish/></txt><txt ptr="0xa9998904" next="0xa9998994" prev="0xa9998874" upper="0xa999c848" lower="(nil)">        int &amp;lc = nodes[A].lc;<Finish/></txt><txt ptr="0xa9998994" next="0xa9998a24" prev="0xa9998904" upper="0xa999c848" lower="(nil)">        int &amp;rc = nodes[A].rc;<Finish/></txt><txt ptr="0xa9998a24" next="0xa9998ab4" prev="0xa9998994" upper="0xa999c848" lower="(nil)">        if (nodes[lc].dist &lt; nodes[rc].dist) {<Finish/></txt><txt ptr="0xa9998ab4" next="(nil)" prev="0xa9998a24" upper="0xa999c848" lower="(nil)">            swap(lc, rc);<Finish/></txt></body></column><column ptr="0xa6bff220" next="0xa6bff284" prev="0xa6bff1bc" upper="0xa894b30c" lower="0xa999c8a8"><body ptr="0xa999c8a8" next="(nil)" prev="(nil)" upper="0xa6bff220" lower="0xa9998b44"><txt ptr="0xa9998b44" next="0xa9998bd4" prev="(nil)" upper="0xa999c8a8" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9998bd4" next="0xa9998c64" prev="0xa9998b44" upper="0xa999c8a8" lower="(nil)">        nodes[A].dist = nodes[rc].dist + 1;<Finish/></txt><txt ptr="0xa9998c64" next="0xa9998cf4" prev="0xa9998bd4" upper="0xa999c8a8" lower="(nil)">    } else {<Finish/></txt><txt ptr="0xa9998cf4" next="0xa9998d84" prev="0xa9998c64" upper="0xa999c8a8" lower="(nil)">        A = A == 0 ? B : A;<Finish/></txt><txt ptr="0xa9998d84" next="0xa9998e14" prev="0xa9998cf4" upper="0xa999c8a8" lower="(nil)">    }<Finish/></txt><txt ptr="0xa9998e14" next="0xa9998ea4" prev="0xa9998d84" upper="0xa999c8a8" lower="(nil)">    return A;<Finish/></txt><txt ptr="0xa9998ea4" next="0xa9998f34" prev="0xa9998e14" upper="0xa999c8a8" lower="(nil)">}<Finish/></txt><txt ptr="0xa9998f34" next="0xa9999008" prev="0xa9998ea4" upper="0xa999c8a8" lower="(nil)"><Finish/></txt><txt ptr="0xa9999008" next="0xa9999098" prev="0xa9998f34" upper="0xa999c8a8" lower="(nil)"><Finish/></txt><txt ptr="0xa9999098" next="0xa9999128" prev="0xa9999008" upper="0xa999c8a8" lower="(nil)">int pop(int A) {<Finish/></txt><txt ptr="0xa9999128" next="0xa99991b8" prev="0xa9999098" upper="0xa999c8a8" lower="(nil)">    int t = merge(nodes[A].lc, nodes[A].rc);<Finish/></txt><txt ptr="0xa99991b8" next="0xa9999248" prev="0xa9999128" upper="0xa999c8a8" lower="(nil)">    deleteNode(A);<Finish/></txt><txt ptr="0xa9999248" next="0xa99992d8" prev="0xa99991b8" upper="0xa999c8a8" lower="(nil)">    return t;<Finish/></txt><txt ptr="0xa99992d8" next="0xa9999368" prev="0xa9999248" upper="0xa999c8a8" lower="(nil)">}<Finish/></txt><txt ptr="0xa9999368" next="0xa99993f8" prev="0xa99992d8" upper="0xa999c8a8" lower="(nil)"><Finish/></txt><txt ptr="0xa99993f8" next="0xa9999488" prev="0xa9999368" upper="0xa999c8a8" lower="(nil)">void insert(int v) {<Finish/></txt><txt ptr="0xa9999488" next="0xa9999518" prev="0xa99993f8" upper="0xa999c8a8" lower="(nil)">    merge(0, newNode(v));<Finish/></txt><txt ptr="0xa9999518" next="0xa99995a8" prev="0xa9999488" upper="0xa999c8a8" lower="(nil)">}<Finish/></txt><txt ptr="0xa99995a8" next="0xa9999638" prev="0xa9999518" upper="0xa999c8a8" lower="(nil)"><Finish/></txt><txt ptr="0xa9999638" next="0xa99996c8" prev="0xa99995a8" upper="0xa999c8a8" lower="(nil)"><Finish/></txt><txt ptr="0xa99996c8" next="0xa9999758" prev="0xa9999638" upper="0xa999c8a8" lower="(nil)"><Finish/></txt><txt ptr="0xa9999758" next="0xa99997e8" prev="0xa99996c8" upper="0xa999c8a8" lower="(nil)">DLX<Finish/></txt><txt ptr="0xa99997e8" next="0xa9999878" prev="0xa9999758" upper="0xa999c8a8" lower="(nil)">双向十字链表用LRUD来记录，LR来记录左右方向的双向链表，UD来记录上下方向的双向链表。<Finish/></txt><txt ptr="0xa9999878" next="0xa9999908" prev="0xa99997e8" upper="0xa999c8a8" lower="(nil)"><Finish/></txt><txt ptr="0xa9999908" next="(nil)" prev="0xa9999878" upper="0xa999c8a8" lower="(nil)">head 指向总的头指针，head通过LR来贯穿的列指针头。<Finish/></txt></body></column><column ptr="0xa6bff284" next="(nil)" prev="0xa6bff220" upper="0xa894b30c" lower="0xa999cae8"><body ptr="0xa999cae8" next="(nil)" prev="(nil)" upper="0xa6bff284" lower="0xa9999998"><txt ptr="0xa9999998" next="0xa9999a28" prev="(nil)" upper="0xa999cae8" lower="(nil)">LRUD的前m个一般作为其列指针头的地址。<Finish/></txt><txt ptr="0xa9999a28" next="0xa9999ab8" prev="0xa9999998" upper="0xa999cae8" lower="(nil)">rowHead[x]是指向其列指针头的地址。<Finish/></txt><txt ptr="0xa9999ab8" next="0xa9999e18" prev="0xa9999a28" upper="0xa999cae8" lower="(nil)">colNum[x]录列链表中结点的总数。<Finish/></txt><txt ptr="0xa9999e18" next="0xa9999ea8" prev="0xa9999ab8" upper="0xa999cae8" lower="(nil)">selectRow[x]用来记录搜索结果。<Finish/></txt><txt ptr="0xa9999ea8" next="0xa9999f38" prev="0xa9999e18" upper="0xa999cae8" lower="(nil)">col[x]代表x的列数<Finish/></txt><txt ptr="0xa9999f38" next="0xa997a00c" prev="0xa9999ea8" upper="0xa999cae8" lower="(nil)">row[x]代表x的行数<Finish/></txt><txt ptr="0xa997a00c" next="0xa997a09c" prev="0xa9999f38" upper="0xa999cae8" lower="(nil)"><Finish/></txt><txt ptr="0xa997a09c" next="0xa997a12c" prev="0xa997a00c" upper="0xa999cae8" lower="(nil)">//一般需要使用A*或IDA*优化。<Finish/></txt><txt ptr="0xa997a12c" next="0xa997a1bc" prev="0xa997a09c" upper="0xa999cae8" lower="(nil)">//以exact cover problem的代码为例子<Finish/></txt><txt ptr="0xa997a1bc" next="0xa997a24c" prev="0xa997a12c" upper="0xa999cae8" lower="(nil)">const int N = 1005;<Finish/></txt><txt ptr="0xa997a24c" next="0xa997a2dc" prev="0xa997a1bc" upper="0xa999cae8" lower="(nil)">const int M = 1005;<Finish/></txt><txt ptr="0xa997a2dc" next="0xa997a36c" prev="0xa997a24c" upper="0xa999cae8" lower="(nil)">const int maxn = N*M;<Finish/></txt><txt ptr="0xa997a36c" next="0xa997a3fc" prev="0xa997a2dc" upper="0xa999cae8" lower="(nil)">int R[maxn], L[maxn], U[maxn], D[maxn];<Finish/></txt><txt ptr="0xa997a3fc" next="0xa997a48c" prev="0xa997a36c" upper="0xa999cae8" lower="(nil)">int col[maxn], row[maxn];<Finish/></txt><txt ptr="0xa997a48c" next="0xa997a51c" prev="0xa997a3fc" upper="0xa999cae8" lower="(nil)">int rowHead[M], selectRow[N],colNum[N];<Finish/></txt><txt ptr="0xa997a51c" next="0xa997a5ac" prev="0xa997a48c" upper="0xa999cae8" lower="(nil)">int size,n,m;<Finish/></txt><txt ptr="0xa997a5ac" next="0xa997a63c" prev="0xa997a51c" upper="0xa999cae8" lower="(nil)">bool flag;<Finish/></txt><txt ptr="0xa997a63c" next="0xa997a6cc" prev="0xa997a5ac" upper="0xa999cae8" lower="(nil)">//初始化<Finish/></txt><txt ptr="0xa997a6cc" next="0xa997a75c" prev="0xa997a63c" upper="0xa999cae8" lower="(nil)">void init() {<Finish/></txt><txt ptr="0xa997a75c" next="0xa997a7ec" prev="0xa997a6cc" upper="0xa999cae8" lower="(nil)">    memset(rowHead,-1,sizeof(rowHead));<Finish/></txt><txt ptr="0xa997a7ec" next="0xa997a87c" prev="0xa997a75c" upper="0xa999cae8" lower="(nil)">    for(int i=0; i&lt;=m; i++) {<Finish/></txt><txt ptr="0xa997a87c" next="0xa997a90c" prev="0xa997a7ec" upper="0xa999cae8" lower="(nil)">        colNum[i]=0;<Finish/></txt><txt ptr="0xa997a90c" next="0xa997a99c" prev="0xa997a87c" upper="0xa999cae8" lower="(nil)"><Finish/></txt><txt ptr="0xa997a99c" next="0xa997aa2c" prev="0xa997a90c" upper="0xa999cae8" lower="(nil)">        D[i]=U[i]=i;<Finish/></txt><txt ptr="0xa997aa2c" next="0xa997aabc" prev="0xa997a99c" upper="0xa999cae8" lower="(nil)">        L[i+1]=i;<Finish/></txt><txt ptr="0xa997aabc" next="0xa997ab4c" prev="0xa997aa2c" upper="0xa999cae8" lower="(nil)">        R[i]=i+1;<Finish/></txt><txt ptr="0xa997ab4c" next="0xa997abdc" prev="0xa997aabc" upper="0xa999cae8" lower="(nil)"><Finish/></txt><txt ptr="0xa997abdc" next="(nil)" prev="0xa997ab4c" upper="0xa999cae8" lower="(nil)">        row[i] = 0;<Finish/></txt></body></column></section></body><footer ptr="0xa8998480" next="(nil)" prev="0xa99c83c4" upper="0xa89935e4" lower="0xa99ad2dc"><txt ptr="0xa99ad2dc" next="0xa99ad48c" prev="(nil)" upper="0xa8998480" lower="(nil)"><anchored><fly ptr="0xb57a528" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99ad36c"><txt ptr="0xa99ad36c" next="0xa99ad3fc" prev="(nil)" upper="0xb57a528" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99ad3fc" next="(nil)" prev="0xa99ad36c" upper="0xb57a528" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="1"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="5"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99ad48c" next="(nil)" prev="0xa99ad2dc" upper="0xa8998480" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993658" next="0xa89936cc" prev="0xa89935e4" upper="0xb0726b0" lower="0xa89964e0"><header ptr="0xa89964e0" next="0xa99c8544" prev="(nil)" upper="0xa8993658" lower="0xa99b07f0"><txt ptr="0xa99b07f0" next="(nil)" prev="(nil)" upper="0xa89964e0" lower="(nil)"><Finish/></txt></header><body ptr="0xa99c8544" next="0xa89984e0" prev="0xa89964e0" upper="0xa8993658" lower="0xa998ce84"><section ptr="0xa998ce84" next="(nil)" prev="(nil)" upper="0xa99c8544" lower="0xa898b718" follow="0xa894b08c" precede="0xa894b30c"><column ptr="0xa898b718" next="0xa898b77c" prev="(nil)" upper="0xa998ce84" lower="0xa8989a34"><body ptr="0xa8989a34" next="(nil)" prev="(nil)" upper="0xa898b718" lower="0xa997ac6c"><txt ptr="0xa997ac6c" next="0xa997acfc" prev="(nil)" upper="0xa8989a34" lower="(nil)">        col[i] = i;<Finish/></txt><txt ptr="0xa997acfc" next="0xa997ad8c" prev="0xa997ac6c" upper="0xa8989a34" lower="(nil)">    }<Finish/></txt><txt ptr="0xa997ad8c" next="0xa997ae1c" prev="0xa997acfc" upper="0xa8989a34" lower="(nil)">    R[m]=0;<Finish/></txt><txt ptr="0xa997ae1c" next="0xa997aeac" prev="0xa997ad8c" upper="0xa8989a34" lower="(nil)">    size=m+1;<Finish/></txt><txt ptr="0xa997aeac" next="0xa997af3c" prev="0xa997ae1c" upper="0xa8989a34" lower="(nil)">}<Finish/></txt><txt ptr="0xa997af3c" next="0xa997b010" prev="0xa997aeac" upper="0xa8989a34" lower="(nil)">//插入一个点<Finish/></txt><txt ptr="0xa997b010" next="0xa997b0a0" prev="0xa997af3c" upper="0xa8989a34" lower="(nil)">void insert(int r,int c) {<Finish/></txt><txt ptr="0xa997b0a0" next="0xa997b400" prev="0xa997b010" upper="0xa8989a34" lower="(nil)">    colNum[c]++;<Finish/></txt><txt ptr="0xa997b400" next="0xa997b490" prev="0xa997b0a0" upper="0xa8989a34" lower="(nil)">    U[size]=U[c];<Finish/></txt><txt ptr="0xa997b490" next="0xa997b520" prev="0xa997b400" upper="0xa8989a34" lower="(nil)">    D[size]=c;<Finish/></txt><txt ptr="0xa997b520" next="0xa997b5b0" prev="0xa997b490" upper="0xa8989a34" lower="(nil)">    D[U[size]]=size;<Finish/></txt><txt ptr="0xa997b5b0" next="0xa997b640" prev="0xa997b520" upper="0xa8989a34" lower="(nil)">    U[D[size]]=size;<Finish/></txt><txt ptr="0xa997b640" next="0xa997b6d0" prev="0xa997b5b0" upper="0xa8989a34" lower="(nil)"><Finish/></txt><txt ptr="0xa997b6d0" next="0xa997b760" prev="0xa997b640" upper="0xa8989a34" lower="(nil)">    if(rowHead[r]==-1) {<Finish/></txt><txt ptr="0xa997b760" next="0xa997b7f0" prev="0xa997b6d0" upper="0xa8989a34" lower="(nil)">        rowHead[r]=L[size]=R[size]=size;<Finish/></txt><txt ptr="0xa997b7f0" next="0xa997b880" prev="0xa997b760" upper="0xa8989a34" lower="(nil)">    } else {<Finish/></txt><txt ptr="0xa997b880" next="0xa997b910" prev="0xa997b7f0" upper="0xa8989a34" lower="(nil)">        L[size]=L[rowHead[r]];<Finish/></txt><txt ptr="0xa997b910" next="0xa997b9a0" prev="0xa997b880" upper="0xa8989a34" lower="(nil)">        R[size]=rowHead[r];<Finish/></txt><txt ptr="0xa997b9a0" next="0xa997ba30" prev="0xa997b910" upper="0xa8989a34" lower="(nil)">        R[L[size]]=size;<Finish/></txt><txt ptr="0xa997ba30" next="0xa997bac0" prev="0xa997b9a0" upper="0xa8989a34" lower="(nil)">        L[R[size]]=size;<Finish/></txt><txt ptr="0xa997bac0" next="0xa997bb50" prev="0xa997ba30" upper="0xa8989a34" lower="(nil)">    }<Finish/></txt><txt ptr="0xa997bb50" next="0xa997bbe0" prev="0xa997bac0" upper="0xa8989a34" lower="(nil)">    row[size] = r;<Finish/></txt><txt ptr="0xa997bbe0" next="0xa997bc70" prev="0xa997bb50" upper="0xa8989a34" lower="(nil)">    col[size] = c;<Finish/></txt><txt ptr="0xa997bc70" next="0xa997bd00" prev="0xa997bbe0" upper="0xa8989a34" lower="(nil)">    size++;<Finish/></txt><txt ptr="0xa997bd00" next="0xa997bd90" prev="0xa997bc70" upper="0xa8989a34" lower="(nil)">}<Finish/></txt><txt ptr="0xa997bd90" next="0xa997be20" prev="0xa997bd00" upper="0xa8989a34" lower="(nil)">//删除一列<Finish/></txt><txt ptr="0xa997be20" next="0xa997beb0" prev="0xa997bd90" upper="0xa8989a34" lower="(nil)">void remove(int const&amp; c) { //删除列<Finish/></txt><txt ptr="0xa997beb0" next="(nil)" prev="0xa997be20" upper="0xa8989a34" lower="(nil)">    int i,j;<Finish/></txt></body></column><column ptr="0xa898b77c" next="0xa898b7e0" prev="0xa898b718" upper="0xa998ce84" lower="0xa8989a94"><body ptr="0xa8989a94" next="(nil)" prev="(nil)" upper="0xa898b77c" lower="0xa997bf40"><txt ptr="0xa997bf40" next="0xa997c014" prev="(nil)" upper="0xa8989a94" lower="(nil)">    L[R[c]]=L[c];<Finish/></txt><txt ptr="0xa997c014" next="0xa997c0a4" prev="0xa997bf40" upper="0xa8989a94" lower="(nil)">    R[L[c]]=R[c];<Finish/></txt><txt ptr="0xa997c0a4" next="0xa997c134" prev="0xa997c014" upper="0xa8989a94" lower="(nil)">    for(i=D[c]; i!=c; i=D[i]) {<Finish/></txt><txt ptr="0xa997c134" next="0xa997c1c4" prev="0xa997c0a4" upper="0xa8989a94" lower="(nil)">        for(j=R[i]; j!=i; j=R[j]) {<Finish/></txt><txt ptr="0xa997c1c4" next="0xa997c254" prev="0xa997c134" upper="0xa8989a94" lower="(nil)">            U[D[j]]=U[j],D[U[j]]=D[j];<Finish/></txt><txt ptr="0xa997c254" next="0xa997c2e4" prev="0xa997c1c4" upper="0xa8989a94" lower="(nil)">            colNum[col[j]]--;<Finish/></txt><txt ptr="0xa997c2e4" next="0xa997c374" prev="0xa997c254" upper="0xa8989a94" lower="(nil)">        }<Finish/></txt><txt ptr="0xa997c374" next="0xa997c404" prev="0xa997c2e4" upper="0xa8989a94" lower="(nil)">    }<Finish/></txt><txt ptr="0xa997c404" next="0xa997c494" prev="0xa997c374" upper="0xa8989a94" lower="(nil)">}<Finish/></txt><txt ptr="0xa997c494" next="0xa997c524" prev="0xa997c404" upper="0xa8989a94" lower="(nil)">//恢复一列<Finish/></txt><txt ptr="0xa997c524" next="0xa997c5b4" prev="0xa997c494" upper="0xa8989a94" lower="(nil)">void resume(int c) {<Finish/></txt><txt ptr="0xa997c5b4" next="0xa997c644" prev="0xa997c524" upper="0xa8989a94" lower="(nil)">    int i,j;<Finish/></txt><txt ptr="0xa997c644" next="0xa997c9a4" prev="0xa997c5b4" upper="0xa8989a94" lower="(nil)">    for(i=U[c]; i!=c; i=U[i]) {<Finish/></txt><txt ptr="0xa997c9a4" next="0xa997ca34" prev="0xa997c644" upper="0xa8989a94" lower="(nil)">        for(j=L[i]; j!=i; j=L[j]) {<Finish/></txt><txt ptr="0xa997ca34" next="0xa997cac4" prev="0xa997c9a4" upper="0xa8989a94" lower="(nil)">            U[D[j]]=j;<Finish/></txt><txt ptr="0xa997cac4" next="0xa997cb54" prev="0xa997ca34" upper="0xa8989a94" lower="(nil)">            D[U[j]]=j;<Finish/></txt><txt ptr="0xa997cb54" next="0xa997cbe4" prev="0xa997cac4" upper="0xa8989a94" lower="(nil)">            colNum[col[j]]++;<Finish/></txt><txt ptr="0xa997cbe4" next="0xa997cc74" prev="0xa997cb54" upper="0xa8989a94" lower="(nil)">        }<Finish/></txt><txt ptr="0xa997cc74" next="0xa997cd04" prev="0xa997cbe4" upper="0xa8989a94" lower="(nil)">    }<Finish/></txt><txt ptr="0xa997cd04" next="0xa997cd94" prev="0xa997cc74" upper="0xa8989a94" lower="(nil)">    L[R[c]]=c;<Finish/></txt><txt ptr="0xa997cd94" next="0xa997ce24" prev="0xa997cd04" upper="0xa8989a94" lower="(nil)">    R[L[c]]=c;<Finish/></txt><txt ptr="0xa997ce24" next="0xa997ceb4" prev="0xa997cd94" upper="0xa8989a94" lower="(nil)">}<Finish/></txt><txt ptr="0xa997ceb4" next="0xa997cf44" prev="0xa997ce24" upper="0xa8989a94" lower="(nil)">//搜索<Finish/></txt><txt ptr="0xa997cf44" next="0xa997f018" prev="0xa997ceb4" upper="0xa8989a94" lower="(nil)">void dfs(int k){<Finish/></txt><txt ptr="0xa997f018" next="0xa997f0a8" prev="0xa997cf44" upper="0xa8989a94" lower="(nil)">    int i,j,Min,c;<Finish/></txt><txt ptr="0xa997f0a8" next="0xa997f138" prev="0xa997f018" upper="0xa8989a94" lower="(nil)">    if(R[0] == 0) {<Finish/></txt><txt ptr="0xa997f138" next="0xa997f1c8" prev="0xa997f0a8" upper="0xa8989a94" lower="(nil)">        flag = true;//标记有解<Finish/></txt><txt ptr="0xa997f1c8" next="(nil)" prev="0xa997f138" upper="0xa8989a94" lower="(nil)">        printf(&quot;%d&quot;,k);//输出有k行<Finish/></txt></body></column><column ptr="0xa898b7e0" next="(nil)" prev="0xa898b77c" upper="0xa998ce84" lower="0xa8989af4"><body ptr="0xa8989af4" next="(nil)" prev="(nil)" upper="0xa898b7e0" lower="0xa997f258"><txt ptr="0xa997f258" next="0xa997f2e8" prev="(nil)" upper="0xa8989af4" lower="(nil)">        for(i=0; i&lt;k; i++){<Finish/></txt><txt ptr="0xa997f2e8" next="0xa997f378" prev="0xa997f258" upper="0xa8989af4" lower="(nil)">            printf(&quot; %d&quot;,selectRow[i]);<Finish/></txt><txt ptr="0xa997f378" next="0xa997f408" prev="0xa997f2e8" upper="0xa8989af4" lower="(nil)">        }<Finish/></txt><txt ptr="0xa997f408" next="0xa997f498" prev="0xa997f378" upper="0xa8989af4" lower="(nil)">        printf(&quot;\n&quot;);<Finish/></txt><txt ptr="0xa997f498" next="0xa997f528" prev="0xa997f408" upper="0xa8989af4" lower="(nil)">        return;<Finish/></txt><txt ptr="0xa997f528" next="0xa997f5b8" prev="0xa997f498" upper="0xa8989af4" lower="(nil)">    }<Finish/></txt><txt ptr="0xa997f5b8" next="0xa997f648" prev="0xa997f528" upper="0xa8989af4" lower="(nil)"><Finish/></txt><txt ptr="0xa997f648" next="0xa997f6d8" prev="0xa997f5b8" upper="0xa8989af4" lower="(nil)">    //select a col that has min 1<Finish/></txt><txt ptr="0xa997f6d8" next="0xa997f768" prev="0xa997f648" upper="0xa8989af4" lower="(nil)">    for(Min=N,i=R[0]; i; i=R[i]){<Finish/></txt><txt ptr="0xa997f768" next="0xa997f7f8" prev="0xa997f6d8" upper="0xa8989af4" lower="(nil)">        if(colNum[i]&lt;Min){<Finish/></txt><txt ptr="0xa997f7f8" next="0xa997f888" prev="0xa997f768" upper="0xa8989af4" lower="(nil)">            Min=colNum[i],c=i;<Finish/></txt><txt ptr="0xa997f888" next="0xa997f918" prev="0xa997f7f8" upper="0xa8989af4" lower="(nil)">        }<Finish/></txt><txt ptr="0xa997f918" next="0xa997f9a8" prev="0xa997f888" upper="0xa8989af4" lower="(nil)">    }<Finish/></txt><txt ptr="0xa997f9a8" next="0xa997fa38" prev="0xa997f918" upper="0xa8989af4" lower="(nil)">    remove(c);//删除该列<Finish/></txt><txt ptr="0xa997fa38" next="0xa997fac8" prev="0xa997f9a8" upper="0xa8989af4" lower="(nil)"><Finish/></txt><txt ptr="0xa997fac8" next="0xa997fb58" prev="0xa997fa38" upper="0xa8989af4" lower="(nil)">    //select a row in the delete col<Finish/></txt><txt ptr="0xa997fb58" next="0xa997fbe8" prev="0xa997fac8" upper="0xa8989af4" lower="(nil)">    for(i=D[c]; i!=c; i=D[i]) {<Finish/></txt><txt ptr="0xa997fbe8" next="0xa997ff48" prev="0xa997fb58" upper="0xa8989af4" lower="(nil)">        selectRow[k] = row[i];<Finish/></txt><txt ptr="0xa997ff48" next="0xa998001c" prev="0xa997fbe8" upper="0xa8989af4" lower="(nil)">        for(j=R[i]; j!=i; j=R[j]){<Finish/></txt><txt ptr="0xa998001c" next="0xa99800ac" prev="0xa997ff48" upper="0xa8989af4" lower="(nil)">            remove(col[j]);<Finish/></txt><txt ptr="0xa99800ac" next="0xa998013c" prev="0xa998001c" upper="0xa8989af4" lower="(nil)">        }<Finish/></txt><txt ptr="0xa998013c" next="0xa99801cc" prev="0xa99800ac" upper="0xa8989af4" lower="(nil)">        dfs(k+1);<Finish/></txt><txt ptr="0xa99801cc" next="0xa998025c" prev="0xa998013c" upper="0xa8989af4" lower="(nil)">        if(flag) return;//只要一组解<Finish/></txt><txt ptr="0xa998025c" next="0xa99802ec" prev="0xa99801cc" upper="0xa8989af4" lower="(nil)">        for(j=L[i]; j!=i; j=L[j]){<Finish/></txt><txt ptr="0xa99802ec" next="0xa998037c" prev="0xa998025c" upper="0xa8989af4" lower="(nil)">            resume(col[j]);<Finish/></txt><txt ptr="0xa998037c" next="0xa998040c" prev="0xa99802ec" upper="0xa8989af4" lower="(nil)">        }<Finish/></txt><txt ptr="0xa998040c" next="0xa998049c" prev="0xa998037c" upper="0xa8989af4" lower="(nil)">    }<Finish/></txt><txt ptr="0xa998049c" next="(nil)" prev="0xa998040c" upper="0xa8989af4" lower="(nil)">    resume(c);<Finish/></txt></body></column></section></body><footer ptr="0xa89984e0" next="(nil)" prev="0xa99c8544" upper="0xa8993658" lower="0xa99b0880"><txt ptr="0xa99b0880" next="0xa99b0a30" prev="(nil)" upper="0xa89984e0" lower="(nil)"><anchored><fly ptr="0xb6abba8" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99b0910"><txt ptr="0xa99b0910" next="0xa99b09a0" prev="(nil)" upper="0xb6abba8" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99b09a0" next="(nil)" prev="0xa99b0910" upper="0xb6abba8" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="1"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="6"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99b0a30" next="(nil)" prev="0xa99b0880" upper="0xa89984e0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa89936cc" next="0xa8993740" prev="0xa8993658" upper="0xb0726b0" lower="0xa8996540"><header ptr="0xa8996540" next="0xa99c86c4" prev="(nil)" upper="0xa89936cc" lower="0xa99b1d94"><txt ptr="0xa99b1d94" next="(nil)" prev="(nil)" upper="0xa8996540" lower="(nil)"><Finish/></txt></header><body ptr="0xa99c86c4" next="0xa8998540" prev="0xa8996540" upper="0xa89936cc" lower="0xa894b08c"><section ptr="0xa894b08c" next="(nil)" prev="(nil)" upper="0xa99c86c4" lower="0xa6bff540" follow="0xa8978d88" precede="0xa998ce84"><column ptr="0xa6bff540" next="0xa6bff5a4" prev="(nil)" upper="0xa894b08c" lower="0xa998e00c"><body ptr="0xa998e00c" next="(nil)" prev="(nil)" upper="0xa6bff540" lower="0xa998052c"><txt ptr="0xa998052c" next="0xa99805bc" prev="(nil)" upper="0xa998e00c" lower="(nil)"><Finish/></txt><txt ptr="0xa99805bc" next="0xa998064c" prev="0xa998052c" upper="0xa998e00c" lower="(nil)">}<Finish/></txt><txt ptr="0xa998064c" next="0xa99806dc" prev="0xa99805bc" upper="0xa998e00c" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa99806dc" next="0xa998076c" prev="0xa998064c" upper="0xa998e00c" lower="(nil)">    int i,j,num;<Finish/></txt><txt ptr="0xa998076c" next="0xa99807fc" prev="0xa99806dc" upper="0xa998e00c" lower="(nil)">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) {<Finish/></txt><txt ptr="0xa99807fc" next="0xa998088c" prev="0xa998076c" upper="0xa998e00c" lower="(nil)">        init();<Finish/></txt><txt ptr="0xa998088c" next="0xa998091c" prev="0xa99807fc" upper="0xa998e00c" lower="(nil)">        for(i=1; i&lt;=n; i++) {<Finish/></txt><txt ptr="0xa998091c" next="0xa99809ac" prev="0xa998088c" upper="0xa998e00c" lower="(nil)">            scanf(&quot;%d&quot;,&amp;num);<Finish/></txt><txt ptr="0xa99809ac" next="0xa9980a3c" prev="0xa998091c" upper="0xa998e00c" lower="(nil)">            while(num--) {<Finish/></txt><txt ptr="0xa9980a3c" next="0xa9980acc" prev="0xa99809ac" upper="0xa998e00c" lower="(nil)">                scanf(&quot;%d&quot;,&amp;j);<Finish/></txt><txt ptr="0xa9980acc" next="0xa9980b5c" prev="0xa9980a3c" upper="0xa998e00c" lower="(nil)">                insert(i,j);//向第i行第j列插入1<Finish/></txt><txt ptr="0xa9980b5c" next="0xa9980bec" prev="0xa9980acc" upper="0xa998e00c" lower="(nil)">            }<Finish/></txt><txt ptr="0xa9980bec" next="0xa9980c7c" prev="0xa9980b5c" upper="0xa998e00c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9980c7c" next="0xa9980d0c" prev="0xa9980bec" upper="0xa998e00c" lower="(nil)">        flag = false;<Finish/></txt><txt ptr="0xa9980d0c" next="0xa9980d9c" prev="0xa9980c7c" upper="0xa998e00c" lower="(nil)">        dfs(0);<Finish/></txt><txt ptr="0xa9980d9c" next="0xa9980e2c" prev="0xa9980d0c" upper="0xa998e00c" lower="(nil)">        if(!flag){<Finish/></txt><txt ptr="0xa9980e2c" next="0xa9980ebc" prev="0xa9980d9c" upper="0xa998e00c" lower="(nil)">            printf(&quot;NO\n&quot;);<Finish/></txt><txt ptr="0xa9980ebc" next="0xa9980f4c" prev="0xa9980e2c" upper="0xa998e00c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9980f4c" next="0xa9981020" prev="0xa9980ebc" upper="0xa998e00c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa9981020" next="0xa99810b0" prev="0xa9980f4c" upper="0xa998e00c" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa99810b0" next="0xa9981140" prev="0xa9981020" upper="0xa998e00c" lower="(nil)">}<Finish/></txt><txt ptr="0xa9981140" next="0xa99811d0" prev="0xa99810b0" upper="0xa998e00c" lower="(nil)">AC自动机<Finish/></txt><txt ptr="0xa99811d0" next="0xa9981530" prev="0xa9981140" upper="0xa998e00c" lower="(nil)">常用与解决多模式匹配问题。<Finish/></txt><txt ptr="0xa9981530" next="0xa99815c0" prev="0xa99811d0" upper="0xa998e00c" lower="(nil)">例如：给出n个单词，再给出一段包含m个字符的文章，让你找出有多少个单词在文章里出现过。<Finish/></txt><txt ptr="0xa99815c0" next="0xa9981650" prev="0xa9981530" upper="0xa998e00c" lower="(nil)"><Finish/></txt><txt ptr="0xa9981650" next="(nil)" prev="0xa99815c0" upper="0xa998e00c" lower="(nil)">一般由字典树和KMP结合而成。<Finish/></txt></body></column><column ptr="0xa6bff5a4" next="0xa6bff608" prev="0xa6bff540" upper="0xa894b08c" lower="0xa998e06c"><body ptr="0xa998e06c" next="(nil)" prev="(nil)" upper="0xa6bff5a4" lower="0xa99816e0"><txt ptr="0xa99816e0" next="0xa9981770" prev="(nil)" upper="0xa998e06c" lower="(nil)">传统字典树<Finish/></txt><txt ptr="0xa9981770" next="0xa9981800" prev="0xa99816e0" upper="0xa998e06c" lower="(nil)">const int kind = 26;<Finish/></txt><txt ptr="0xa9981800" next="0xa9981890" prev="0xa9981770" upper="0xa998e06c" lower="(nil)">struct Tire {<Finish/></txt><txt ptr="0xa9981890" next="0xa9981920" prev="0xa9981800" upper="0xa998e06c" lower="(nil)">    int fail;       //失败指针<Finish/></txt><txt ptr="0xa9981920" next="0xa99819b0" prev="0xa9981890" upper="0xa998e06c" lower="(nil)">int next[kind]; <Finish/></txt><txt ptr="0xa99819b0" next="0xa9981a40" prev="0xa9981920" upper="0xa998e06c" lower="(nil)">//Tire每个节点的个子节点（最多个字母）<Finish/></txt><txt ptr="0xa9981a40" next="0xa9981ad0" prev="0xa99819b0" upper="0xa998e06c" lower="(nil)">    int count;   //是否为该单词的最后一个节点<Finish/></txt><txt ptr="0xa9981ad0" next="0xa9981b60" prev="0xa9981a40" upper="0xa998e06c" lower="(nil)">    void init() {          //构造函数初始化<Finish/></txt><txt ptr="0xa9981b60" next="0xa9981bf0" prev="0xa9981ad0" upper="0xa998e06c" lower="(nil)">        fail = 0;<Finish/></txt><txt ptr="0xa9981bf0" next="0xa9981c80" prev="0xa9981b60" upper="0xa998e06c" lower="(nil)">        count = 0;<Finish/></txt><txt ptr="0xa9981c80" next="0xa9981d10" prev="0xa9981bf0" upper="0xa998e06c" lower="(nil)">        memset(next,-1,sizeof(next));<Finish/></txt><txt ptr="0xa9981d10" next="0xa9981da0" prev="0xa9981c80" upper="0xa998e06c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa9981da0" next="0xa9981e30" prev="0xa9981d10" upper="0xa998e06c" lower="(nil)">} tire[5000001];  //队列，方便用于bfs构造失败指针<Finish/></txt><txt ptr="0xa9981e30" next="0xa9981ec0" prev="0xa9981da0" upper="0xa998e06c" lower="(nil)">int size = 0;<Finish/></txt><txt ptr="0xa9981ec0" next="0xa9981f50" prev="0xa9981e30" upper="0xa998e06c" lower="(nil)">queue&lt;int&gt;que;<Finish/></txt><txt ptr="0xa9981f50" next="0xa9982024" prev="0xa9981ec0" upper="0xa998e06c" lower="(nil)"><Finish/></txt><txt ptr="0xa9982024" next="0xa99820b4" prev="0xa9981f50" upper="0xa998e06c" lower="(nil)">void init() {<Finish/></txt><txt ptr="0xa99820b4" next="0xa9982144" prev="0xa9982024" upper="0xa998e06c" lower="(nil)">    tire[0].init();<Finish/></txt><txt ptr="0xa9982144" next="0xa99821d4" prev="0xa99820b4" upper="0xa998e06c" lower="(nil)">    size = 1;<Finish/></txt><txt ptr="0xa99821d4" next="0xa9982264" prev="0xa9982144" upper="0xa998e06c" lower="(nil)">    while(!que.empty())que.pop();<Finish/></txt><txt ptr="0xa9982264" next="0xa99822f4" prev="0xa99821d4" upper="0xa998e06c" lower="(nil)">}<Finish/></txt><txt ptr="0xa99822f4" next="0xa9982384" prev="0xa9982264" upper="0xa998e06c" lower="(nil)"><Finish/></txt><txt ptr="0xa9982384" next="0xa9982414" prev="0xa99822f4" upper="0xa998e06c" lower="(nil)">void insert(char *str) {<Finish/></txt><txt ptr="0xa9982414" next="0xa99824a4" prev="0xa9982384" upper="0xa998e06c" lower="(nil)">    int p = 0, i=0,index;<Finish/></txt><txt ptr="0xa99824a4" next="0xa9982534" prev="0xa9982414" upper="0xa998e06c" lower="(nil)">    while(str[i]) {<Finish/></txt><txt ptr="0xa9982534" next="0xa99825c4" prev="0xa99824a4" upper="0xa998e06c" lower="(nil)">        index=str[i]-'a';<Finish/></txt><txt ptr="0xa99825c4" next="0xa9982654" prev="0xa9982534" upper="0xa998e06c" lower="(nil)">        if(tire[p].next[index] == -1) {<Finish/></txt><txt ptr="0xa9982654" next="(nil)" prev="0xa99825c4" upper="0xa998e06c" lower="(nil)">            tire[size].init();<Finish/></txt></body></column><column ptr="0xa6bff608" next="(nil)" prev="0xa6bff5a4" upper="0xa894b08c" lower="0xa998e2ac"><body ptr="0xa998e2ac" next="(nil)" prev="(nil)" upper="0xa6bff608" lower="0xa99826e4"><txt ptr="0xa99826e4" next="0xa9982774" prev="(nil)" upper="0xa998e2ac" lower="(nil)">            tire[p].next[index]= size++;<Finish/></txt><txt ptr="0xa9982774" next="0xa9982ad4" prev="0xa99826e4" upper="0xa998e2ac" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9982ad4" next="0xa9982b64" prev="0xa9982774" upper="0xa998e2ac" lower="(nil)">        p = tire[p].next[index];<Finish/></txt><txt ptr="0xa9982b64" next="0xa9982bf4" prev="0xa9982ad4" upper="0xa998e2ac" lower="(nil)">        i++;<Finish/></txt><txt ptr="0xa9982bf4" next="0xa9982c84" prev="0xa9982b64" upper="0xa998e2ac" lower="(nil)">    }<Finish/></txt><txt ptr="0xa9982c84" next="0xa9982d14" prev="0xa9982bf4" upper="0xa998e2ac" lower="(nil)">    tire[p].count++;     //在单词的最后一个节点count+1，代表一个单词<Finish/></txt><txt ptr="0xa9982d14" next="0xa9982da4" prev="0xa9982c84" upper="0xa998e2ac" lower="(nil)">}<Finish/></txt><txt ptr="0xa9982da4" next="0xa9982e34" prev="0xa9982d14" upper="0xa998e2ac" lower="(nil)"><Finish/></txt><txt ptr="0xa9982e34" next="0xa9982ec4" prev="0xa9982da4" upper="0xa998e2ac" lower="(nil)">void build_ac_automation() {<Finish/></txt><txt ptr="0xa9982ec4" next="0xa9982f54" prev="0xa9982e34" upper="0xa998e2ac" lower="(nil)">    int i,pre,pre_fail,child;<Finish/></txt><txt ptr="0xa9982f54" next="0xa9984028" prev="0xa9982ec4" upper="0xa998e2ac" lower="(nil)"><Finish/></txt><txt ptr="0xa9984028" next="0xa99840b8" prev="0xa9982f54" upper="0xa998e2ac" lower="(nil)">    tire[0].fail = -1;<Finish/></txt><txt ptr="0xa99840b8" next="0xa9984148" prev="0xa9984028" upper="0xa998e2ac" lower="(nil)">    que.push(0);<Finish/></txt><txt ptr="0xa9984148" next="0xa99841d8" prev="0xa99840b8" upper="0xa998e2ac" lower="(nil)"><Finish/></txt><txt ptr="0xa99841d8" next="0xa9984268" prev="0xa9984148" upper="0xa998e2ac" lower="(nil)">    while(!que.empty()) {<Finish/></txt><txt ptr="0xa9984268" next="0xa99842f8" prev="0xa99841d8" upper="0xa998e2ac" lower="(nil)">        pre = que.front();<Finish/></txt><txt ptr="0xa99842f8" next="0xa9984388" prev="0xa9984268" upper="0xa998e2ac" lower="(nil)">        que.pop();<Finish/></txt><txt ptr="0xa9984388" next="0xa9984418" prev="0xa99842f8" upper="0xa998e2ac" lower="(nil)"><Finish/></txt><txt ptr="0xa9984418" next="0xa99844a8" prev="0xa9984388" upper="0xa998e2ac" lower="(nil)">        for(i=0; i&lt;kind; i++) {<Finish/></txt><txt ptr="0xa99844a8" next="0xa9984538" prev="0xa9984418" upper="0xa998e2ac" lower="(nil)">            if(tire[pre].next[i] != -1) {<Finish/></txt><txt ptr="0xa9984538" next="0xa99845c8" prev="0xa99844a8" upper="0xa998e2ac" lower="(nil)">                child = tire[pre].next[i] ;<Finish/></txt><txt ptr="0xa99845c8" next="0xa9984658" prev="0xa9984538" upper="0xa998e2ac" lower="(nil)">                pre_fail = tire[pre].fail;<Finish/></txt><txt ptr="0xa9984658" next="0xa99846e8" prev="0xa99845c8" upper="0xa998e2ac" lower="(nil)">                while(pre_fail != -1) {<Finish/></txt><txt ptr="0xa99846e8" next="0xa9984778" prev="0xa9984658" upper="0xa998e2ac" lower="(nil)">                    if(tire[pre_fail].next[i] != -1) {<Finish/></txt><txt ptr="0xa9984778" next="0xa9984808" prev="0xa99846e8" upper="0xa998e2ac" lower="(nil)">          tire[ child ].fail = tire[pre_fail].next[i];<Finish/></txt><txt ptr="0xa9984808" next="0xa9984898" prev="0xa9984778" upper="0xa998e2ac" lower="(nil)">                        break;<Finish/></txt><txt ptr="0xa9984898" next="(nil)" prev="0xa9984808" upper="0xa998e2ac" lower="(nil)">                    }<Finish/></txt></body></column></section></body><footer ptr="0xa8998540" next="(nil)" prev="0xa99c86c4" upper="0xa89936cc" lower="0xa99b1e24"><txt ptr="0xa99b1e24" next="0xa99b2018" prev="(nil)" upper="0xa8998540" lower="(nil)"><anchored><fly ptr="0xb596358" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99b1eb4"><txt ptr="0xa99b1eb4" next="0xa99b1f44" prev="(nil)" upper="0xb596358" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99b1f44" next="(nil)" prev="0xa99b1eb4" upper="0xb596358" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="1"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="7"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99b2018" next="(nil)" prev="0xa99b1e24" upper="0xa8998540" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993740" next="0xa89937b4" prev="0xa89936cc" upper="0xb0726b0" lower="0xa89965a0"><header ptr="0xa89965a0" next="0xa99c8844" prev="(nil)" upper="0xa8993740" lower="0xa99b337c"><txt ptr="0xa99b337c" next="(nil)" prev="(nil)" upper="0xa89965a0" lower="(nil)"><Finish/></txt></header><body ptr="0xa99c8844" next="0xa89985a0" prev="0xa89965a0" upper="0xa8993740" lower="0xa8978d88"><section ptr="0xa8978d88" next="(nil)" prev="(nil)" upper="0xa99c8844" lower="0xa6bff798" follow="0xa8978c08" precede="0xa894b08c"><column ptr="0xa6bff798" next="0xa6bff7fc" prev="(nil)" upper="0xa8978d88" lower="0xa998e60c"><body ptr="0xa998e60c" next="(nil)" prev="(nil)" upper="0xa6bff798" lower="0xa9984928"><txt ptr="0xa9984928" next="0xa99849b8" prev="(nil)" upper="0xa998e60c" lower="(nil)">                    pre_fail = tire[pre_fail].fail;<Finish/></txt><txt ptr="0xa99849b8" next="0xa9984a48" prev="0xa9984928" upper="0xa998e60c" lower="(nil)">                }<Finish/></txt><txt ptr="0xa9984a48" next="0xa9984ad8" prev="0xa99849b8" upper="0xa998e60c" lower="(nil)">                if(pre_fail == -1) {<Finish/></txt><txt ptr="0xa9984ad8" next="0xa9984b68" prev="0xa9984a48" upper="0xa998e60c" lower="(nil)">                    tire[ child ].fail = 0;<Finish/></txt><txt ptr="0xa9984b68" next="0xa9984bf8" prev="0xa9984ad8" upper="0xa998e60c" lower="(nil)">                }<Finish/></txt><txt ptr="0xa9984bf8" next="0xa9984c88" prev="0xa9984b68" upper="0xa998e60c" lower="(nil)">                que.push(child);<Finish/></txt><txt ptr="0xa9984c88" next="0xa9984d18" prev="0xa9984bf8" upper="0xa998e60c" lower="(nil)">            }<Finish/></txt><txt ptr="0xa9984d18" next="0xa9987090" prev="0xa9984c88" upper="0xa998e60c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9987090" next="0xa9987120" prev="0xa9984d18" upper="0xa998e60c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa9987120" next="0xa99871b0" prev="0xa9987090" upper="0xa998e60c" lower="(nil)">}<Finish/></txt><txt ptr="0xa99871b0" next="0xa9987240" prev="0xa9987120" upper="0xa998e60c" lower="(nil)">int query(char* str) {<Finish/></txt><txt ptr="0xa9987240" next="0xa99872d0" prev="0xa99871b0" upper="0xa998e60c" lower="(nil)">    int i=0,cnt=0,index,tmp;<Finish/></txt><txt ptr="0xa99872d0" next="0xa9987360" prev="0xa9987240" upper="0xa998e60c" lower="(nil)">    int p = 0;<Finish/></txt><txt ptr="0xa9987360" next="0xa99873f0" prev="0xa99872d0" upper="0xa998e60c" lower="(nil)">    while(str[i]) {<Finish/></txt><txt ptr="0xa99873f0" next="0xa9987480" prev="0xa9987360" upper="0xa998e60c" lower="(nil)">        index=str[i]-'a';<Finish/></txt><txt ptr="0xa9987480" next="0xa9987510" prev="0xa99873f0" upper="0xa998e60c" lower="(nil)">while(tire[p].next[index] == -1 &amp;&amp; p != 0) p=tire[p].fail;<Finish/></txt><txt ptr="0xa9987510" next="0xa99875a0" prev="0xa9987480" upper="0xa998e60c" lower="(nil)">        p = tire[p].next[index];<Finish/></txt><txt ptr="0xa99875a0" next="0xa9987630" prev="0xa9987510" upper="0xa998e60c" lower="(nil)">        tmp = p = (p==-1 ? 0:p);<Finish/></txt><txt ptr="0xa9987630" next="0xa99876c0" prev="0xa99875a0" upper="0xa998e60c" lower="(nil)">        while(tmp != 0 &amp;&amp; tire[tmp].count != -1) {<Finish/></txt><txt ptr="0xa99876c0" next="0xa9987750" prev="0xa9987630" upper="0xa998e60c" lower="(nil)">            cnt += tire[tmp].count;<Finish/></txt><txt ptr="0xa9987750" next="0xa99877e0" prev="0xa99876c0" upper="0xa998e60c" lower="(nil)">            tire[tmp].count = -1;<Finish/></txt><txt ptr="0xa99877e0" next="0xa9987870" prev="0xa9987750" upper="0xa998e60c" lower="(nil)">            tmp = tire[tmp].fail;<Finish/></txt><txt ptr="0xa9987870" next="0xa9987900" prev="0xa99877e0" upper="0xa998e60c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9987900" next="0xa9987990" prev="0xa9987870" upper="0xa998e60c" lower="(nil)">        i++;<Finish/></txt><txt ptr="0xa9987990" next="0xa9987a20" prev="0xa9987900" upper="0xa998e60c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa9987a20" next="0xa9987ab0" prev="0xa9987990" upper="0xa998e60c" lower="(nil)">    return cnt;<Finish/></txt><txt ptr="0xa9987ab0" next="0xa9987b40" prev="0xa9987a20" upper="0xa998e60c" lower="(nil)">}<Finish/></txt><txt ptr="0xa9987b40" next="(nil)" prev="0xa9987ab0" upper="0xa998e60c" lower="(nil)">int main() {<Finish/></txt></body></column><column ptr="0xa6bff7fc" next="0xa6bff860" prev="0xa6bff798" upper="0xa8978d88" lower="0xa998e66c"><body ptr="0xa998e66c" next="(nil)" prev="(nil)" upper="0xa6bff7fc" lower="0xa9987bd0"><txt ptr="0xa9987bd0" next="0xa9987c60" prev="(nil)" upper="0xa998e66c" lower="(nil)">    char keyword[51];     //输入的单词<Finish/></txt><txt ptr="0xa9987c60" next="0xa9987cf0" prev="0xa9987bd0" upper="0xa998e66c" lower="(nil)">    char str[1000005];    //模式串<Finish/></txt><txt ptr="0xa9987cf0" next="0xa9987d80" prev="0xa9987c60" upper="0xa998e66c" lower="(nil)">    int n;<Finish/></txt><txt ptr="0xa9987d80" next="0xa9987e10" prev="0xa9987cf0" upper="0xa998e66c" lower="(nil)">    scanf(&quot;%d&quot;,&amp;n);<Finish/></txt><txt ptr="0xa9987e10" next="0xa9987ea0" prev="0xa9987d80" upper="0xa998e66c" lower="(nil)">    init();<Finish/></txt><txt ptr="0xa9987ea0" next="0xa9987f30" prev="0xa9987e10" upper="0xa998e66c" lower="(nil)">    while(n--) {<Finish/></txt><txt ptr="0xa9987f30" next="0xa9988004" prev="0xa9987ea0" upper="0xa998e66c" lower="(nil)">        scanf(&quot;%s&quot;,keyword);<Finish/></txt><txt ptr="0xa9988004" next="0xa9988094" prev="0xa9987f30" upper="0xa998e66c" lower="(nil)">        insert(keyword);<Finish/></txt><txt ptr="0xa9988094" next="0xa9988124" prev="0xa9988004" upper="0xa998e66c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa9988124" next="0xa99881b4" prev="0xa9988094" upper="0xa998e66c" lower="(nil)">    build_ac_automation();<Finish/></txt><txt ptr="0xa99881b4" next="0xa9988244" prev="0xa9988124" upper="0xa998e66c" lower="(nil)">    scanf(&quot;%s&quot;,str);<Finish/></txt><txt ptr="0xa9988244" next="0xa99882d4" prev="0xa99881b4" upper="0xa998e66c" lower="(nil)">    printf(&quot;%d\n&quot;,query(str));<Finish/></txt><txt ptr="0xa99882d4" next="0xa9988634" prev="0xa9988244" upper="0xa998e66c" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa9988634" next="0xa99886c4" prev="0xa99882d4" upper="0xa998e66c" lower="(nil)">}<Finish/></txt><txt ptr="0xa99886c4" next="0xa9988754" prev="0xa9988634" upper="0xa998e66c" lower="(nil)">数组式字典树<Finish/></txt><txt ptr="0xa9988754" next="0xa99887e4" prev="0xa99886c4" upper="0xa998e66c" lower="(nil)">const int kind = 26,N=1000001;<Finish/></txt><txt ptr="0xa99887e4" next="0xa9988874" prev="0xa9988754" upper="0xa998e66c" lower="(nil)"><Finish/></txt><txt ptr="0xa9988874" next="0xa9988904" prev="0xa99887e4" upper="0xa998e66c" lower="(nil)">int tire[N][kind],fail[N],word[N];<Finish/></txt><txt ptr="0xa9988904" next="0xa9988994" prev="0xa9988874" upper="0xa998e66c" lower="(nil)">int size = 0;<Finish/></txt><txt ptr="0xa9988994" next="0xa9988a24" prev="0xa9988904" upper="0xa998e66c" lower="(nil)">queue&lt;int&gt;que;<Finish/></txt><txt ptr="0xa9988a24" next="0xa9988ab4" prev="0xa9988994" upper="0xa998e66c" lower="(nil)"><Finish/></txt><txt ptr="0xa9988ab4" next="0xa9988b44" prev="0xa9988a24" upper="0xa998e66c" lower="(nil)">void init() {<Finish/></txt><txt ptr="0xa9988b44" next="0xa9988bd4" prev="0xa9988ab4" upper="0xa998e66c" lower="(nil)">    memset(word,0,sizeof(word));<Finish/></txt><txt ptr="0xa9988bd4" next="0xa9988c64" prev="0xa9988b44" upper="0xa998e66c" lower="(nil)">    memset(tire[0],0,sizeof(tire[0]));<Finish/></txt><txt ptr="0xa9988c64" next="0xa9988cf4" prev="0xa9988bd4" upper="0xa998e66c" lower="(nil)">    while(!que.empty())que.pop();<Finish/></txt><txt ptr="0xa9988cf4" next="0xa9988d84" prev="0xa9988c64" upper="0xa998e66c" lower="(nil)">    fail[0] = 0;<Finish/></txt><txt ptr="0xa9988d84" next="0xa9988e14" prev="0xa9988cf4" upper="0xa998e66c" lower="(nil)">    size=1;<Finish/></txt><txt ptr="0xa9988e14" next="(nil)" prev="0xa9988d84" upper="0xa998e66c" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa6bff860" next="(nil)" prev="0xa6bff7fc" upper="0xa8978d88" lower="0xa998e72c"><body ptr="0xa998e72c" next="(nil)" prev="(nil)" upper="0xa6bff860" lower="0xa9988ea4"><txt ptr="0xa9988ea4" next="0xa9988f34" prev="(nil)" upper="0xa998e72c" lower="(nil)"><Finish/></txt><txt ptr="0xa9988f34" next="0xa9989008" prev="0xa9988ea4" upper="0xa998e72c" lower="(nil)">void insert(char *str, int val) {<Finish/></txt><txt ptr="0xa9989008" next="0xa9989098" prev="0xa9988f34" upper="0xa998e72c" lower="(nil)">    int p = 0, i;<Finish/></txt><txt ptr="0xa9989098" next="0xa9989128" prev="0xa9989008" upper="0xa998e72c" lower="(nil)">    for(; *str; str++) {<Finish/></txt><txt ptr="0xa9989128" next="0xa99891b8" prev="0xa9989098" upper="0xa998e72c" lower="(nil)">        i = *str - 'a';<Finish/></txt><txt ptr="0xa99891b8" next="0xa9989248" prev="0xa9989128" upper="0xa998e72c" lower="(nil)">        if(!tire[p][i]) {<Finish/></txt><txt ptr="0xa9989248" next="0xa99892d8" prev="0xa99891b8" upper="0xa998e72c" lower="(nil)">            memset(tire[size],0,sizeof(tire[size]));<Finish/></txt><txt ptr="0xa99892d8" next="0xa9989368" prev="0xa9989248" upper="0xa998e72c" lower="(nil)">            word[size]=0;<Finish/></txt><txt ptr="0xa9989368" next="0xa99893f8" prev="0xa99892d8" upper="0xa998e72c" lower="(nil)">            tire[p][i]= size++;<Finish/></txt><txt ptr="0xa99893f8" next="0xa9989488" prev="0xa9989368" upper="0xa998e72c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9989488" next="0xa9989518" prev="0xa99893f8" upper="0xa998e72c" lower="(nil)">        p = tire[p][i];<Finish/></txt><txt ptr="0xa9989518" next="0xa99895a8" prev="0xa9989488" upper="0xa998e72c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa99895a8" next="0xa9989638" prev="0xa9989518" upper="0xa998e72c" lower="(nil)">    word[p] += val;<Finish/></txt><txt ptr="0xa9989638" next="0xa99896c8" prev="0xa99895a8" upper="0xa998e72c" lower="(nil)">}<Finish/></txt><txt ptr="0xa99896c8" next="0xa9989758" prev="0xa9989638" upper="0xa998e72c" lower="(nil)"><Finish/></txt><txt ptr="0xa9989758" next="0xa99897e8" prev="0xa99896c8" upper="0xa998e72c" lower="(nil)">void build_ac_automation() {<Finish/></txt><txt ptr="0xa99897e8" next="0xa9989878" prev="0xa9989758" upper="0xa998e72c" lower="(nil)">    int i,pre;<Finish/></txt><txt ptr="0xa9989878" next="0xa9989bd8" prev="0xa99897e8" upper="0xa998e72c" lower="(nil)"><Finish/></txt><txt ptr="0xa9989bd8" next="0xa9989c68" prev="0xa9989878" upper="0xa998e72c" lower="(nil)">    for(i=0; i&lt; kind; i++) {<Finish/></txt><txt ptr="0xa9989c68" next="0xa9989cf8" prev="0xa9989bd8" upper="0xa998e72c" lower="(nil)">        if(tire[0][i]) {<Finish/></txt><txt ptr="0xa9989cf8" next="0xa9989d88" prev="0xa9989c68" upper="0xa998e72c" lower="(nil)">            fail[tire[0][i]]=0;<Finish/></txt><txt ptr="0xa9989d88" next="0xa9989e18" prev="0xa9989cf8" upper="0xa998e72c" lower="(nil)">            que.push(tire[0][i]);<Finish/></txt><txt ptr="0xa9989e18" next="0xa9989ea8" prev="0xa9989d88" upper="0xa998e72c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa9989ea8" next="0xa9989f38" prev="0xa9989e18" upper="0xa998e72c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa9989f38" next="0xa897f00c" prev="0xa9989ea8" upper="0xa998e72c" lower="(nil)">    while(!que.empty()) {<Finish/></txt><txt ptr="0xa897f00c" next="0xa897f09c" prev="0xa9989f38" upper="0xa998e72c" lower="(nil)">        pre = que.front();<Finish/></txt><txt ptr="0xa897f09c" next="0xa897f12c" prev="0xa897f00c" upper="0xa998e72c" lower="(nil)">        que.pop();<Finish/></txt><txt ptr="0xa897f12c" next="(nil)" prev="0xa897f09c" upper="0xa998e72c" lower="(nil)">        for(i=0; i&lt;kind; i++) {<Finish/></txt></body></column></section></body><footer ptr="0xa89985a0" next="(nil)" prev="0xa99c8844" upper="0xa8993740" lower="0xa99b340c"><txt ptr="0xa99b340c" next="0xa99b35bc" prev="(nil)" upper="0xa89985a0" lower="(nil)"><anchored><fly ptr="0xad003c8" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99b349c"><txt ptr="0xa99b349c" next="0xa99b352c" prev="(nil)" upper="0xad003c8" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99b352c" next="(nil)" prev="0xa99b349c" upper="0xad003c8" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="1"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="8"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99b35bc" next="(nil)" prev="0xa99b340c" upper="0xa89985a0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa89937b4" next="0xa8993828" prev="0xa8993740" upper="0xb0726b0" lower="0xa8996600"><header ptr="0xa8996600" next="0xa99c89c4" prev="(nil)" upper="0xa89937b4" lower="0xa99b5920"><txt ptr="0xa99b5920" next="(nil)" prev="(nil)" upper="0xa8996600" lower="(nil)"><Finish/></txt></header><body ptr="0xa99c89c4" next="0xa8998600" prev="0xa8996600" upper="0xa89937b4" lower="0xa8978c08"><section ptr="0xa8978c08" next="(nil)" prev="(nil)" upper="0xa99c89c4" lower="0xa6bff9f0" follow="0xa8978488" precede="0xa8978d88"><column ptr="0xa6bff9f0" next="0xa6bffa54" prev="(nil)" upper="0xa8978c08" lower="0xa998ea8c"><body ptr="0xa998ea8c" next="(nil)" prev="(nil)" upper="0xa6bff9f0" lower="0xa897f1bc"><txt ptr="0xa897f1bc" next="0xa897f24c" prev="(nil)" upper="0xa998ea8c" lower="(nil)">            if(tire[pre][i]) {<Finish/></txt><txt ptr="0xa897f24c" next="0xa897f2dc" prev="0xa897f1bc" upper="0xa998ea8c" lower="(nil)">                que.push(tire[pre][i]);<Finish/></txt><txt ptr="0xa897f2dc" next="0xa897f36c" prev="0xa897f24c" upper="0xa998ea8c" lower="(nil)">                fail[tire[pre][i]] = tire[fail[pre]][i];<Finish/></txt><txt ptr="0xa897f36c" next="0xa897f3fc" prev="0xa897f2dc" upper="0xa998ea8c" lower="(nil)">            } else {<Finish/></txt><txt ptr="0xa897f3fc" next="0xa897f48c" prev="0xa897f36c" upper="0xa998ea8c" lower="(nil)">                tire[pre][i] = tire[fail[pre]][i];<Finish/></txt><txt ptr="0xa897f48c" next="0xa897f51c" prev="0xa897f3fc" upper="0xa998ea8c" lower="(nil)">            }<Finish/></txt><txt ptr="0xa897f51c" next="0xa897f5ac" prev="0xa897f48c" upper="0xa998ea8c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa897f5ac" next="0xa897f63c" prev="0xa897f51c" upper="0xa998ea8c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa897f63c" next="0xa897f6cc" prev="0xa897f5ac" upper="0xa998ea8c" lower="(nil)">}<Finish/></txt><txt ptr="0xa897f6cc" next="0xa897f75c" prev="0xa897f63c" upper="0xa998ea8c" lower="(nil)">int query(char* str) {<Finish/></txt><txt ptr="0xa897f75c" next="0xa897f7ec" prev="0xa897f6cc" upper="0xa998ea8c" lower="(nil)">    int cnt=0,i,tmp;<Finish/></txt><txt ptr="0xa897f7ec" next="0xa897f87c" prev="0xa897f75c" upper="0xa998ea8c" lower="(nil)">    int p = 0;<Finish/></txt><txt ptr="0xa897f87c" next="0xa897f90c" prev="0xa897f7ec" upper="0xa998ea8c" lower="(nil)">    for(; *str; str++) {<Finish/></txt><txt ptr="0xa897f90c" next="0xa897f99c" prev="0xa897f87c" upper="0xa998ea8c" lower="(nil)">        i= *str-'a';<Finish/></txt><txt ptr="0xa897f99c" next="0xa897fa2c" prev="0xa897f90c" upper="0xa998ea8c" lower="(nil)">        while(tire[p][i] == 0 &amp;&amp; p) p=fail[p];<Finish/></txt><txt ptr="0xa897fa2c" next="0xa897fabc" prev="0xa897f99c" upper="0xa998ea8c" lower="(nil)">        p = tire[p][i];<Finish/></txt><txt ptr="0xa897fabc" next="0xa897fb4c" prev="0xa897fa2c" upper="0xa998ea8c" lower="(nil)">        tmp = p;<Finish/></txt><txt ptr="0xa897fb4c" next="0xa897fbdc" prev="0xa897fabc" upper="0xa998ea8c" lower="(nil)">        while(tmp) {<Finish/></txt><txt ptr="0xa897fbdc" next="0xa897fc6c" prev="0xa897fb4c" upper="0xa998ea8c" lower="(nil)">            cnt += word[tmp];<Finish/></txt><txt ptr="0xa897fc6c" next="0xa897fcfc" prev="0xa897fbdc" upper="0xa998ea8c" lower="(nil)">            word[tmp] = 0;<Finish/></txt><txt ptr="0xa897fcfc" next="0xa897fd8c" prev="0xa897fc6c" upper="0xa998ea8c" lower="(nil)">            tmp = fail[tmp];<Finish/></txt><txt ptr="0xa897fd8c" next="0xa897fe1c" prev="0xa897fcfc" upper="0xa998ea8c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa897fe1c" next="0xa89801c0" prev="0xa897fd8c" upper="0xa998ea8c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89801c0" next="0xa8980250" prev="0xa897fe1c" upper="0xa998ea8c" lower="(nil)">    return cnt;<Finish/></txt><txt ptr="0xa8980250" next="0xa89802e0" prev="0xa89801c0" upper="0xa998ea8c" lower="(nil)">}<Finish/></txt><txt ptr="0xa89802e0" next="0xa8980370" prev="0xa8980250" upper="0xa998ea8c" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa8980370" next="0xa8980400" prev="0xa89802e0" upper="0xa998ea8c" lower="(nil)">    char keyword[51];     //输入的单词<Finish/></txt><txt ptr="0xa8980400" next="(nil)" prev="0xa8980370" upper="0xa998ea8c" lower="(nil)">    char str[1000005];    //模式串<Finish/></txt></body></column><column ptr="0xa6bffa54" next="0xa6bffab8" prev="0xa6bff9f0" upper="0xa8978c08" lower="0xa998eaec"><body ptr="0xa998eaec" next="(nil)" prev="(nil)" upper="0xa6bffa54" lower="0xa8980490"><txt ptr="0xa8980490" next="0xa8980520" prev="(nil)" upper="0xa998eaec" lower="(nil)">    int n;<Finish/></txt><txt ptr="0xa8980520" next="0xa89805b0" prev="0xa8980490" upper="0xa998eaec" lower="(nil)">    scanf(&quot;%d&quot;,&amp;n);<Finish/></txt><txt ptr="0xa89805b0" next="0xa8980640" prev="0xa8980520" upper="0xa998eaec" lower="(nil)">    init();<Finish/></txt><txt ptr="0xa8980640" next="0xa89806d0" prev="0xa89805b0" upper="0xa998eaec" lower="(nil)">    while(n--) {<Finish/></txt><txt ptr="0xa89806d0" next="0xa8980760" prev="0xa8980640" upper="0xa998eaec" lower="(nil)">        scanf(&quot;%s&quot;,keyword);<Finish/></txt><txt ptr="0xa8980760" next="0xa89807f0" prev="0xa89806d0" upper="0xa998eaec" lower="(nil)">        insert(keyword,1);<Finish/></txt><txt ptr="0xa89807f0" next="0xa8980880" prev="0xa8980760" upper="0xa998eaec" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8980880" next="0xa8980910" prev="0xa89807f0" upper="0xa998eaec" lower="(nil)">    build_ac_automation();<Finish/></txt><txt ptr="0xa8980910" next="0xa89809a0" prev="0xa8980880" upper="0xa998eaec" lower="(nil)">    scanf(&quot;%s&quot;,str);<Finish/></txt><txt ptr="0xa89809a0" next="0xa8980a30" prev="0xa8980910" upper="0xa998eaec" lower="(nil)">    printf(&quot;%d\n&quot;,query(str));<Finish/></txt><txt ptr="0xa8980a30" next="0xa8980ac0" prev="0xa89809a0" upper="0xa998eaec" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa8980ac0" next="0xa8980b50" prev="0xa8980a30" upper="0xa998eaec" lower="(nil)">}<Finish/></txt><txt ptr="0xa8980b50" next="0xa8980be0" prev="0xa8980ac0" upper="0xa998eaec" lower="(nil)">最少交换次数<Finish/></txt><txt ptr="0xa8980be0" next="0xa8980c70" prev="0xa8980b50" upper="0xa998eaec" lower="(nil)">只能交换相邻的数<Finish/></txt><txt ptr="0xa8980c70" next="0xa8980d00" prev="0xa8980be0" upper="0xa998eaec" lower="(nil)">给出一组数，通过不断交换两个相邻的数，可以使这组数按非递减顺序排列。问，最小的交换次数是多少？<Finish/></txt><txt ptr="0xa8980d00" next="0xa8980d90" prev="0xa8980c70" upper="0xa998eaec" lower="(nil)">思路：归并排序，其实答案就是逆序数的个数。<Finish/></txt><txt ptr="0xa8980d90" next="0xa8980e20" prev="0xa8980d00" upper="0xa998eaec" lower="(nil)">只能交换相邻的区间<Finish/></txt><txt ptr="0xa8980e20" next="0xa8980eb0" prev="0xa8980d90" upper="0xa998eaec" lower="(nil)">使用IDA*搜索。<Finish/></txt><txt ptr="0xa8980eb0" next="0xa8980f40" prev="0xa8980e20" upper="0xa998eaec" lower="(nil)">离散化<Finish/></txt><txt ptr="0xa8980f40" next="0xa8981014" prev="0xa8980eb0" upper="0xa998eaec" lower="(nil)">/*<Finish/></txt><txt ptr="0xa8981014" next="0xa89810a4" prev="0xa8980f40" upper="0xa998eaec" lower="(nil)">边界为1<Finish/></txt><txt ptr="0xa89810a4" next="0xa8981134" prev="0xa8981014" upper="0xa998eaec" lower="(nil)">内部为2<Finish/></txt><txt ptr="0xa8981134" next="0xa89811c4" prev="0xa89810a4" upper="0xa998eaec" lower="(nil)">当边界无效时为3<Finish/></txt><txt ptr="0xa89811c4" next="0xa8981254" prev="0xa8981134" upper="0xa998eaec" lower="(nil)"><Finish/></txt><txt ptr="0xa8981254" next="(nil)" prev="0xa89811c4" upper="0xa998eaec" lower="(nil)" follow="0xa8962808">矩阵的周长就是偶数行奇数列的1的宽度 和 奇数列偶数行的高度<Finish/></txt></body></column><column ptr="0xa6bffab8" next="(nil)" prev="0xa6bffa54" upper="0xa8978c08" lower="0xa998ebac"><body ptr="0xa998ebac" next="(nil)" prev="(nil)" upper="0xa6bffab8" lower="0xa8962808"><txt ptr="0xa8962808" next="0xa89812e4" prev="(nil)" upper="0xa998ebac" lower="(nil)" precede="0xa8981254">矩阵的周长就是偶数行奇数列的1的宽度 和 奇数列偶数行的高度<Finish/></txt><txt ptr="0xa89812e4" next="0xa8981374" prev="0xa8962808" upper="0xa998ebac" lower="(nil)">矩阵的面积就是里面2的面积计算方法:(r-l)*(d-u)<Finish/></txt><txt ptr="0xa8981374" next="0xa8981404" prev="0xa89812e4" upper="0xa998ebac" lower="(nil)">/*<Finish/></txt><txt ptr="0xa8981404" next="0xa8981764" prev="0xa8981374" upper="0xa998ebac" lower="(nil)"> 0  0  0  0  0  0<Finish/></txt><txt ptr="0xa8981764" next="0xa89817f4" prev="0xa8981404" upper="0xa998ebac" lower="(nil)"> 0  0  0  0  0  0<Finish/></txt><txt ptr="0xa89817f4" next="0xa8981884" prev="0xa8981764" upper="0xa998ebac" lower="(nil)"> 0  0  1  1  1  0<Finish/></txt><txt ptr="0xa8981884" next="0xa8981914" prev="0xa89817f4" upper="0xa998ebac" lower="(nil)"> 0  0  1  2  1  0<Finish/></txt><txt ptr="0xa8981914" next="0xa89819a4" prev="0xa8981884" upper="0xa998ebac" lower="(nil)"> 0  0  1  1  1  0<Finish/></txt><txt ptr="0xa89819a4" next="0xa8981a34" prev="0xa8981914" upper="0xa998ebac" lower="(nil)"> 0  0  0  0  0  0<Finish/></txt><txt ptr="0xa8981a34" next="0xa8981ac4" prev="0xa89819a4" upper="0xa998ebac" lower="(nil)">*/<Finish/></txt><txt ptr="0xa8981ac4" next="0xa8981b54" prev="0xa8981a34" upper="0xa998ebac" lower="(nil)">struct B {<Finish/></txt><txt ptr="0xa8981b54" next="0xa8981be4" prev="0xa8981ac4" upper="0xa998ebac" lower="(nil)">*double x1, y1, x2, y2;<Finish/></txt><txt ptr="0xa8981be4" next="0xa8981c74" prev="0xa8981b54" upper="0xa998ebac" lower="(nil)">*void init() {<Finish/></txt><txt ptr="0xa8981c74" next="0xa8981d04" prev="0xa8981be4" upper="0xa998ebac" lower="(nil)">**scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);<Finish/></txt><txt ptr="0xa8981d04" next="0xa8981d94" prev="0xa8981c74" upper="0xa998ebac" lower="(nil)">**if(x1 &gt; x2) swap(x1, x2);<Finish/></txt><txt ptr="0xa8981d94" next="0xa8981e24" prev="0xa8981d04" upper="0xa998ebac" lower="(nil)">**if(y1 &gt; y2) swap(y1, y2);<Finish/></txt><txt ptr="0xa8981e24" next="0xa8981eb4" prev="0xa8981d94" upper="0xa998ebac" lower="(nil)">*};<Finish/></txt><txt ptr="0xa8981eb4" next="0xa8981f44" prev="0xa8981e24" upper="0xa998ebac" lower="(nil)">};<Finish/></txt><txt ptr="0xa8981f44" next="0xa8982018" prev="0xa8981eb4" upper="0xa998ebac" lower="(nil)">int const inf = 0x3f3f3f3f, maxn =  20100;<Finish/></txt><txt ptr="0xa8982018" next="0xa89820a8" prev="0xa8981f44" upper="0xa998ebac" lower="(nil)">int x1, y1, x2, y2, n, mx, my;<Finish/></txt><txt ptr="0xa89820a8" next="0xa8982138" prev="0xa8982018" upper="0xa998ebac" lower="(nil)">int m[maxn][maxn];<Finish/></txt><txt ptr="0xa8982138" next="0xa89821c8" prev="0xa89820a8" upper="0xa998ebac" lower="(nil)">set&lt;double&gt; x, y;<Finish/></txt><txt ptr="0xa89821c8" next="0xa8982258" prev="0xa8982138" upper="0xa998ebac" lower="(nil)">set&lt;double&gt;::iterator si;<Finish/></txt><txt ptr="0xa8982258" next="0xa89822e8" prev="0xa89821c8" upper="0xa998ebac" lower="(nil)">map&lt;double, int&gt; hx, hy;<Finish/></txt><txt ptr="0xa89822e8" next="0xa8982378" prev="0xa8982258" upper="0xa998ebac" lower="(nil)">map&lt;int, double&gt; hhx, hhy;<Finish/></txt><txt ptr="0xa8982378" next="0xa8982408" prev="0xa89822e8" upper="0xa998ebac" lower="(nil)">B b[maxn];<Finish/></txt><txt ptr="0xa8982408" next="0xa8982498" prev="0xa8982378" upper="0xa998ebac" lower="(nil)"><Finish/></txt><txt ptr="0xa8982498" next="(nil)" prev="0xa8982408" upper="0xa998ebac" lower="(nil)">double getS(){<Finish/></txt></body></column></section></body><footer ptr="0xa8998600" next="(nil)" prev="0xa99c89c4" upper="0xa89937b4" lower="0xa99b59b0"><txt ptr="0xa99b59b0" next="0xa99b5b60" prev="(nil)" upper="0xa8998600" lower="(nil)"><anchored><fly ptr="0xb3a5858" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99b5a40"><txt ptr="0xa99b5a40" next="0xa99b5ad0" prev="(nil)" upper="0xb3a5858" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99b5ad0" next="(nil)" prev="0xa99b5a40" upper="0xb3a5858" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="1"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="9"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99b5b60" next="(nil)" prev="0xa99b59b0" upper="0xa8998600" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993828" next="0xa899389c" prev="0xa89937b4" upper="0xb0726b0" lower="0xa8996660"><header ptr="0xa8996660" next="0xa99c8b44" prev="(nil)" upper="0xa8993828" lower="0xa99b6ec4"><txt ptr="0xa99b6ec4" next="(nil)" prev="(nil)" upper="0xa8996660" lower="(nil)"><Finish/></txt></header><body ptr="0xa99c8b44" next="0xa8998660" prev="0xa8996660" upper="0xa8993828" lower="0xa8978488"><section ptr="0xa8978488" next="(nil)" prev="(nil)" upper="0xa99c8b44" lower="0xa8961460" follow="0xa8978908" precede="0xa8978c08"><column ptr="0xa8961460" next="0xa89614c4" prev="(nil)" upper="0xa8978488" lower="0xa897baf8"><body ptr="0xa897baf8" next="(nil)" prev="(nil)" upper="0xa8961460" lower="0xa8982528"><txt ptr="0xa8982528" next="0xa89825b8" prev="(nil)" upper="0xa897baf8" lower="(nil)">*double ans = 0;<Finish/></txt><txt ptr="0xa89825b8" next="0xa8982648" prev="0xa8982528" upper="0xa897baf8" lower="(nil)">*for(int i=3;i&lt;mx;i+=2)<Finish/></txt><txt ptr="0xa8982648" next="0xa89826d8" prev="0xa89825b8" upper="0xa897baf8" lower="(nil)">**for(int j=3;j&lt;my;j+=2)<Finish/></txt><txt ptr="0xa89826d8" next="0xa8982768" prev="0xa8982648" upper="0xa897baf8" lower="(nil)">***if(m[i][j]==2)<Finish/></txt><txt ptr="0xa8982768" next="0xa89827f8" prev="0xa89826d8" upper="0xa897baf8" lower="(nil)">****ans += (hhx[i+1]-hhx[i-1])*(hhy[j+1]-hhy[j-1]);<Finish/></txt><txt ptr="0xa89827f8" next="0xa8982888" prev="0xa8982768" upper="0xa897baf8" lower="(nil)">*return ans;<Finish/></txt><txt ptr="0xa8982888" next="0xa8982918" prev="0xa89827f8" upper="0xa897baf8" lower="(nil)">}<Finish/></txt><txt ptr="0xa8982918" next="0xa89829a8" prev="0xa8982888" upper="0xa897baf8" lower="(nil)"><Finish/></txt><txt ptr="0xa89829a8" next="0xa8982d08" prev="0xa8982918" upper="0xa897baf8" lower="(nil)">double getL(){<Finish/></txt><txt ptr="0xa8982d08" next="0xa8982d98" prev="0xa89829a8" upper="0xa897baf8" lower="(nil)">*double  ans=0;<Finish/></txt><txt ptr="0xa8982d98" next="0xa8982e28" prev="0xa8982d08" upper="0xa897baf8" lower="(nil)">*for(int i=2;i&lt;mx;i+=2)<Finish/></txt><txt ptr="0xa8982e28" next="0xa8982eb8" prev="0xa8982d98" upper="0xa897baf8" lower="(nil)">**for(int j=3;j&lt;my;j+=2)<Finish/></txt><txt ptr="0xa8982eb8" next="0xa8982f48" prev="0xa8982e28" upper="0xa897baf8" lower="(nil)">***if(m[i][j]==1)<Finish/></txt><txt ptr="0xa8982f48" next="0xa898301c" prev="0xa8982eb8" upper="0xa897baf8" lower="(nil)">****ans += hhy[j+1]-hhy[j-1];<Finish/></txt><txt ptr="0xa898301c" next="0xa89830ac" prev="0xa8982f48" upper="0xa897baf8" lower="(nil)"><Finish/></txt><txt ptr="0xa89830ac" next="0xa898313c" prev="0xa898301c" upper="0xa897baf8" lower="(nil)">*for(int i=3;i&lt;mx;i+=2)<Finish/></txt><txt ptr="0xa898313c" next="0xa89831cc" prev="0xa89830ac" upper="0xa897baf8" lower="(nil)">**for(int j=2;j&lt;my;j+=2)<Finish/></txt><txt ptr="0xa89831cc" next="0xa898325c" prev="0xa898313c" upper="0xa897baf8" lower="(nil)">***if(m[i][j]==1)<Finish/></txt><txt ptr="0xa898325c" next="0xa89832ec" prev="0xa89831cc" upper="0xa897baf8" lower="(nil)">****ans += hhx[i+1]-hhx[i-1];<Finish/></txt><txt ptr="0xa89832ec" next="0xa898337c" prev="0xa898325c" upper="0xa897baf8" lower="(nil)">*return ans;<Finish/></txt><txt ptr="0xa898337c" next="0xa898340c" prev="0xa89832ec" upper="0xa897baf8" lower="(nil)">}<Finish/></txt><txt ptr="0xa898340c" next="0xa898349c" prev="0xa898337c" upper="0xa897baf8" lower="(nil)"><Finish/></txt><txt ptr="0xa898349c" next="0xa898352c" prev="0xa898340c" upper="0xa897baf8" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa898352c" next="0xa89835bc" prev="0xa898349c" upper="0xa897baf8" lower="(nil)">*const bool debug = false;<Finish/></txt><txt ptr="0xa89835bc" next="0xa898364c" prev="0xa898352c" upper="0xa897baf8" lower="(nil)">*int i, j, k,cs=1;<Finish/></txt><txt ptr="0xa898364c" next="0xa89836dc" prev="0xa89835bc" upper="0xa897baf8" lower="(nil)">*while(~scanf(&quot;%d&quot;, &amp;n),n) {<Finish/></txt><txt ptr="0xa89836dc" next="(nil)" prev="0xa898364c" upper="0xa897baf8" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa89614c4" next="0xa8961528" prev="0xa8961460" upper="0xa8978488" lower="0xa897bb58"><body ptr="0xa897bb58" next="(nil)" prev="(nil)" upper="0xa89614c4" lower="0xa898376c"><txt ptr="0xa898376c" next="0xa89837fc" prev="(nil)" upper="0xa897bb58" lower="(nil)">**x.clear();y.clear();<Finish/></txt><txt ptr="0xa89837fc" next="0xa898388c" prev="0xa898376c" upper="0xa897bb58" lower="(nil)">**for(i = 0; i &lt; n; i++) {<Finish/></txt><txt ptr="0xa898388c" next="0xa898391c" prev="0xa89837fc" upper="0xa897bb58" lower="(nil)">***b[i].init();<Finish/></txt><txt ptr="0xa898391c" next="0xa89839ac" prev="0xa898388c" upper="0xa897bb58" lower="(nil)">***x.insert(b[i].x1);x.insert(b[i].x2);<Finish/></txt><txt ptr="0xa89839ac" next="0xa8983a3c" prev="0xa898391c" upper="0xa897bb58" lower="(nil)">***y.insert(b[i].y1);y.insert(b[i].y2);<Finish/></txt><txt ptr="0xa8983a3c" next="0xa8983acc" prev="0xa89839ac" upper="0xa897bb58" lower="(nil)">**}<Finish/></txt><txt ptr="0xa8983acc" next="0xa8983b5c" prev="0xa8983a3c" upper="0xa897bb58" lower="(nil)">**hx.clear();hy.clear();<Finish/></txt><txt ptr="0xa8983b5c" next="0xa8983bec" prev="0xa8983acc" upper="0xa897bb58" lower="(nil)"><Finish/></txt><txt ptr="0xa8983bec" next="0xa8983c7c" prev="0xa8983b5c" upper="0xa897bb58" lower="(nil)">**//把地图扩大二倍后，矩阵内部就可以被填充，矩阵边界就可以走了<Finish/></txt><txt ptr="0xa8983c7c" next="0xa8983d0c" prev="0xa8983bec" upper="0xa897bb58" lower="(nil)">**//对x离散化<Finish/></txt><txt ptr="0xa8983d0c" next="0xa8983d9c" prev="0xa8983c7c" upper="0xa897bb58" lower="(nil)">*for(si=x.begin(),mx=2;si!=x.end();hx[*si]=mx,hhx[mx] = *si, si++,mx+=2) ;<Finish/></txt><txt ptr="0xa8983d9c" next="0xa8983e2c" prev="0xa8983d0c" upper="0xa897bb58" lower="(nil)"><Finish/></txt><txt ptr="0xa8983e2c" next="0xa8983ebc" prev="0xa8983d9c" upper="0xa897bb58" lower="(nil)">**//对y离散化<Finish/></txt><txt ptr="0xa8983ebc" next="0xa8983f4c" prev="0xa8983e2c" upper="0xa897bb58" lower="(nil)">**for(si=y.begin(),my=2;si!=y.end();hy[*si]=my, hhy[my] = *si, si++,my+=2);<Finish/></txt><txt ptr="0xa8983f4c" next="0xa89842f0" prev="0xa8983ebc" upper="0xa897bb58" lower="(nil)">**//初始化矩阵<Finish/></txt><txt ptr="0xa89842f0" next="0xa8984380" prev="0xa8983f4c" upper="0xa897bb58" lower="(nil)">**for(i = 0; i &lt; mx; ++i){<Finish/></txt><txt ptr="0xa8984380" next="0xa8984410" prev="0xa89842f0" upper="0xa897bb58" lower="(nil)">***fill(m[i], m[i] + my, 0);<Finish/></txt><txt ptr="0xa8984410" next="0xa89844a0" prev="0xa8984380" upper="0xa897bb58" lower="(nil)">**}<Finish/></txt><txt ptr="0xa89844a0" next="0xa8984530" prev="0xa8984410" upper="0xa897bb58" lower="(nil)">**//填充矩阵，填充为1<Finish/></txt><txt ptr="0xa8984530" next="0xa89845c0" prev="0xa89844a0" upper="0xa897bb58" lower="(nil)">**for(i = 0; i &lt; n; i++) {<Finish/></txt><txt ptr="0xa89845c0" next="0xa8984650" prev="0xa8984530" upper="0xa897bb58" lower="(nil)">***int xuper = hx[b[i].x2];<Finish/></txt><txt ptr="0xa8984650" next="0xa89846e0" prev="0xa89845c0" upper="0xa897bb58" lower="(nil)">***int yuper = hy[b[i].y2];<Finish/></txt><txt ptr="0xa89846e0" next="0xa8984770" prev="0xa8984650" upper="0xa897bb58" lower="(nil)"><Finish/></txt><txt ptr="0xa8984770" next="0xa8984800" prev="0xa89846e0" upper="0xa897bb58" lower="(nil)">***//填充上下边界<Finish/></txt><txt ptr="0xa8984800" next="(nil)" prev="0xa8984770" upper="0xa897bb58" lower="(nil)">***for(j = hx[b[i].x1]; j &lt;= xuper; j++){<Finish/></txt></body></column><column ptr="0xa8961528" next="(nil)" prev="0xa89614c4" upper="0xa8978488" lower="0xa897bbb8"><body ptr="0xa897bbb8" next="(nil)" prev="(nil)" upper="0xa8961528" lower="0xa8984890"><txt ptr="0xa8984890" next="0xa8984920" prev="(nil)" upper="0xa897bbb8" lower="(nil)">*if(m[j][hy[b[i].y1]]==0)m[j][hy[b[i].y1]]=1;<Finish/></txt><txt ptr="0xa8984920" next="0xa89849b0" prev="0xa8984890" upper="0xa897bbb8" lower="(nil)">*if(m[j][hy[b[i].y2]]==0)m[j][hy[b[i].y2]]=1;<Finish/></txt><txt ptr="0xa89849b0" next="0xa8984a40" prev="0xa8984920" upper="0xa897bbb8" lower="(nil)">***}<Finish/></txt><txt ptr="0xa8984a40" next="0xa8984ad0" prev="0xa89849b0" upper="0xa897bbb8" lower="(nil)">***//填充左右边界<Finish/></txt><txt ptr="0xa8984ad0" next="0xa8984b60" prev="0xa8984a40" upper="0xa897bbb8" lower="(nil)">***for(k = hy[b[i].y1]; k &lt;= yuper; k++){<Finish/></txt><txt ptr="0xa8984b60" next="0xa8984bf0" prev="0xa8984ad0" upper="0xa897bbb8" lower="(nil)">*if(m[hx[b[i].x1]][k]==0)m[hx[b[i].x1]][k]=1;<Finish/></txt><txt ptr="0xa8984bf0" next="0xa8984c80" prev="0xa8984b60" upper="0xa897bbb8" lower="(nil)">*if(m[hx[b[i].x2]][k]==0)m[hx[b[i].x2]][k]=1;<Finish/></txt><txt ptr="0xa8984c80" next="0xa8984d10" prev="0xa8984bf0" upper="0xa897bbb8" lower="(nil)">***}<Finish/></txt><txt ptr="0xa8984d10" next="0xa8984da0" prev="0xa8984c80" upper="0xa897bbb8" lower="(nil)">***//填充矩阵内部<Finish/></txt><txt ptr="0xa8984da0" next="0xa8984e30" prev="0xa8984d10" upper="0xa897bbb8" lower="(nil)">***for(j = hx[b[i].x1] + 1; j &lt; xuper; j++) {<Finish/></txt><txt ptr="0xa8984e30" next="0xa8984ec0" prev="0xa8984da0" upper="0xa897bbb8" lower="(nil)">***for(k = hy[b[i].y1] + 1; k &lt; yuper; k++) {<Finish/></txt><txt ptr="0xa8984ec0" next="0xa8984f50" prev="0xa8984e30" upper="0xa897bbb8" lower="(nil)">*****m[j][k]=2;<Finish/></txt><txt ptr="0xa8984f50" next="0xa8985024" prev="0xa8984ec0" upper="0xa897bbb8" lower="(nil)">****}<Finish/></txt><txt ptr="0xa8985024" next="0xa89850b4" prev="0xa8984f50" upper="0xa897bbb8" lower="(nil)">***}<Finish/></txt><txt ptr="0xa89850b4" next="0xa8985144" prev="0xa8985024" upper="0xa897bbb8" lower="(nil)">**}<Finish/></txt><txt ptr="0xa8985144" next="0xa89851d4" prev="0xa89850b4" upper="0xa897bbb8" lower="(nil)">**//此处已不属于周长，标记为3<Finish/></txt><txt ptr="0xa89851d4" next="0xa8985264" prev="0xa8985144" upper="0xa897bbb8" lower="(nil)">**for(i=1;i&lt;mx-1;i++){<Finish/></txt><txt ptr="0xa8985264" next="0xa89852f4" prev="0xa89851d4" upper="0xa897bbb8" lower="(nil)">***for(j=1;j&lt;my-1;j++){<Finish/></txt><txt ptr="0xa89852f4" next="0xa8985384" prev="0xa8985264" upper="0xa897bbb8" lower="(nil)">****if(m[i][j] == 1 &amp;&amp; m[i-1][j]&amp;&amp;m[i][j-1]&amp;&amp;m[i+1][j]&amp;&amp;m[i][j+1])<Finish/></txt><txt ptr="0xa8985384" next="0xa8985414" prev="0xa89852f4" upper="0xa897bbb8" lower="(nil)">*****m[i][j]=3;<Finish/></txt><txt ptr="0xa8985414" next="0xa89854a4" prev="0xa8985384" upper="0xa897bbb8" lower="(nil)">***}<Finish/></txt><txt ptr="0xa89854a4" next="0xa8985534" prev="0xa8985414" upper="0xa897bbb8" lower="(nil)">**}<Finish/></txt><txt ptr="0xa8985534" next="0xa8985894" prev="0xa89854a4" upper="0xa897bbb8" lower="(nil)">**double S=getS();<Finish/></txt><txt ptr="0xa8985894" next="0xa8985924" prev="0xa8985534" upper="0xa897bbb8" lower="(nil)">printf(&quot;Test case #%d\nTotal  area: %.2f\n\n&quot;,cs++,S);<Finish/></txt><txt ptr="0xa8985924" next="0xa89859b4" prev="0xa8985894" upper="0xa897bbb8" lower="(nil)">**//int L = (int)getL();<Finish/></txt><txt ptr="0xa89859b4" next="0xa8985a44" prev="0xa8985924" upper="0xa897bbb8" lower="(nil)">**//printf(&quot;%d\n&quot;,L);<Finish/></txt><txt ptr="0xa8985a44" next="(nil)" prev="0xa89859b4" upper="0xa897bbb8" lower="(nil)">*}<Finish/></txt></body></column></section></body><footer ptr="0xa8998660" next="(nil)" prev="0xa99c8b44" upper="0xa8993828" lower="0xa99b6f54"><txt ptr="0xa99b6f54" next="0xa99b7148" prev="(nil)" upper="0xa8998660" lower="(nil)"><anchored><fly ptr="0xad175d0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99b7028"><txt ptr="0xa99b7028" next="0xa99b70b8" prev="(nil)" upper="0xad175d0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99b70b8" next="(nil)" prev="0xa99b7028" upper="0xad175d0" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="2"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="0"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99b7148" next="(nil)" prev="0xa99b6f54" upper="0xa8998660" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa899389c" next="0xa8993910" prev="0xa8993828" upper="0xb0726b0" lower="0xa89966c0"><header ptr="0xa89966c0" next="0xa99c8cc4" prev="(nil)" upper="0xa899389c" lower="0xa99b8480"><txt ptr="0xa99b8480" next="(nil)" prev="(nil)" upper="0xa89966c0" lower="(nil)"><Finish/></txt></header><body ptr="0xa99c8cc4" next="0xa89986c0" prev="0xa89966c0" upper="0xa899389c" lower="0xa8978908"><section ptr="0xa8978908" next="(nil)" prev="(nil)" upper="0xa99c8cc4" lower="0xa6bffd74" follow="0xa8978788" precede="0xa8978488"><column ptr="0xa6bffd74" next="0xa6bffdd8" prev="(nil)" upper="0xa8978908" lower="0xa8902e44"><body ptr="0xa8902e44" next="(nil)" prev="(nil)" upper="0xa6bffd74" lower="0xa8985ad4"><txt ptr="0xa8985ad4" next="0xa8985b64" prev="(nil)" upper="0xa8902e44" lower="(nil)">*return 0;<Finish/></txt><txt ptr="0xa8985b64" next="0xa8985bf4" prev="0xa8985ad4" upper="0xa8902e44" lower="(nil)">}<Finish/></txt><txt ptr="0xa8985bf4" next="0xa8985c84" prev="0xa8985b64" upper="0xa8902e44" lower="(nil)"><Finish/></txt><txt ptr="0xa8985c84" next="0xa8985d14" prev="0xa8985bf4" upper="0xa8902e44" lower="(nil)">Splay（伸展树）<Finish/></txt><txt ptr="0xa8985d14" next="0xa8985da4" prev="0xa8985c84" upper="0xa8902e44" lower="(nil)">用伸展树解决数列维护问题，可以支持两个线段树无法支持的操作：在某个<Finish/></txt><txt ptr="0xa8985da4" next="0xa8985e34" prev="0xa8985d14" upper="0xa8902e44" lower="(nil)">位置插入一些数和删除一些连续的数<Finish/></txt><txt ptr="0xa8985e34" next="0xa8985ec4" prev="0xa8985da4" upper="0xa8902e44" lower="(nil)">分段哈希<Finish/></txt><txt ptr="0xa8985ec4" next="0xa8985f54" prev="0xa8985e34" upper="0xa8902e44" lower="(nil)">const int cs=337,cs2=1007;<Finish/></txt><txt ptr="0xa8985f54" next="0xa8986028" prev="0xa8985ec4" upper="0xa8902e44" lower="(nil)">struct HS{<Finish/></txt><txt ptr="0xa8986028" next="0xa89860b8" prev="0xa8985f54" upper="0xa8902e44" lower="(nil)">*//n为当前段有几种颜色 <Finish/></txt><txt ptr="0xa89860b8" next="0xa8986148" prev="0xa8986028" upper="0xa8902e44" lower="(nil)">//s[]存这种颜色的个数,b[]存颜色的值 <Finish/></txt><txt ptr="0xa8986148" next="0xa89861d8" prev="0xa89860b8" upper="0xa8902e44" lower="(nil)">*int a[1000],next[cs2],n,s[cs2],f[cs2],b[cs2];<Finish/></txt><txt ptr="0xa89861d8" next="0xa8986268" prev="0xa8986148" upper="0xa8902e44" lower="(nil)">*int bj;<Finish/></txt><txt ptr="0xa8986268" next="0xa89862f8" prev="0xa89861d8" upper="0xa8902e44" lower="(nil)">*<Finish/></txt><txt ptr="0xa89862f8" next="0xa8986388" prev="0xa8986268" upper="0xa8902e44" lower="(nil)">*void clear(){<Finish/></txt><txt ptr="0xa8986388" next="0xa8986418" prev="0xa89862f8" upper="0xa8902e44" lower="(nil)">**bj=-1; memset(f,-1,sizeof(f)); n=0;<Finish/></txt><txt ptr="0xa8986418" next="0xa89864a8" prev="0xa8986388" upper="0xa8902e44" lower="(nil)">*}<Finish/></txt><txt ptr="0xa89864a8" next="0xa8986538" prev="0xa8986418" upper="0xa8902e44" lower="(nil)">*void init(){<Finish/></txt><txt ptr="0xa8986538" next="0xa89865c8" prev="0xa89864a8" upper="0xa8902e44" lower="(nil)">**bj=-1;<Finish/></txt><txt ptr="0xa89865c8" next="0xa8986658" prev="0xa8986538" upper="0xa8902e44" lower="(nil)">**for(int i=0;i&lt;n;i++)<Finish/></txt><txt ptr="0xa8986658" next="0xa89866e8" prev="0xa89865c8" upper="0xa8902e44" lower="(nil)">***f[b[i]%cs2]=-1;<Finish/></txt><txt ptr="0xa89866e8" next="0xa8986778" prev="0xa8986658" upper="0xa8902e44" lower="(nil)">**n=0;<Finish/></txt><txt ptr="0xa8986778" next="0xa8986808" prev="0xa89866e8" upper="0xa8902e44" lower="(nil)">*}<Finish/></txt><txt ptr="0xa8986808" next="0xa8986898" prev="0xa8986778" upper="0xa8902e44" lower="(nil)">*int fd(int k){<Finish/></txt><txt ptr="0xa8986898" next="(nil)" prev="0xa8986808" upper="0xa8902e44" lower="(nil)">**if(bj!=-1){<Finish/></txt></body></column><column ptr="0xa6bffdd8" next="0xa6bffe3c" prev="0xa6bffd74" upper="0xa8978908" lower="0xa8902ea4"><body ptr="0xa8902ea4" next="(nil)" prev="(nil)" upper="0xa6bffdd8" lower="0xa8986928"><txt ptr="0xa8986928" next="0xa89869b8" prev="(nil)" upper="0xa8902ea4" lower="(nil)">***if(bj==k)return cs;<Finish/></txt><txt ptr="0xa89869b8" next="0xa8986a48" prev="0xa8986928" upper="0xa8902ea4" lower="(nil)">***else return 0;<Finish/></txt><txt ptr="0xa8986a48" next="0xa8986ad8" prev="0xa89869b8" upper="0xa8902ea4" lower="(nil)">**}<Finish/></txt><txt ptr="0xa8986ad8" next="0xa8986e38" prev="0xa8986a48" upper="0xa8902ea4" lower="(nil)">**int fk=f[k%cs2];<Finish/></txt><txt ptr="0xa8986e38" next="0xa8986ec8" prev="0xa8986ad8" upper="0xa8902ea4" lower="(nil)">**while(fk!=-1){<Finish/></txt><txt ptr="0xa8986ec8" next="0xa8986f58" prev="0xa8986e38" upper="0xa8902ea4" lower="(nil)">***if(b[fk]==k)return s[fk];<Finish/></txt><txt ptr="0xa8986f58" next="0xa8987000" prev="0xa8986ec8" upper="0xa8902ea4" lower="(nil)">***fk=next[fk];<Finish/></txt><txt ptr="0xa8987000" next="0xa8987090" prev="0xa8986f58" upper="0xa8902ea4" lower="(nil)">**}<Finish/></txt><txt ptr="0xa8987090" next="0xa8987120" prev="0xa8987000" upper="0xa8902ea4" lower="(nil)">**return 0;<Finish/></txt><txt ptr="0xa8987120" next="0xa89871b0" prev="0xa8987090" upper="0xa8902ea4" lower="(nil)">*}<Finish/></txt><txt ptr="0xa89871b0" next="0xa8987240" prev="0xa8987120" upper="0xa8902ea4" lower="(nil)">*int fd(int l,int r,int k){<Finish/></txt><txt ptr="0xa8987240" next="0xa89872d0" prev="0xa89871b0" upper="0xa8902ea4" lower="(nil)">**int da=0;<Finish/></txt><txt ptr="0xa89872d0" next="0xa8987360" prev="0xa8987240" upper="0xa8902ea4" lower="(nil)">**if(bj!=-1){ push();crt();}<Finish/></txt><txt ptr="0xa8987360" next="0xa89873f0" prev="0xa89872d0" upper="0xa8902ea4" lower="(nil)"><Finish/></txt><txt ptr="0xa89873f0" next="0xa8987480" prev="0xa8987360" upper="0xa8902ea4" lower="(nil)">**for(int i=l;i&lt;=r;i++){<Finish/></txt><txt ptr="0xa8987480" next="0xa8987510" prev="0xa89873f0" upper="0xa8902ea4" lower="(nil)">***da+=(a[i%cs]==k);<Finish/></txt><txt ptr="0xa8987510" next="0xa89875a0" prev="0xa8987480" upper="0xa8902ea4" lower="(nil)">**}<Finish/></txt><txt ptr="0xa89875a0" next="0xa8987630" prev="0xa8987510" upper="0xa8902ea4" lower="(nil)">**return da;<Finish/></txt><txt ptr="0xa8987630" next="0xa89876c0" prev="0xa89875a0" upper="0xa8902ea4" lower="(nil)">*}<Finish/></txt><txt ptr="0xa89876c0" next="0xa8987750" prev="0xa8987630" upper="0xa8902ea4" lower="(nil)">*void ins(int k){<Finish/></txt><txt ptr="0xa8987750" next="0xa89877e0" prev="0xa89876c0" upper="0xa8902ea4" lower="(nil)">**int fk=f[k%cs2];<Finish/></txt><txt ptr="0xa89877e0" next="0xa8987870" prev="0xa8987750" upper="0xa8902ea4" lower="(nil)">**while(fk!=-1){<Finish/></txt><txt ptr="0xa8987870" next="0xa8987900" prev="0xa89877e0" upper="0xa8902ea4" lower="(nil)">***if(b[fk]==k){<Finish/></txt><txt ptr="0xa8987900" next="0xa8987990" prev="0xa8987870" upper="0xa8902ea4" lower="(nil)">****s[fk]++; return ;<Finish/></txt><txt ptr="0xa8987990" next="0xa8987a20" prev="0xa8987900" upper="0xa8902ea4" lower="(nil)">***}<Finish/></txt><txt ptr="0xa8987a20" next="0xa8987ab0" prev="0xa8987990" upper="0xa8902ea4" lower="(nil)">***fk=next[fk];<Finish/></txt><txt ptr="0xa8987ab0" next="0xa8987b40" prev="0xa8987a20" upper="0xa8902ea4" lower="(nil)">**}<Finish/></txt><txt ptr="0xa8987b40" next="(nil)" prev="0xa8987ab0" upper="0xa8902ea4" lower="(nil)">**s[n]=1; b[n]=k;<Finish/></txt></body></column><column ptr="0xa6bffe3c" next="(nil)" prev="0xa6bffdd8" upper="0xa8978908" lower="0xa8902f04"><body ptr="0xa8902f04" next="(nil)" prev="(nil)" upper="0xa6bffe3c" lower="0xa8987bd0"><txt ptr="0xa8987bd0" next="0xa8987c60" prev="(nil)" upper="0xa8902f04" lower="(nil)">next[n]=f[k%cs2];<Finish/></txt><txt ptr="0xa8987c60" next="0xa8987cf0" prev="0xa8987bd0" upper="0xa8902f04" lower="(nil)">**f[k%cs2]=n++;<Finish/></txt><txt ptr="0xa8987cf0" next="0xa8987d80" prev="0xa8987c60" upper="0xa8902f04" lower="(nil)">*}<Finish/></txt><txt ptr="0xa8987d80" next="0xa8987e10" prev="0xa8987cf0" upper="0xa8902f04" lower="(nil)">*void update(int l,int r,int k){<Finish/></txt><txt ptr="0xa8987e10" next="0xa8987ea0" prev="0xa8987d80" upper="0xa8902f04" lower="(nil)">**push();<Finish/></txt><txt ptr="0xa8987ea0" next="0xa8987f30" prev="0xa8987e10" upper="0xa8902f04" lower="(nil)">**for(int i=l;i&lt;=r;i++)<Finish/></txt><txt ptr="0xa8987f30" next="0xa8988004" prev="0xa8987ea0" upper="0xa8902f04" lower="(nil)">***a[i%cs]=k;<Finish/></txt><txt ptr="0xa8988004" next="0xa8988094" prev="0xa8987f30" upper="0xa8902f04" lower="(nil)">**crt();<Finish/></txt><txt ptr="0xa8988094" next="0xa89883f4" prev="0xa8988004" upper="0xa8902f04" lower="(nil)">*}<Finish/></txt><txt ptr="0xa89883f4" next="0xa8988484" prev="0xa8988094" upper="0xa8902f04" lower="(nil)">*void push(){<Finish/></txt><txt ptr="0xa8988484" next="0xa8988514" prev="0xa89883f4" upper="0xa8902f04" lower="(nil)">**if(bj!=-1){<Finish/></txt><txt ptr="0xa8988514" next="0xa89885a4" prev="0xa8988484" upper="0xa8902f04" lower="(nil)">***for(int i=0;i&lt;cs;i++)<Finish/></txt><txt ptr="0xa89885a4" next="0xa8988634" prev="0xa8988514" upper="0xa8902f04" lower="(nil)">****a[i]=bj;<Finish/></txt><txt ptr="0xa8988634" next="0xa89886c4" prev="0xa89885a4" upper="0xa8902f04" lower="(nil)">***bj=-1;<Finish/></txt><txt ptr="0xa89886c4" next="0xa8988754" prev="0xa8988634" upper="0xa8902f04" lower="(nil)">**}<Finish/></txt><txt ptr="0xa8988754" next="0xa89887e4" prev="0xa89886c4" upper="0xa8902f04" lower="(nil)">*}<Finish/></txt><txt ptr="0xa89887e4" next="0xa8988874" prev="0xa8988754" upper="0xa8902f04" lower="(nil)">*void crt(){<Finish/></txt><txt ptr="0xa8988874" next="0xa8988904" prev="0xa89887e4" upper="0xa8902f04" lower="(nil)">**init();<Finish/></txt><txt ptr="0xa8988904" next="0xa8988994" prev="0xa8988874" upper="0xa8902f04" lower="(nil)">**for(int i=0;i&lt;cs;i++)<Finish/></txt><txt ptr="0xa8988994" next="0xa8988a24" prev="0xa8988904" upper="0xa8902f04" lower="(nil)">***ins(a[i]);<Finish/></txt><txt ptr="0xa8988a24" next="0xa8988ab4" prev="0xa8988994" upper="0xa8902f04" lower="(nil)">*}<Finish/></txt><txt ptr="0xa8988ab4" next="0xa8988b44" prev="0xa8988a24" upper="0xa8902f04" lower="(nil)">}hs[400];<Finish/></txt><txt ptr="0xa8988b44" next="0xa8988bd4" prev="0xa8988ab4" upper="0xa8902f04" lower="(nil)">int main(){<Finish/></txt><txt ptr="0xa8988bd4" next="0xa8988c64" prev="0xa8988b44" upper="0xa8902f04" lower="(nil)">*for(int i=0;i&lt;400;i++)<Finish/></txt><txt ptr="0xa8988c64" next="0xa8988cf4" prev="0xa8988bd4" upper="0xa8902f04" lower="(nil)">**hs[i].clear();<Finish/></txt><txt ptr="0xa8988cf4" next="0xa8988d84" prev="0xa8988c64" upper="0xa8902f04" lower="(nil)">*int n,m;<Finish/></txt><txt ptr="0xa8988d84" next="0xa8988e14" prev="0xa8988cf4" upper="0xa8902f04" lower="(nil)">*while(cin&gt;&gt;n&gt;&gt;m){<Finish/></txt><txt ptr="0xa8988e14" next="(nil)" prev="0xa8988d84" upper="0xa8902f04" lower="(nil)">**for(int i=0;i&lt;n;i++)<Finish/></txt></body></column></section></body><footer ptr="0xa89986c0" next="(nil)" prev="0xa99c8cc4" upper="0xa899389c" lower="0xa99b8510"><txt ptr="0xa99b8510" next="0xa99b86c0" prev="(nil)" upper="0xa89986c0" lower="(nil)"><anchored><fly ptr="0xa4b4000" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99b85a0"><txt ptr="0xa99b85a0" next="0xa99b8630" prev="(nil)" upper="0xa4b4000" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99b8630" next="(nil)" prev="0xa99b85a0" upper="0xa4b4000" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="2"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="1"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99b86c0" next="(nil)" prev="0xa99b8510" upper="0xa89986c0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993910" next="0xa8993984" prev="0xa899389c" upper="0xb0726b0" lower="0xa8996720"><header ptr="0xa8996720" next="0xa99c8e44" prev="(nil)" upper="0xa8993910" lower="0xa999aa24"><txt ptr="0xa999aa24" next="(nil)" prev="(nil)" upper="0xa8996720" lower="(nil)"><Finish/></txt></header><body ptr="0xa99c8e44" next="0xa8998720" prev="0xa8996720" upper="0xa8993910" lower="0xa8978788"><section ptr="0xa8978788" next="(nil)" prev="(nil)" upper="0xa99c8e44" lower="0xa6c00030" follow="0xa8978608" precede="0xa8978908"><column ptr="0xa6c00030" next="0xa6c00094" prev="(nil)" upper="0xa8978788" lower="0xa6bfe0c8"><body ptr="0xa6bfe0c8" next="(nil)" prev="(nil)" upper="0xa6c00030" lower="0xa8988ea4"><txt ptr="0xa8988ea4" next="0xa8988f34" prev="(nil)" upper="0xa6bfe0c8" lower="(nil)">***scanf(&quot;%d&quot;,&amp;hs[i/cs].a[i%cs]);<Finish/></txt><txt ptr="0xa8988f34" next="0xa898a008" prev="0xa8988ea4" upper="0xa6bfe0c8" lower="(nil)">**for(int i=0;i*cs&lt;n;i++)<Finish/></txt><txt ptr="0xa898a008" next="0xa898a098" prev="0xa8988f34" upper="0xa6bfe0c8" lower="(nil)">***hs[i].crt();<Finish/></txt><txt ptr="0xa898a098" next="0xa898a128" prev="0xa898a008" upper="0xa6bfe0c8" lower="(nil)"><Finish/></txt><txt ptr="0xa898a128" next="0xa898a1b8" prev="0xa898a098" upper="0xa6bfe0c8" lower="(nil)">**while(m--){<Finish/></txt><txt ptr="0xa898a1b8" next="0xa898a248" prev="0xa898a128" upper="0xa6bfe0c8" lower="(nil)">***int a,l,z,r;<Finish/></txt><txt ptr="0xa898a248" next="0xa898a2d8" prev="0xa898a1b8" upper="0xa6bfe0c8" lower="(nil)">***scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;l,&amp;r,&amp;z);<Finish/></txt><txt ptr="0xa898a2d8" next="0xa898a368" prev="0xa898a248" upper="0xa6bfe0c8" lower="(nil)">***if(a==1){//更新 <Finish/></txt><txt ptr="0xa898a368" next="0xa898a3f8" prev="0xa898a2d8" upper="0xa6bfe0c8" lower="(nil)">****if(l/cs==r/cs){<Finish/></txt><txt ptr="0xa898a3f8" next="0xa898a488" prev="0xa898a368" upper="0xa6bfe0c8" lower="(nil)">*****hs[l/cs].update(l,r,z);<Finish/></txt><txt ptr="0xa898a488" next="0xa898a518" prev="0xa898a3f8" upper="0xa6bfe0c8" lower="(nil)">****}else{<Finish/></txt><txt ptr="0xa898a518" next="0xa898a5a8" prev="0xa898a488" upper="0xa6bfe0c8" lower="(nil)">*****hs[l/cs].update(l%cs,cs-1,z);<Finish/></txt><txt ptr="0xa898a5a8" next="0xa898a638" prev="0xa898a518" upper="0xa6bfe0c8" lower="(nil)">*****hs[r/cs].update(0,r%cs,z);<Finish/></txt><txt ptr="0xa898a638" next="0xa898a998" prev="0xa898a5a8" upper="0xa6bfe0c8" lower="(nil)">*****for(int i=l/cs+1;i&lt;r/cs;i++)<Finish/></txt><txt ptr="0xa898a998" next="0xa898aa28" prev="0xa898a638" upper="0xa6bfe0c8" lower="(nil)">******hs[i].bj=z;*<Finish/></txt><txt ptr="0xa898aa28" next="0xa898aab8" prev="0xa898a998" upper="0xa6bfe0c8" lower="(nil)">****} <Finish/></txt><txt ptr="0xa898aab8" next="0xa898ab48" prev="0xa898aa28" upper="0xa6bfe0c8" lower="(nil)">****<Finish/></txt><txt ptr="0xa898ab48" next="0xa898abd8" prev="0xa898aab8" upper="0xa6bfe0c8" lower="(nil)">***}else{//查询 <Finish/></txt><txt ptr="0xa898abd8" next="0xa898ac68" prev="0xa898ab48" upper="0xa6bfe0c8" lower="(nil)">****int da=0;<Finish/></txt><txt ptr="0xa898ac68" next="0xa898acf8" prev="0xa898abd8" upper="0xa6bfe0c8" lower="(nil)">****if(l/cs==r/cs)<Finish/></txt><txt ptr="0xa898acf8" next="0xa898ad88" prev="0xa898ac68" upper="0xa6bfe0c8" lower="(nil)">****{<Finish/></txt><txt ptr="0xa898ad88" next="0xa898ae18" prev="0xa898acf8" upper="0xa6bfe0c8" lower="(nil)">*****printf(&quot;%d\n&quot;,hs[l/cs].fd(l,r,z));<Finish/></txt><txt ptr="0xa898ae18" next="0xa898aea8" prev="0xa898ad88" upper="0xa6bfe0c8" lower="(nil)">****}else{<Finish/></txt><txt ptr="0xa898aea8" next="0xa898af38" prev="0xa898ae18" upper="0xa6bfe0c8" lower="(nil)">*****da+=hs[l/cs].fd(l%cs,cs-1,z);<Finish/></txt><txt ptr="0xa898af38" next="0xa898c00c" prev="0xa898aea8" upper="0xa6bfe0c8" lower="(nil)">*****da+=hs[r/cs].fd(0,r%cs,z);<Finish/></txt><txt ptr="0xa898c00c" next="0xa898c09c" prev="0xa898af38" upper="0xa6bfe0c8" lower="(nil)">*****for(int i=l/cs+1;i&lt;r/cs;i++)<Finish/></txt><txt ptr="0xa898c09c" next="0xa898c12c" prev="0xa898c00c" upper="0xa6bfe0c8" lower="(nil)">******da+=hs[i].fd(z);<Finish/></txt><txt ptr="0xa898c12c" next="(nil)" prev="0xa898c09c" upper="0xa6bfe0c8" lower="(nil)">*****printf(&quot;%d\n&quot;,da);*<Finish/></txt></body></column><column ptr="0xa6c00094" next="0xa6c000f8" prev="0xa6c00030" upper="0xa8978788" lower="0xa6bfe128"><body ptr="0xa6bfe128" next="(nil)" prev="(nil)" upper="0xa6c00094" lower="0xa898c1bc"><txt ptr="0xa898c1bc" next="0xa898c24c" prev="(nil)" upper="0xa6bfe128" lower="(nil)">****} <Finish/></txt><txt ptr="0xa898c24c" next="0xa898c2dc" prev="0xa898c1bc" upper="0xa6bfe128" lower="(nil)">***}<Finish/></txt><txt ptr="0xa898c2dc" next="0xa898c36c" prev="0xa898c24c" upper="0xa6bfe128" lower="(nil)">**}<Finish/></txt><txt ptr="0xa898c36c" next="0xa898c3fc" prev="0xa898c2dc" upper="0xa6bfe128" lower="(nil)">*}<Finish/></txt><txt ptr="0xa898c3fc" next="0xa898c48c" prev="0xa898c36c" upper="0xa6bfe128" lower="(nil)">}<Finish/></txt><txt ptr="0xa898c48c" next="0xa898c51c" prev="0xa898c3fc" upper="0xa6bfe128" lower="(nil)"> 树状数组<Finish/></txt><txt ptr="0xa898c51c" next="0xa898c5ac" prev="0xa898c48c" upper="0xa6bfe128" lower="(nil)">得到最低位的值<Finish/></txt><txt ptr="0xa898c5ac" next="0xa898c63c" prev="0xa898c51c" upper="0xa6bfe128" lower="(nil)">int Lowbit(int t){ return t &amp; -t;}<Finish/></txt><txt ptr="0xa898c63c" next="0xa898c6cc" prev="0xa898c5ac" upper="0xa6bfe128" lower="(nil)">一维情况<Finish/></txt><txt ptr="0xa898c6cc" next="0xa898c75c" prev="0xa898c63c" upper="0xa6bfe128" lower="(nil)">求区间和<Finish/></txt><txt ptr="0xa898c75c" next="0xa898c7ec" prev="0xa898c6cc" upper="0xa6bfe128" lower="(nil)">int musum(int end){// 复杂度O(logn)<Finish/></txt><txt ptr="0xa898c7ec" next="0xa898c87c" prev="0xa898c75c" upper="0xa6bfe128" lower="(nil)">    int sum = 0;<Finish/></txt><txt ptr="0xa898c87c" next="0xa898c90c" prev="0xa898c7ec" upper="0xa6bfe128" lower="(nil)">    while (end &gt; 0){<Finish/></txt><txt ptr="0xa898c90c" next="0xa898c99c" prev="0xa898c87c" upper="0xa6bfe128" lower="(nil)">         sum += m[end];<Finish/></txt><txt ptr="0xa898c99c" next="0xa898ca2c" prev="0xa898c90c" upper="0xa6bfe128" lower="(nil)">         end -= Lowbit(end);<Finish/></txt><txt ptr="0xa898ca2c" next="0xa898cabc" prev="0xa898c99c" upper="0xa6bfe128" lower="(nil)">    }<Finish/></txt><txt ptr="0xa898cabc" next="0xa898cb4c" prev="0xa898ca2c" upper="0xa6bfe128" lower="(nil)">     return sum;<Finish/></txt><txt ptr="0xa898cb4c" next="0xa898cbdc" prev="0xa898cabc" upper="0xa6bfe128" lower="(nil)">}<Finish/></txt><txt ptr="0xa898cbdc" next="0xa898cf3c" prev="0xa898cb4c" upper="0xa6bfe128" lower="(nil)">修改一个位置的值<Finish/></txt><txt ptr="0xa898cf3c" next="0xa898d010" prev="0xa898cbdc" upper="0xa6bfe128" lower="(nil)">void myplus(int pos){// 复杂度O(logn)<Finish/></txt><txt ptr="0xa898d010" next="0xa898d0a0" prev="0xa898cf3c" upper="0xa6bfe128" lower="(nil)">    while(pos &lt;= mx)<Finish/></txt><txt ptr="0xa898d0a0" next="0xa898d130" prev="0xa898d010" upper="0xa6bfe128" lower="(nil)">    {<Finish/></txt><txt ptr="0xa898d130" next="0xa898d1c0" prev="0xa898d0a0" upper="0xa6bfe128" lower="(nil)">         m[pos] ++;<Finish/></txt><txt ptr="0xa898d1c0" next="0xa898d250" prev="0xa898d130" upper="0xa6bfe128" lower="(nil)">         pos += Lowbit(pos);<Finish/></txt><txt ptr="0xa898d250" next="0xa898d2e0" prev="0xa898d1c0" upper="0xa6bfe128" lower="(nil)">    }<Finish/></txt><txt ptr="0xa898d2e0" next="(nil)" prev="0xa898d250" upper="0xa6bfe128" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa6c000f8" next="(nil)" prev="0xa6c00094" upper="0xa8978788" lower="0xa6bfe188"><body ptr="0xa6bfe188" next="(nil)" prev="(nil)" upper="0xa6c000f8" lower="0xa898d370"><txt ptr="0xa898d370" next="0xa898d400" prev="(nil)" upper="0xa6bfe188" lower="(nil)">得到某一个位置的值<Finish/></txt><txt ptr="0xa898d400" next="0xa898d490" prev="0xa898d370" upper="0xa6bfe188" lower="(nil)">int readSingle(int idx){*     int sum = tree[idx]; *             int z = idx - (idx &amp; -idx); *             idx--; *             while (idx != z){ *                     sum -= tree[idx]; *                     idx -= (idx &amp; -idx);*             }*     }*     return sum;*}<Finish/></txt><txt ptr="0xa898d490" next="0xa898d520" prev="0xa898d400" upper="0xa6bfe188" lower="(nil)"><Finish/></txt><txt ptr="0xa898d520" next="0xa898d5b0" prev="0xa898d490" upper="0xa6bfe188" lower="(nil)">二维情况<Finish/></txt><txt ptr="0xa898d5b0" next="0xa898d640" prev="0xa898d520" upper="0xa6bfe188" lower="(nil)">求区间和<Finish/></txt><txt ptr="0xa898d640" next="0xa898d6d0" prev="0xa898d5b0" upper="0xa6bfe188" lower="(nil)">int Sum(int i, int j){<Finish/></txt><txt ptr="0xa898d6d0" next="0xa898d760" prev="0xa898d640" upper="0xa6bfe188" lower="(nil)">*int tempj, sum = 0;<Finish/></txt><txt ptr="0xa898d760" next="0xa898d7f0" prev="0xa898d6d0" upper="0xa6bfe188" lower="(nil)">*while( i &gt; 0 ){<Finish/></txt><txt ptr="0xa898d7f0" next="0xa898d880" prev="0xa898d760" upper="0xa6bfe188" lower="(nil)">**tempj = j;<Finish/></txt><txt ptr="0xa898d880" next="0xa898d910" prev="0xa898d7f0" upper="0xa6bfe188" lower="(nil)">**while( tempj &gt; 0 ){<Finish/></txt><txt ptr="0xa898d910" next="0xa898d9a0" prev="0xa898d880" upper="0xa6bfe188" lower="(nil)">***sum += c[i][tempj];<Finish/></txt><txt ptr="0xa898d9a0" next="0xa898da30" prev="0xa898d910" upper="0xa6bfe188" lower="(nil)">***tempj -= Lowbit(tempj);<Finish/></txt><txt ptr="0xa898da30" next="0xa898dac0" prev="0xa898d9a0" upper="0xa6bfe188" lower="(nil)">**}<Finish/></txt><txt ptr="0xa898dac0" next="0xa898db50" prev="0xa898da30" upper="0xa6bfe188" lower="(nil)">**i -= Lowbit(i);<Finish/></txt><txt ptr="0xa898db50" next="0xa898dbe0" prev="0xa898dac0" upper="0xa6bfe188" lower="(nil)">*}<Finish/></txt><txt ptr="0xa898dbe0" next="0xa898dc70" prev="0xa898db50" upper="0xa6bfe188" lower="(nil)">return sum;<Finish/></txt><txt ptr="0xa898dc70" next="(nil)" prev="0xa898dbe0" upper="0xa6bfe188" lower="(nil)">}<Finish/></txt></body></column></section></body><footer ptr="0xa8998720" next="(nil)" prev="0xa99c8e44" upper="0xa8993910" lower="0xa999aab4"><txt ptr="0xa999aab4" next="0xa999ac64" prev="(nil)" upper="0xa8998720" lower="(nil)"><anchored><fly ptr="0xb55c028" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa999ab44"><txt ptr="0xa999ab44" next="0xa999abd4" prev="(nil)" upper="0xb55c028" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa999abd4" next="(nil)" prev="0xa999ab44" upper="0xb55c028" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="2"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="2"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa999ac64" next="(nil)" prev="0xa999aab4" upper="0xa8998720" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993984" next="0xa89939f8" prev="0xa8993910" upper="0xb0726b0" lower="0xa8996780"><header ptr="0xa8996780" next="0xa999c008" prev="(nil)" upper="0xa8993984" lower="0xa999d00c"><txt ptr="0xa999d00c" next="(nil)" prev="(nil)" upper="0xa8996780" lower="(nil)"><Finish/></txt></header><body ptr="0xa999c008" next="0xa8998780" prev="0xa8996780" upper="0xa8993984" lower="0xa8978608"><section ptr="0xa8978608" next="(nil)" prev="(nil)" upper="0xa999c008" lower="0xa6c00288" follow="0xa8978408" precede="0xa8978788"><column ptr="0xa6c00288" next="0xa6c002ec" prev="(nil)" upper="0xa8978608" lower="0xa6bfe308"><body ptr="0xa6bfe308" next="(nil)" prev="(nil)" upper="0xa6c00288" lower="0xa898dd00"><txt ptr="0xa898dd00" next="0xa898dd90" prev="(nil)" upper="0xa6bfe308" lower="(nil)">更新一个点<Finish/></txt><txt ptr="0xa898dd90" next="0xa898de20" prev="0xa898dd00" upper="0xa6bfe308" lower="(nil)">void Update(int i, int j, int num){<Finish/></txt><txt ptr="0xa898de20" next="0xa898deb0" prev="0xa898dd90" upper="0xa6bfe308" lower="(nil)">*int tempj;<Finish/></txt><txt ptr="0xa898deb0" next="0xa898df40" prev="0xa898de20" upper="0xa6bfe308" lower="(nil)">*while( i &lt;= Row ){<Finish/></txt><txt ptr="0xa898df40" next="0xa896e014" prev="0xa898deb0" upper="0xa6bfe308" lower="(nil)">**tempj = j;<Finish/></txt><txt ptr="0xa896e014" next="0xa896e0a4" prev="0xa898df40" upper="0xa6bfe308" lower="(nil)">**while( tempj &lt;= Col ){<Finish/></txt><txt ptr="0xa896e0a4" next="0xa896e134" prev="0xa896e014" upper="0xa6bfe308" lower="(nil)">***c[i][tempj] += num;<Finish/></txt><txt ptr="0xa896e134" next="0xa896e1c4" prev="0xa896e0a4" upper="0xa6bfe308" lower="(nil)">***tempj += Lowbit(tempj);<Finish/></txt><txt ptr="0xa896e1c4" next="0xa896e524" prev="0xa896e134" upper="0xa6bfe308" lower="(nil)">**}<Finish/></txt><txt ptr="0xa896e524" next="0xa896e5b4" prev="0xa896e1c4" upper="0xa6bfe308" lower="(nil)">**i += Lowbit(i);<Finish/></txt><txt ptr="0xa896e5b4" next="0xa896e644" prev="0xa896e524" upper="0xa6bfe308" lower="(nil)">*}<Finish/></txt><txt ptr="0xa896e644" next="0xa896e6d4" prev="0xa896e5b4" upper="0xa6bfe308" lower="(nil)">}<Finish/></txt><txt ptr="0xa896e6d4" next="0xa896e764" prev="0xa896e644" upper="0xa6bfe308" lower="(nil)">Treap树<Finish/></txt><txt ptr="0xa896e764" next="0xa896e7f4" prev="0xa896e6d4" upper="0xa6bfe308" lower="(nil)">Treap，就是有另一个随机数满足堆的性质的二叉搜索树，其结构相当于以随机顺序插入的二叉搜索树。<Finish/></txt><txt ptr="0xa896e7f4" next="0xa896e884" prev="0xa896e764" upper="0xa6bfe308" lower="(nil)">其基本操作的期望复杂度为O(log n)。<Finish/></txt><txt ptr="0xa896e884" next="0xa896e914" prev="0xa896e7f4" upper="0xa6bfe308" lower="(nil)">其特点是实现简单，效率高于伸展树并且支持大部分基本功能，性价比很高。<Finish/></txt><txt ptr="0xa896e914" next="0xa896e9a4" prev="0xa896e884" upper="0xa6bfe308" lower="(nil)">const int maxn = 100010;<Finish/></txt><txt ptr="0xa896e9a4" next="0xa896ea34" prev="0xa896e914" upper="0xa6bfe308" lower="(nil)">const int LEFT = 1;<Finish/></txt><txt ptr="0xa896ea34" next="0xa896eac4" prev="0xa896e9a4" upper="0xa6bfe308" lower="(nil)">const int RIGHT = 0;<Finish/></txt><txt ptr="0xa896eac4" next="0xa896eb54" prev="0xa896ea34" upper="0xa6bfe308" lower="(nil)"><Finish/></txt><txt ptr="0xa896eb54" next="0xa896ebe4" prev="0xa896eac4" upper="0xa6bfe308" lower="(nil)">int cnt = 1, rt = 0;<Finish/></txt><txt ptr="0xa896ebe4" next="0xa896ec74" prev="0xa896eb54" upper="0xa6bfe308" lower="(nil)"><Finish/></txt><txt ptr="0xa896ec74" next="0xa896ed04" prev="0xa896ebe4" upper="0xa6bfe308" lower="(nil)">struct Treap{<Finish/></txt><txt ptr="0xa896ed04" next="0xa896ed94" prev="0xa896ec74" upper="0xa6bfe308" lower="(nil)">    int key, val, pri, ch[2];<Finish/></txt><txt ptr="0xa896ed94" next="(nil)" prev="0xa896ed04" upper="0xa6bfe308" lower="(nil)">    void set(int&amp; _key, int&amp; _val, int _pri){<Finish/></txt></body></column><column ptr="0xa6c002ec" next="0xa6c00350" prev="0xa6c00288" upper="0xa8978608" lower="0xa6bfe368"><body ptr="0xa6bfe368" next="(nil)" prev="(nil)" upper="0xa6c002ec" lower="0xa896ee24"><txt ptr="0xa896ee24" next="0xa896eeb4" prev="(nil)" upper="0xa6bfe368" lower="(nil)">        key = _key, val = _val, pri = _pri, ch[0] = ch[1] = 0;<Finish/></txt><txt ptr="0xa896eeb4" next="0xa896ef44" prev="0xa896ee24" upper="0xa6bfe368" lower="(nil)">    }<Finish/></txt><txt ptr="0xa896ef44" next="0xa896f018" prev="0xa896eeb4" upper="0xa6bfe368" lower="(nil)">}treap[maxn];<Finish/></txt><txt ptr="0xa896f018" next="0xa896f0a8" prev="0xa896ef44" upper="0xa6bfe368" lower="(nil)"><Finish/></txt><txt ptr="0xa896f0a8" next="0xa896f138" prev="0xa896f018" upper="0xa6bfe368" lower="(nil)"><Finish/></txt><txt ptr="0xa896f138" next="0xa896f1c8" prev="0xa896f0a8" upper="0xa6bfe368" lower="(nil)">void rotate(int&amp; node, int f){<Finish/></txt><txt ptr="0xa896f1c8" next="0xa896f258" prev="0xa896f138" upper="0xa6bfe368" lower="(nil)">    int pre_node =treap[node].ch[!f];<Finish/></txt><txt ptr="0xa896f258" next="0xa896f2e8" prev="0xa896f1c8" upper="0xa6bfe368" lower="(nil)">    treap[node].ch[!f] = treap[pre_node].ch[f];<Finish/></txt><txt ptr="0xa896f2e8" next="0xa896f378" prev="0xa896f258" upper="0xa6bfe368" lower="(nil)">    treap[node].ch[f] = node;<Finish/></txt><txt ptr="0xa896f378" next="0xa896f408" prev="0xa896f2e8" upper="0xa6bfe368" lower="(nil)">    node = pre_node;<Finish/></txt><txt ptr="0xa896f408" next="0xa896f498" prev="0xa896f378" upper="0xa6bfe368" lower="(nil)">}<Finish/></txt><txt ptr="0xa896f498" next="0xa896f528" prev="0xa896f408" upper="0xa6bfe368" lower="(nil)"><Finish/></txt><txt ptr="0xa896f528" next="0xa896f5b8" prev="0xa896f498" upper="0xa6bfe368" lower="(nil)">void insert(int&amp; x, int&amp; key, int&amp; val){<Finish/></txt><txt ptr="0xa896f5b8" next="0xa896f648" prev="0xa896f528" upper="0xa6bfe368" lower="(nil)">    if(x == 0){<Finish/></txt><txt ptr="0xa896f648" next="0xa896f6d8" prev="0xa896f5b8" upper="0xa6bfe368" lower="(nil)">        treap[x = cnt++].set(key,val,rand());<Finish/></txt><txt ptr="0xa896f6d8" next="0xa896f768" prev="0xa896f648" upper="0xa6bfe368" lower="(nil)">    }else{<Finish/></txt><txt ptr="0xa896f768" next="0xa896fac8" prev="0xa896f6d8" upper="0xa6bfe368" lower="(nil)">        int f = key &lt; treap[x].key;<Finish/></txt><txt ptr="0xa896fac8" next="0xa896fb58" prev="0xa896f768" upper="0xa6bfe368" lower="(nil)">        insert(treap[x].ch[!f], key, val);<Finish/></txt><txt ptr="0xa896fb58" next="0xa896fbe8" prev="0xa896fac8" upper="0xa6bfe368" lower="(nil)">        if(treap[x].pri &lt; treap[ treap[x].ch[!f] ].pri){<Finish/></txt><txt ptr="0xa896fbe8" next="0xa896fc78" prev="0xa896fb58" upper="0xa6bfe368" lower="(nil)">            rotate(x,f);<Finish/></txt><txt ptr="0xa896fc78" next="0xa896fd08" prev="0xa896fbe8" upper="0xa6bfe368" lower="(nil)">        }<Finish/></txt><txt ptr="0xa896fd08" next="0xa896fd98" prev="0xa896fc78" upper="0xa6bfe368" lower="(nil)">    }<Finish/></txt><txt ptr="0xa896fd98" next="0xa896fe28" prev="0xa896fd08" upper="0xa6bfe368" lower="(nil)">}<Finish/></txt><txt ptr="0xa896fe28" next="0xa896feb8" prev="0xa896fd98" upper="0xa6bfe368" lower="(nil)"><Finish/></txt><txt ptr="0xa896feb8" next="0xa896ff48" prev="0xa896fe28" upper="0xa6bfe368" lower="(nil)">int get(int x, int f){<Finish/></txt><txt ptr="0xa896ff48" next="0xa897101c" prev="0xa896feb8" upper="0xa6bfe368" lower="(nil)">    while(treap[x].ch[f]){<Finish/></txt><txt ptr="0xa897101c" next="0xa89710ac" prev="0xa896ff48" upper="0xa6bfe368" lower="(nil)">        x = treap[x].ch[f];<Finish/></txt><txt ptr="0xa89710ac" next="(nil)" prev="0xa897101c" upper="0xa6bfe368" lower="(nil)">    }<Finish/></txt></body></column><column ptr="0xa6c00350" next="(nil)" prev="0xa6c002ec" upper="0xa8978608" lower="0xa6bfe3c8"><body ptr="0xa6bfe3c8" next="(nil)" prev="(nil)" upper="0xa6c00350" lower="0xa897113c"><txt ptr="0xa897113c" next="0xa89711cc" prev="(nil)" upper="0xa6bfe3c8" lower="(nil)">    return f;<Finish/></txt><txt ptr="0xa89711cc" next="0xa897125c" prev="0xa897113c" upper="0xa6bfe3c8" lower="(nil)">}<Finish/></txt><txt ptr="0xa897125c" next="0xa89712ec" prev="0xa89711cc" upper="0xa6bfe3c8" lower="(nil)"><Finish/></txt><txt ptr="0xa89712ec" next="0xa897137c" prev="0xa897125c" upper="0xa6bfe3c8" lower="(nil)"><Finish/></txt><txt ptr="0xa897137c" next="0xa897140c" prev="0xa89712ec" upper="0xa6bfe3c8" lower="(nil)"><Finish/></txt><txt ptr="0xa897140c" next="0xa897149c" prev="0xa897137c" upper="0xa6bfe3c8" lower="(nil)">void del(int &amp;x, int key){<Finish/></txt><txt ptr="0xa897149c" next="0xa897152c" prev="0xa897140c" upper="0xa6bfe3c8" lower="(nil)">    if(treap[x].key == key){<Finish/></txt><txt ptr="0xa897152c" next="0xa89715bc" prev="0xa897149c" upper="0xa6bfe3c8" lower="(nil)">        if(!treap[x].ch[0] || !treap[x].ch[1]){<Finish/></txt><txt ptr="0xa89715bc" next="0xa897164c" prev="0xa897152c" upper="0xa6bfe3c8" lower="(nil)">            if(!treap[x].ch[0]){<Finish/></txt><txt ptr="0xa897164c" next="0xa89716dc" prev="0xa89715bc" upper="0xa6bfe3c8" lower="(nil)">                x = treap[x].ch[1];<Finish/></txt><txt ptr="0xa89716dc" next="0xa897176c" prev="0xa897164c" upper="0xa6bfe3c8" lower="(nil)">            }else{<Finish/></txt><txt ptr="0xa897176c" next="0xa89717fc" prev="0xa89716dc" upper="0xa6bfe3c8" lower="(nil)">                x = treap[x].ch[0];<Finish/></txt><txt ptr="0xa89717fc" next="0xa897188c" prev="0xa897176c" upper="0xa6bfe3c8" lower="(nil)">            }<Finish/></txt><txt ptr="0xa897188c" next="0xa897191c" prev="0xa89717fc" upper="0xa6bfe3c8" lower="(nil)">        }else{<Finish/></txt><txt ptr="0xa897191c" next="0xa89719ac" prev="0xa897188c" upper="0xa6bfe3c8" lower="(nil)">            int f = treap[ treap[x].ch[0] ].pri &gt; treap[ treap[x].ch[1] ].pri;<Finish/></txt><txt ptr="0xa89719ac" next="0xa8971a3c" prev="0xa897191c" upper="0xa6bfe3c8" lower="(nil)">            rotate(x, f);<Finish/></txt><txt ptr="0xa8971a3c" next="0xa8971acc" prev="0xa89719ac" upper="0xa6bfe3c8" lower="(nil)">            del(treap[x].ch[f], key);<Finish/></txt><txt ptr="0xa8971acc" next="0xa8971b5c" prev="0xa8971a3c" upper="0xa6bfe3c8" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8971b5c" next="0xa8971bec" prev="0xa8971acc" upper="0xa6bfe3c8" lower="(nil)">    }else{<Finish/></txt><txt ptr="0xa8971bec" next="0xa8971c7c" prev="0xa8971b5c" upper="0xa6bfe3c8" lower="(nil)">        int f = treap[x].key &gt; key;<Finish/></txt><txt ptr="0xa8971c7c" next="0xa8971d0c" prev="0xa8971bec" upper="0xa6bfe3c8" lower="(nil)">        del(treap[x].ch[!f], key);<Finish/></txt><txt ptr="0xa8971d0c" next="0xa89720b0" prev="0xa8971c7c" upper="0xa6bfe3c8" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89720b0" next="0xa8972140" prev="0xa8971d0c" upper="0xa6bfe3c8" lower="(nil)">}<Finish/></txt><txt ptr="0xa8972140" next="0xa89721d0" prev="0xa89720b0" upper="0xa6bfe3c8" lower="(nil)"><Finish/></txt><txt ptr="0xa89721d0" next="0xa8972260" prev="0xa8972140" upper="0xa6bfe3c8" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa8972260" next="0xa89722f0" prev="0xa89721d0" upper="0xa6bfe3c8" lower="(nil)">    int key,val;<Finish/></txt><txt ptr="0xa89722f0" next="(nil)" prev="0xa8972260" upper="0xa6bfe3c8" lower="(nil)">    insert(rt, key, val);//插入元素<Finish/></txt></body></column></section></body><footer ptr="0xa8998780" next="(nil)" prev="0xa999c008" upper="0xa8993984" lower="0xa999d09c"><txt ptr="0xa999d09c" next="0xa999d24c" prev="(nil)" upper="0xa8998780" lower="(nil)"><anchored><fly ptr="0xb861870" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa999d12c"><txt ptr="0xa999d12c" next="0xa999d1bc" prev="(nil)" upper="0xb861870" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa999d1bc" next="(nil)" prev="0xa999d12c" upper="0xb861870" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="2"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="3"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa999d24c" next="(nil)" prev="0xa999d09c" upper="0xa8998780" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa89939f8" next="0xa8993a6c" prev="0xa8993984" upper="0xb0726b0" lower="0xa89967e0"><header ptr="0xa89967e0" next="0xa999c188" prev="(nil)" upper="0xa89939f8" lower="0xa999e5b0"><txt ptr="0xa999e5b0" next="(nil)" prev="(nil)" upper="0xa89967e0" lower="(nil)"><Finish/></txt></header><body ptr="0xa999c188" next="0xa89987e0" prev="0xa89967e0" upper="0xa89939f8" lower="0xa8978408"><section ptr="0xa8978408" next="(nil)" prev="(nil)" upper="0xa999c188" lower="0xa6c004e0" follow="0xa8978b88" precede="0xa8978608"><column ptr="0xa6c004e0" next="0xa6c00544" prev="(nil)" upper="0xa8978408" lower="0xa6bfe548"><body ptr="0xa6bfe548" next="(nil)" prev="(nil)" upper="0xa6c004e0" lower="0xa8972380"><txt ptr="0xa8972380" next="0xa8972410" prev="(nil)" upper="0xa6bfe548" lower="(nil)">    get(rt, 1);//最大值<Finish/></txt><txt ptr="0xa8972410" next="0xa89724a0" prev="0xa8972380" upper="0xa6bfe548" lower="(nil)">    get(rt, 0);//最小值<Finish/></txt><txt ptr="0xa89724a0" next="0xa8972530" prev="0xa8972410" upper="0xa6bfe548" lower="(nil)">    del(rt,treap[x].key);<Finish/></txt><txt ptr="0xa8972530" next="0xa89725c0" prev="0xa89724a0" upper="0xa6bfe548" lower="(nil)"><Finish/></txt><txt ptr="0xa89725c0" next="0xa8972650" prev="0xa8972530" upper="0xa6bfe548" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa8972650" next="0xa89726e0" prev="0xa89725c0" upper="0xa6bfe548" lower="(nil)">}<Finish/></txt><txt ptr="0xa89726e0" next="0xa8972770" prev="0xa8972650" upper="0xa6bfe548" lower="(nil)"><Finish/></txt><txt ptr="0xa8972770" next="0xa8972800" prev="0xa89726e0" upper="0xa6bfe548" lower="(nil)">DP分类<Finish/></txt><txt ptr="0xa8972800" next="0xa8972890" prev="0xa8972770" upper="0xa6bfe548" lower="(nil)">f(i,j) =min{f(i,k) + f(k,j) + g(i,k,j) },(i&lt;=k&lt;=j)<Finish/></txt><txt ptr="0xa8972890" next="0xa8972920" prev="0xa8972800" upper="0xa6bfe548" lower="(nil)">一般，g(i,k,j)为一常数<Finish/></txt><txt ptr="0xa8972920" next="0xa89729b0" prev="0xa8972890" upper="0xa6bfe548" lower="(nil)">分析：从f(0,0)到f(n,n)需要双重循环，在每次循环时又要花费O(n)的时间去找最小值，故总复杂度O(n^3)<Finish/></txt><txt ptr="0xa89729b0" next="0xa8972a40" prev="0xa8972920" upper="0xa6bfe548" lower="(nil)">例如：矩阵连乘<Finish/></txt><txt ptr="0xa8972a40" next="0xa8972ad0" prev="0xa89729b0" upper="0xa6bfe548" lower="(nil)"><Finish/></txt><txt ptr="0xa8972ad0" next="0xa8972b60" prev="0xa8972a40" upper="0xa6bfe548" lower="(nil)">单调队列<Finish/></txt><txt ptr="0xa8972b60" next="0xa8972bf0" prev="0xa8972ad0" upper="0xa6bfe548" lower="(nil)">而单调队列的方程为：<Finish/></txt><txt ptr="0xa8972bf0" next="0xa8972c80" prev="0xa8972b60" upper="0xa6bfe548" lower="(nil)">f(x)= opt( cost[i] ) * bound[x] &lt;=i&lt;x;<Finish/></txt><txt ptr="0xa8972c80" next="0xa8972d10" prev="0xa8972bf0" upper="0xa6bfe548" lower="(nil)"><anchored><fly ptr="0xa52d2d0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa52d458"><txt ptr="0xa52d458" next="(nil)" prev="(nil)" upper="0xa52d2d0" lower="(nil)"/></fly></anchored>在这样一种状态量为O(n)，决策量为O(n)，直接求解复杂度为O(n2)的动态规划问题中，如果状态x转移到状态y的代价为w[x,y]，只要满足，那么这个动态规划的问题的决策就是单调的。这就是四边形不等式的原理。<Finish/></txt><txt ptr="0xa8972d10" next="0xa8972da0" prev="0xa8972c80" upper="0xa6bfe548" lower="(nil)"><Finish/></txt><txt ptr="0xa8972da0" next="(nil)" prev="0xa8972d10" upper="0xa6bfe548" lower="(nil)">另一种形式<Finish/></txt></body></column><column ptr="0xa6c00544" next="0xa6c005a8" prev="0xa6c004e0" upper="0xa8978408" lower="0xa6bfe5a8"><body ptr="0xa6bfe5a8" next="(nil)" prev="(nil)" upper="0xa6c00544" lower="0xa8972e30"><txt ptr="0xa8972e30" next="0xa8972ec0" prev="(nil)" upper="0xa6bfe5a8" lower="(nil)"> f[x] = max or min{g(k) | b[x] &lt;= k &lt; x} + w[x]<Finish/></txt><txt ptr="0xa8972ec0" next="0xa8972f50" prev="0xa8972e30" upper="0xa6bfe5a8" lower="(nil)">　　(其中b[x]随x单调不降，即b[1]&lt;=b[2]&lt;=b[3]&lt;=...&lt;=b[n])<Finish/></txt><txt ptr="0xa8972f50" next="0xa8973024" prev="0xa8972ec0" upper="0xa6bfe5a8" lower="(nil)">　　(g[k]表示一个和k或f[k]有关的函数，w[x]表示一个和x有关的函数)<Finish/></txt><txt ptr="0xa8973024" next="0xa89730b4" prev="0xa8972f50" upper="0xa6bfe5a8" lower="(nil)"><Finish/></txt><txt ptr="0xa89730b4" next="0xa8973144" prev="0xa8973024" upper="0xa6bfe5a8" lower="(nil)">排列组合<Finish/></txt><txt ptr="0xa8973144" next="0xa89731d4" prev="0xa89730b4" upper="0xa6bfe5a8" lower="(nil)">A(n,r)=n(n-1)…(n-r+1)=n!/(n-r)!<Finish/></txt><txt ptr="0xa89731d4" next="0xa8973264" prev="0xa8973144" upper="0xa6bfe5a8" lower="(nil)">C(n,r)=A(n,r)/r! = n! /((n-r)! r!)<Finish/></txt><txt ptr="0xa8973264" next="0xa89732f4" prev="0xa89731d4" upper="0xa6bfe5a8" lower="(nil)">C(n,r)=C(n,n-r)<Finish/></txt><txt ptr="0xa89732f4" next="0xa8973654" prev="0xa8973264" upper="0xa6bfe5a8" lower="(nil)">C(n,r)=C(n-1,r)+C(n-1,r-1)<Finish/></txt><txt ptr="0xa8973654" next="0xa89736e4" prev="0xa89732f4" upper="0xa6bfe5a8" lower="(nil)">C(n+r+1,r)=C(n+r,r)+C(n+r-1,r-1)+…+C(n+1,1)+C(n,0)<Finish/></txt><txt ptr="0xa89736e4" next="0xa8973774" prev="0xa8973654" upper="0xa6bfe5a8" lower="(nil)">C(n,k)C(k,r)=C(n,r)C(n-r,k-r)<Finish/></txt><txt ptr="0xa8973774" next="0xa8973804" prev="0xa89736e4" upper="0xa6bfe5a8" lower="(nil)">重复排列：n^r<Finish/></txt><txt ptr="0xa8973804" next="0xa8973894" prev="0xa8973774" upper="0xa6bfe5a8" lower="(nil)">重复组合：C(n+r-1,r)<Finish/></txt><txt ptr="0xa8973894" next="0xa8973924" prev="0xa8973804" upper="0xa6bfe5a8" lower="(nil)">圆周排列：A(n,r)/r<Finish/></txt><txt ptr="0xa8973924" next="0xa89739b4" prev="0xa8973894" upper="0xa6bfe5a8" lower="(nil)"><Finish/></txt><txt ptr="0xa89739b4" next="0xa8973a44" prev="0xa8973924" upper="0xa6bfe5a8" lower="(nil)"><Finish/></txt><txt ptr="0xa8973a44" next="0xa8973ad4" prev="0xa89739b4" upper="0xa6bfe5a8" lower="(nil)">组合C（m,n）<Finish/></txt><txt ptr="0xa8973ad4" next="0xa8973b64" prev="0xa8973a44" upper="0xa6bfe5a8" lower="(nil)">const int N=100;<Finish/></txt><txt ptr="0xa8973b64" next="0xa8973bf4" prev="0xa8973ad4" upper="0xa6bfe5a8" lower="(nil)">int str[N][N];//初始化为-1 <Finish/></txt><txt ptr="0xa8973bf4" next="0xa8973c84" prev="0xa8973b64" upper="0xa6bfe5a8" lower="(nil)">int fun(int m,int n){<Finish/></txt><txt ptr="0xa8973c84" next="0xa8973d14" prev="0xa8973bf4" upper="0xa6bfe5a8" lower="(nil)">*if(str[m][n]!=-1)return str[m][n];<Finish/></txt><txt ptr="0xa8973d14" next="0xa8973da4" prev="0xa8973c84" upper="0xa6bfe5a8" lower="(nil)">*if(m==n || n==0)return str[m][n]=1;<Finish/></txt><txt ptr="0xa8973da4" next="0xa8973e34" prev="0xa8973d14" upper="0xa6bfe5a8" lower="(nil)">*if(m&lt;n)return str[m][n]=0;<Finish/></txt><txt ptr="0xa8973e34" next="0xa8973ec4" prev="0xa8973da4" upper="0xa6bfe5a8" lower="(nil)">*return str[m][n]=fun(m-1,n-1)+fun(m-1,n);*<Finish/></txt><txt ptr="0xa8973ec4" next="(nil)" prev="0xa8973e34" upper="0xa6bfe5a8" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa6c005a8" next="(nil)" prev="0xa6c00544" upper="0xa8978408" lower="0xa6bfe608"><body ptr="0xa6bfe608" next="(nil)" prev="(nil)" upper="0xa6c005a8" lower="0xa8973f54"><txt ptr="0xa8973f54" next="0xa8974028" prev="(nil)" upper="0xa6bfe608" lower="(nil)">有n种物品，并且知道每种物品的数量。（可以用母函数）<Finish/></txt><txt ptr="0xa8974028" next="0xa89740b8" prev="0xa8973f54" upper="0xa6bfe608" lower="(nil)">要求从中选出m件物品的排列数。<Finish/></txt><txt ptr="0xa89740b8" next="0xa8974148" prev="0xa8974028" upper="0xa6bfe608" lower="(nil)">INT dp(int n,int m){<Finish/></txt><txt ptr="0xa8974148" next="0xa89741d8" prev="0xa89740b8" upper="0xa6bfe608" lower="(nil)">*if(str1[n][m]!=-1)return str1[n][m];<Finish/></txt><txt ptr="0xa89741d8" next="0xa8974268" prev="0xa8974148" upper="0xa6bfe608" lower="(nil)">*if(m==0)return str1[n][m]=1;<Finish/></txt><txt ptr="0xa8974268" next="0xa89742f8" prev="0xa89741d8" upper="0xa6bfe608" lower="(nil)">*if(n==0)return str1[n][m]=0;<Finish/></txt><txt ptr="0xa89742f8" next="0xa8974388" prev="0xa8974268" upper="0xa6bfe608" lower="(nil)">*INT ans=0;<Finish/></txt><txt ptr="0xa8974388" next="0xa8974418" prev="0xa89742f8" upper="0xa6bfe608" lower="(nil)">*int end=min(str0[n],m);<Finish/></txt><txt ptr="0xa8974418" next="0xa89744a8" prev="0xa8974388" upper="0xa6bfe608" lower="(nil)">*for(int i=0;i&lt;=end;i++){<Finish/></txt><txt ptr="0xa89744a8" next="0xa8974538" prev="0xa8974418" upper="0xa6bfe608" lower="(nil)">**ans+=dp(n-1,m-i)*fun(m,i);<Finish/></txt><txt ptr="0xa8974538" next="0xa89745c8" prev="0xa89744a8" upper="0xa6bfe608" lower="(nil)">*}<Finish/></txt><txt ptr="0xa89745c8" next="0xa8974658" prev="0xa8974538" upper="0xa6bfe608" lower="(nil)">*return str1[n][m]=ans;<Finish/></txt><txt ptr="0xa8974658" next="0xa89746e8" prev="0xa89745c8" upper="0xa6bfe608" lower="(nil)">} <Finish/></txt><txt ptr="0xa89746e8" next="0xa8974778" prev="0xa8974658" upper="0xa6bfe608" lower="(nil)">要求从中选出m件物品的组合数。<Finish/></txt><txt ptr="0xa8974778" next="0xa8974808" prev="0xa89746e8" upper="0xa6bfe608" lower="(nil)">PS:只需把上面的fun(m,i)去掉即可。<Finish/></txt><txt ptr="0xa8974808" next="0xa8974898" prev="0xa8974778" upper="0xa6bfe608" lower="(nil)">错排<Finish/></txt><txt ptr="0xa8974898" next="0xa8974bf8" prev="0xa8974808" upper="0xa6bfe608" lower="(nil)">n个不同的元素，重新排列，使的每个元素不在原来的位置。<Finish/></txt><txt ptr="0xa8974bf8" next="0xa8974c88" prev="0xa8974898" upper="0xa6bfe608" lower="(nil)">分析：当n个编号元素放在n个编号位置，元素编号与位置编号不相同时，方法数记为M(n).<Finish/></txt><txt ptr="0xa8974c88" next="0xa8974d18" prev="0xa8974bf8" upper="0xa6bfe608" lower="(nil)">第一步：把第n个元素放在一个位置，比如位置k，共有n-1中方法；<Finish/></txt><txt ptr="0xa8974d18" next="0xa8974da8" prev="0xa8974c88" upper="0xa6bfe608" lower="(nil)">第二步，放编号为k的元素，这是有两种情况：1.放到位置n,那么，剩下的n-2个元素的方法数为M(n-2)；<Finish/></txt><txt ptr="0xa8974da8" next="(nil)" prev="0xa8974d18" upper="0xa6bfe608" lower="(nil)">不把它放在位置n，这是，对于这n-2个元素，有M(n-1)中方法。<Finish/></txt></body></column></section></body><footer ptr="0xa89987e0" next="(nil)" prev="0xa999c188" upper="0xa89939f8" lower="0xa999e640"><txt ptr="0xa999e640" next="0xa999e7f0" prev="(nil)" upper="0xa89987e0" lower="(nil)"><anchored><fly ptr="0xb55c348" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa999e6d0"><txt ptr="0xa999e6d0" next="0xa999e760" prev="(nil)" upper="0xb55c348" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa999e760" next="(nil)" prev="0xa999e6d0" upper="0xb55c348" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="2"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="4"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa999e7f0" next="(nil)" prev="0xa999e640" upper="0xa89987e0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993a6c" next="0xa8993ae0" prev="0xa89939f8" upper="0xb0726b0" lower="0xa8996840"><header ptr="0xa8996840" next="0xa999c308" prev="(nil)" upper="0xa8993a6c" lower="0xa999fb54"><txt ptr="0xa999fb54" next="(nil)" prev="(nil)" upper="0xa8996840" lower="(nil)"><Finish/></txt></header><body ptr="0xa999c308" next="0xa8998840" prev="0xa8996840" upper="0xa8993a6c" lower="0xa8978b88"><section ptr="0xa8978b88" next="(nil)" prev="(nil)" upper="0xa999c308" lower="0xa895552c" follow="0xa8978188" precede="0xa8978408"><column ptr="0xa895552c" next="0xa8955590" prev="(nil)" upper="0xa8978b88" lower="0xa895d080"><body ptr="0xa895d080" next="(nil)" prev="(nil)" upper="0xa895552c" lower="0xa8974e38"><txt ptr="0xa8974e38" next="0xa8974ec8" prev="(nil)" upper="0xa895d080" lower="(nil)">故。M(n) = (n-1)( M(n-2) +M(n-1) ),M(1)=0,M(2)=1;<Finish/></txt><txt ptr="0xa8974ec8" next="0xa8974f58" prev="0xa8974e38" upper="0xa895d080" lower="(nil)"><Finish/></txt><txt ptr="0xa8974f58" next="0xa8975000" prev="0xa8974ec8" upper="0xa895d080" lower="(nil)"><Finish/></txt><txt ptr="0xa8975000" next="0xa8975090" prev="0xa8974f58" upper="0xa895d080" lower="(nil)">整数拆分<Finish/></txt><txt ptr="0xa8975090" next="0xa8975120" prev="0xa8975000" upper="0xa895d080" lower="(nil)">1.整数拆分成不同整数的和的拆分数等于拆分成奇数的拆分数。<Finish/></txt><txt ptr="0xa8975120" next="0xa89751b0" prev="0xa8975090" upper="0xa895d080" lower="(nil)">2.N被拆分成一些重复次数不超过k次的整数的和，棋拆分数等于被拆分成不被k+1除尽的数的和的拆分数。<Finish/></txt><txt ptr="0xa89751b0" next="0xa8975240" prev="0xa8975120" upper="0xa895d080" lower="(nil)">3.整数n拆分成k个数的和的拆分数等于n拆分成最大数为k的拆分数。<Finish/></txt><txt ptr="0xa8975240" next="0xa89752d0" prev="0xa89751b0" upper="0xa895d080" lower="(nil)">4.整数n拆分成最多不超过m个数的和的拆分数等于n拆分成最大不超过m的拆分数。<Finish/></txt><txt ptr="0xa89752d0" next="0xa8975360" prev="0xa8975240" upper="0xa895d080" lower="(nil)">5.正整数n拆分成不超过k个数的和的拆分数，等于将n+k拆分成恰好k个数的拆分数。<Finish/></txt><txt ptr="0xa8975360" next="0xa89753f0" prev="0xa89752d0" upper="0xa895d080" lower="(nil)"><Finish/></txt><txt ptr="0xa89753f0" next="0xa8975480" prev="0xa8975360" upper="0xa895d080" lower="(nil)">//fun1(n,m)定义为整数m拆分的数最小为n <Finish/></txt><txt ptr="0xa8975480" next="0xa8975510" prev="0xa89753f0" upper="0xa895d080" lower="(nil)">int fun1(int n,int m){<Finish/></txt><txt ptr="0xa8975510" next="0xa89755a0" prev="0xa8975480" upper="0xa895d080" lower="(nil)"><Finish/></txt><txt ptr="0xa89755a0" next="0xa8975630" prev="0xa8975510" upper="0xa895d080" lower="(nil)">*if(str1[n][m]!=-1)return str1[n][m];<Finish/></txt><txt ptr="0xa8975630" next="0xa89756c0" prev="0xa89755a0" upper="0xa895d080" lower="(nil)">*<Finish/></txt><txt ptr="0xa89756c0" next="0xa8975750" prev="0xa8975630" upper="0xa895d080" lower="(nil)">*if(n==m)return str1[n][m]=1;<Finish/></txt><txt ptr="0xa8975750" next="0xa89757e0" prev="0xa89756c0" upper="0xa895d080" lower="(nil)">*if(n&gt;m)return str1[n][m]=0;<Finish/></txt><txt ptr="0xa89757e0" next="0xa8975870" prev="0xa8975750" upper="0xa895d080" lower="(nil)">*return str1[n][m]=fun1(n,m-n)+fun1(n+1,m); <Finish/></txt><txt ptr="0xa8975870" next="0xa8975900" prev="0xa89757e0" upper="0xa895d080" lower="(nil)">*<Finish/></txt><txt ptr="0xa8975900" next="0xa8975990" prev="0xa8975870" upper="0xa895d080" lower="(nil)">* return str1[n][m];   <Finish/></txt><txt ptr="0xa8975990" next="(nil)" prev="0xa8975900" upper="0xa895d080" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa8955590" next="0xa89555f4" prev="0xa895552c" upper="0xa8978b88" lower="0xa895d0e0"><body ptr="0xa895d0e0" next="(nil)" prev="(nil)" upper="0xa8955590" lower="0xa8975a20"><txt ptr="0xa8975a20" next="0xa8975ab0" prev="(nil)" upper="0xa895d0e0" lower="(nil)">// fun2(n,m)定义为整数m拆分的数最大为n <Finish/></txt><txt ptr="0xa8975ab0" next="0xa8975b40" prev="0xa8975a20" upper="0xa895d0e0" lower="(nil)">int fun2(int n,int m){<Finish/></txt><txt ptr="0xa8975b40" next="0xa8975bd0" prev="0xa8975ab0" upper="0xa895d0e0" lower="(nil)">*if(str2[n][m]!=-1)return str2[n][m];<Finish/></txt><txt ptr="0xa8975bd0" next="0xa8975c60" prev="0xa8975b40" upper="0xa895d0e0" lower="(nil)">*<Finish/></txt><txt ptr="0xa8975c60" next="0xa8975cf0" prev="0xa8975bd0" upper="0xa895d0e0" lower="(nil)">*if(m==0)return str2[n][m]=1;<Finish/></txt><txt ptr="0xa8975cf0" next="0xa8975d80" prev="0xa8975c60" upper="0xa895d0e0" lower="(nil)">*if(n==0)return str2[n][m]=0;<Finish/></txt><txt ptr="0xa8975d80" next="0xa8975e10" prev="0xa8975cf0" upper="0xa895d0e0" lower="(nil)">* <Finish/></txt><txt ptr="0xa8975e10" next="0xa89761b4" prev="0xa8975d80" upper="0xa895d0e0" lower="(nil)">*if(n&gt;m)return str2[n][m]=fun2(m,m); <Finish/></txt><txt ptr="0xa89761b4" next="0xa8976244" prev="0xa8975e10" upper="0xa895d0e0" lower="(nil)">*return  str2[n][m]=fun2(n,m-n)+fun2(n-1,m); <Finish/></txt><txt ptr="0xa8976244" next="0xa89762d4" prev="0xa89761b4" upper="0xa895d0e0" lower="(nil)">}<Finish/></txt><txt ptr="0xa89762d4" next="0xa8976364" prev="0xa8976244" upper="0xa895d0e0" lower="(nil)">集合拆分<Finish/></txt><txt ptr="0xa8976364" next="0xa89763f4" prev="0xa89762d4" upper="0xa895d0e0" lower="(nil)">n个不同的数，分成m份，每份至少一个<Finish/></txt><txt ptr="0xa89763f4" next="0xa8976484" prev="0xa8976364" upper="0xa895d0e0" lower="(nil)">S(n , k) = S(n-1 , k-1) + k* S(n-1 , k) n&gt;1,k&gt;=1<Finish/></txt><txt ptr="0xa8976484" next="0xa8976514" prev="0xa89763f4" upper="0xa895d0e0" lower="(nil)"><Finish/></txt><txt ptr="0xa8976514" next="0xa89765a4" prev="0xa8976484" upper="0xa895d0e0" lower="(nil)">n个相同的球<Finish/></txt><txt ptr="0xa89765a4" next="0xa8976634" prev="0xa8976514" upper="0xa895d0e0" lower="(nil)">放进m个相同的盒子里<Finish/></txt><txt ptr="0xa8976634" next="0xa89766c4" prev="0xa89765a4" upper="0xa895d0e0" lower="(nil)">至少一个<Finish/></txt><txt ptr="0xa89766c4" next="0xa8976754" prev="0xa8976634" upper="0xa895d0e0" lower="(nil)">整数拆分：分为第一个数是1和不是1讨论<Finish/></txt><txt ptr="0xa8976754" next="0xa89767e4" prev="0xa89766c4" upper="0xa895d0e0" lower="(nil)">S1 [n,m]= S1 [n-1,m-1]+ S1 [n-m,m]<Finish/></txt><txt ptr="0xa89767e4" next="0xa8976874" prev="0xa8976754" upper="0xa895d0e0" lower="(nil)">可以为空<Finish/></txt><txt ptr="0xa8976874" next="0xa8976904" prev="0xa89767e4" upper="0xa895d0e0" lower="(nil)">整数拆分：S1 [n+m,m]<Finish/></txt><txt ptr="0xa8976904" next="0xa8976994" prev="0xa8976874" upper="0xa895d0e0" lower="(nil)">放进m个不同的盒子里<Finish/></txt><txt ptr="0xa8976994" next="0xa8976a24" prev="0xa8976904" upper="0xa895d0e0" lower="(nil)">至少一个<Finish/></txt><txt ptr="0xa8976a24" next="0xa8976ab4" prev="0xa8976994" upper="0xa895d0e0" lower="(nil)">挡板法：C( n-1, m-1 )<Finish/></txt><txt ptr="0xa8976ab4" next="0xa8976b44" prev="0xa8976a24" upper="0xa895d0e0" lower="(nil)">可以为空<Finish/></txt><txt ptr="0xa8976b44" next="(nil)" prev="0xa8976ab4" upper="0xa895d0e0" lower="(nil)">填球法：C( n+m-1,m-1 )<Finish/></txt></body></column><column ptr="0xa89555f4" next="(nil)" prev="0xa8955590" upper="0xa8978b88" lower="0xa895d140"><body ptr="0xa895d140" next="(nil)" prev="(nil)" upper="0xa89555f4" lower="0xa8976bd4"><txt ptr="0xa8976bd4" next="0xa8976c64" prev="(nil)" upper="0xa895d140" lower="(nil)">n个不同的球<Finish/></txt><txt ptr="0xa8976c64" next="0xa8976cf4" prev="0xa8976bd4" upper="0xa895d140" lower="(nil)">放进m个相同的盒子里<Finish/></txt><txt ptr="0xa8976cf4" next="0xa8976d84" prev="0xa8976c64" upper="0xa895d140" lower="(nil)">至少一个<Finish/></txt><txt ptr="0xa8976d84" next="0xa8976e14" prev="0xa8976cf4" upper="0xa895d140" lower="(nil)">分析：单独放于不单独放<Finish/></txt><txt ptr="0xa8976e14" next="0xa8976ea4" prev="0xa8976d84" upper="0xa895d140" lower="(nil)">S2[n,m]=m*S2[n-1 , m] + S2[n-1,m-1];<Finish/></txt><txt ptr="0xa8976ea4" next="0xa8976f34" prev="0xa8976e14" upper="0xa895d140" lower="(nil)">可以为空<Finish/></txt><txt ptr="0xa8976f34" next="0xa8977008" prev="0xa8976ea4" upper="0xa895d140" lower="(nil)">方案数为：ANS[n,m] =ANS[n,m-1] + S2[n,m];<Finish/></txt><txt ptr="0xa8977008" next="0xa8977098" prev="0xa8976f34" upper="0xa895d140" lower="(nil)">放进m个不同的盒子里<Finish/></txt><txt ptr="0xa8977098" next="0xa8977128" prev="0xa8977008" upper="0xa895d140" lower="(nil)">至少一个<Finish/></txt><txt ptr="0xa8977128" next="0xa89771b8" prev="0xa8977098" upper="0xa895d140" lower="(nil)">方案数：m*S2[n,m]<Finish/></txt><txt ptr="0xa89771b8" next="0xa8977248" prev="0xa8977128" upper="0xa895d140" lower="(nil)">可以为空<Finish/></txt><txt ptr="0xa8977248" next="0xa89772d8" prev="0xa89771b8" upper="0xa895d140" lower="(nil)">放于不放：m^n<Finish/></txt><txt ptr="0xa89772d8" next="0xa8977368" prev="0xa8977248" upper="0xa895d140" lower="(nil)"><Finish/></txt><txt ptr="0xa8977368" next="0xa89773f8" prev="0xa89772d8" upper="0xa895d140" lower="(nil)">最大1矩阵<Finish/></txt><txt ptr="0xa89773f8" next="0xa8977758" prev="0xa8977368" upper="0xa895d140" lower="(nil)">int a[N][N];<Finish/></txt><txt ptr="0xa8977758" next="0xa89777e8" prev="0xa89773f8" upper="0xa895d140" lower="(nil)">// a[1...m][1...n]<Finish/></txt><txt ptr="0xa89777e8" next="0xa8977878" prev="0xa8977758" upper="0xa895d140" lower="(nil)">int n,m;<Finish/></txt><txt ptr="0xa8977878" next="0xa8977908" prev="0xa89777e8" upper="0xa895d140" lower="(nil)"><Finish/></txt><txt ptr="0xa8977908" next="0xa8977998" prev="0xa8977878" upper="0xa895d140" lower="(nil)">void mycol(int i,int* col){<Finish/></txt><txt ptr="0xa8977998" next="0xa8977a28" prev="0xa8977908" upper="0xa895d140" lower="(nil)">*for(int j=0,k;j&lt;n;++j){<Finish/></txt><txt ptr="0xa8977a28" next="0xa8977ab8" prev="0xa8977998" upper="0xa895d140" lower="(nil)">**if(a[i][j]==0)col[j]=0;<Finish/></txt><txt ptr="0xa8977ab8" next="0xa8977b48" prev="0xa8977a28" upper="0xa895d140" lower="(nil)">**else if(i==0 || !a[i-1][j]){<Finish/></txt><txt ptr="0xa8977b48" next="0xa8977bd8" prev="0xa8977ab8" upper="0xa895d140" lower="(nil)">***for(k=i+1;k&lt;m &amp;&amp; a[k][j];++k);<Finish/></txt><txt ptr="0xa8977bd8" next="0xa8977c68" prev="0xa8977b48" upper="0xa895d140" lower="(nil)">***col[j]=k;<Finish/></txt><txt ptr="0xa8977c68" next="0xa8977cf8" prev="0xa8977bd8" upper="0xa895d140" lower="(nil)">**}<Finish/></txt><txt ptr="0xa8977cf8" next="(nil)" prev="0xa8977c68" upper="0xa895d140" lower="(nil)">*}<Finish/></txt></body></column></section></body><footer ptr="0xa8998840" next="(nil)" prev="0xa999c308" upper="0xa8993a6c" lower="0xa999fbe4"><txt ptr="0xa999fbe4" next="0xa999fd94" prev="(nil)" upper="0xa8998840" lower="(nil)"><anchored><fly ptr="0xb76f778" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa999fc74"><txt ptr="0xa999fc74" next="0xa999fd04" prev="(nil)" upper="0xb76f778" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa999fd04" next="(nil)" prev="0xa999fc74" upper="0xb76f778" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="2"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="5"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa999fd94" next="(nil)" prev="0xa999fbe4" upper="0xa8998840" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993ae0" next="0xa8993b54" prev="0xa8993a6c" upper="0xb0726b0" lower="0xa89968a0"><header ptr="0xa89968a0" next="0xa999c488" prev="(nil)" upper="0xa8993ae0" lower="0xa99a113c"><txt ptr="0xa99a113c" next="(nil)" prev="(nil)" upper="0xa89968a0" lower="(nil)"><Finish/></txt></header><body ptr="0xa999c488" next="0xa89988a0" prev="0xa89968a0" upper="0xa8993ae0" lower="0xa8978188"><section ptr="0xa8978188" next="(nil)" prev="(nil)" upper="0xa999c488" lower="0xa6c00864" follow="0xa998cf04" precede="0xa8978b88"><column ptr="0xa6c00864" next="0xa6c008c8" prev="(nil)" upper="0xa8978188" lower="0xa6bfe8a8"><body ptr="0xa6bfe8a8" next="(nil)" prev="(nil)" upper="0xa6c00864" lower="0xa8977d88"><txt ptr="0xa8977d88" next="0xa8977e18" prev="(nil)" upper="0xa6bfe8a8" lower="(nil)">}<Finish/></txt><txt ptr="0xa8977e18" next="0xa8977ea8" prev="0xa8977d88" upper="0xa6bfe8a8" lower="(nil)"><Finish/></txt><txt ptr="0xa8977ea8" next="0xa8977f38" prev="0xa8977e18" upper="0xa6bfe8a8" lower="(nil)">int Run(){//可以用单调队列优化<Finish/></txt><txt ptr="0xa8977f38" next="0xa897900c" prev="0xa8977ea8" upper="0xa6bfe8a8" lower="(nil)">*int  i,j,l, r, max = 0;<Finish/></txt><txt ptr="0xa897900c" next="0xa897909c" prev="0xa8977f38" upper="0xa6bfe8a8" lower="(nil)">*int col[N];<Finish/></txt><txt ptr="0xa897909c" next="0xa897912c" prev="0xa897900c" upper="0xa6bfe8a8" lower="(nil)">*<Finish/></txt><txt ptr="0xa897912c" next="0xa89791bc" prev="0xa897909c" upper="0xa6bfe8a8" lower="(nil)">*for(i=0; i &lt; m; ++i ){<Finish/></txt><txt ptr="0xa89791bc" next="0xa897924c" prev="0xa897912c" upper="0xa6bfe8a8" lower="(nil)">**mycol(i,col);<Finish/></txt><txt ptr="0xa897924c" next="0xa89792dc" prev="0xa89791bc" upper="0xa6bfe8a8" lower="(nil)">**for(j=0; j &lt; n; ++j )<Finish/></txt><txt ptr="0xa89792dc" next="0xa897936c" prev="0xa897924c" upper="0xa6bfe8a8" lower="(nil)">***if( col[j] &gt; i ){<Finish/></txt><txt ptr="0xa897936c" next="0xa89793fc" prev="0xa89792dc" upper="0xa6bfe8a8" lower="(nil)">***for( l=j-1; l &gt;=0 &amp;&amp; col[l] &gt;= col[j]; --l );<Finish/></txt><txt ptr="0xa89793fc" next="0xa897948c" prev="0xa897936c" upper="0xa6bfe8a8" lower="(nil)">**for( r=j+1; r &lt; n &amp;&amp; col[r] &gt;= col[j]; ++r );<Finish/></txt><txt ptr="0xa897948c" next="0xa897951c" prev="0xa89793fc" upper="0xa6bfe8a8" lower="(nil)">****int res = (r-l-1)*(col[j]-i);<Finish/></txt><txt ptr="0xa897951c" next="0xa89795ac" prev="0xa897948c" upper="0xa6bfe8a8" lower="(nil)">****if( res &gt; max ) max = res;<Finish/></txt><txt ptr="0xa89795ac" next="0xa897963c" prev="0xa897951c" upper="0xa6bfe8a8" lower="(nil)">***}<Finish/></txt><txt ptr="0xa897963c" next="0xa89796cc" prev="0xa89795ac" upper="0xa6bfe8a8" lower="(nil)">*}<Finish/></txt><txt ptr="0xa89796cc" next="0xa897975c" prev="0xa897963c" upper="0xa6bfe8a8" lower="(nil)"><Finish/></txt><txt ptr="0xa897975c" next="0xa89797ec" prev="0xa89796cc" upper="0xa6bfe8a8" lower="(nil)">*return max;<Finish/></txt><txt ptr="0xa89797ec" next="0xa897987c" prev="0xa897975c" upper="0xa6bfe8a8" lower="(nil)">}<Finish/></txt><txt ptr="0xa897987c" next="0xa897990c" prev="0xa89797ec" upper="0xa6bfe8a8" lower="(nil)">最大子段和<Finish/></txt><txt ptr="0xa897990c" next="0xa897999c" prev="0xa897987c" upper="0xa6bfe8a8" lower="(nil)">设当前位置为子段的最后一个，答案有两种情况：<Finish/></txt><txt ptr="0xa897999c" next="0xa8979cfc" prev="0xa897990c" upper="0xa6bfe8a8" lower="(nil)">如果当前位置的上一个为子段的最后一个的最优值小于等于0，则当前位置单独为一个子段会更优。<Finish/></txt><txt ptr="0xa8979cfc" next="0xa8979d8c" prev="0xa897999c" upper="0xa6bfe8a8" lower="(nil)">否则，当前位置加上前一个的最优值就是当前的最优值。<Finish/></txt><txt ptr="0xa8979d8c" next="0xa8979e1c" prev="0xa8979cfc" upper="0xa6bfe8a8" lower="(nil)">int MSS(int*a,int n) {<Finish/></txt><txt ptr="0xa8979e1c" next="(nil)" prev="0xa8979d8c" upper="0xa6bfe8a8" lower="(nil)">    int tmp ,sum;<Finish/></txt></body></column><column ptr="0xa6c008c8" next="0xa6c0092c" prev="0xa6c00864" upper="0xa8978188" lower="0xa6bfe908"><body ptr="0xa6bfe908" next="(nil)" prev="(nil)" upper="0xa6c008c8" lower="0xa8979eac"><txt ptr="0xa8979eac" next="0xa8979f3c" prev="(nil)" upper="0xa6bfe908" lower="(nil)">    tmp = sum = a[1];<Finish/></txt><txt ptr="0xa8979f3c" next="0xa897a010" prev="0xa8979eac" upper="0xa6bfe908" lower="(nil)">    for(i = 2; i&lt;=n; i++) {<Finish/></txt><txt ptr="0xa897a010" next="0xa897a0a0" prev="0xa8979f3c" upper="0xa6bfe908" lower="(nil)">        if(tmp &gt;= 0) {<Finish/></txt><txt ptr="0xa897a0a0" next="0xa897a130" prev="0xa897a010" upper="0xa6bfe908" lower="(nil)">            tmp += a[i];<Finish/></txt><txt ptr="0xa897a130" next="0xa897a1c0" prev="0xa897a0a0" upper="0xa6bfe908" lower="(nil)">        } else {<Finish/></txt><txt ptr="0xa897a1c0" next="0xa897a250" prev="0xa897a130" upper="0xa6bfe908" lower="(nil)">            tmp = a[i];<Finish/></txt><txt ptr="0xa897a250" next="0xa897a2e0" prev="0xa897a1c0" upper="0xa6bfe908" lower="(nil)">        }<Finish/></txt><txt ptr="0xa897a2e0" next="0xa897a370" prev="0xa897a250" upper="0xa6bfe908" lower="(nil)"><Finish/></txt><txt ptr="0xa897a370" next="0xa897a400" prev="0xa897a2e0" upper="0xa6bfe908" lower="(nil)">        if(tmp &gt; sum) {<Finish/></txt><txt ptr="0xa897a400" next="0xa897a490" prev="0xa897a370" upper="0xa6bfe908" lower="(nil)">            sum = tmp;<Finish/></txt><txt ptr="0xa897a490" next="0xa897a520" prev="0xa897a400" upper="0xa6bfe908" lower="(nil)">        }<Finish/></txt><txt ptr="0xa897a520" next="0xa897a5b0" prev="0xa897a490" upper="0xa6bfe908" lower="(nil)">    }<Finish/></txt><txt ptr="0xa897a5b0" next="0xa897a640" prev="0xa897a520" upper="0xa6bfe908" lower="(nil)">    return sum;<Finish/></txt><txt ptr="0xa897a640" next="0xa897a6d0" prev="0xa897a5b0" upper="0xa6bfe908" lower="(nil)">}<Finish/></txt><txt ptr="0xa897a6d0" next="0xa897a760" prev="0xa897a640" upper="0xa6bfe908" lower="(nil)">最大M子段和<Finish/></txt><txt ptr="0xa897a760" next="0xa897a7f0" prev="0xa897a6d0" upper="0xa6bfe908" lower="(nil)">给n个数，求着n个数划分成互不相交的m段的最大m子段和。<Finish/></txt><txt ptr="0xa897a7f0" next="0xa897a880" prev="0xa897a760" upper="0xa6bfe908" lower="(nil)">经典的动态规划优化问题。<Finish/></txt><txt ptr="0xa897a880" next="0xa897a910" prev="0xa897a7f0" upper="0xa6bfe908" lower="(nil)">设f(i,j)表示前i个数划分成j段，且包括第i个数的最大j段和，那么dp方程为：<Finish/></txt><txt ptr="0xa897a910" next="0xa897a9a0" prev="0xa897a880" upper="0xa6bfe908" lower="(nil)">f(i,j)=max(f(i-1,j),max{f(k,j-1)})+v[i];<Finish/></txt><txt ptr="0xa897a9a0" next="0xa897aa30" prev="0xa897a910" upper="0xa6bfe908" lower="(nil)">分析：第i个数要么和前一个数一起划分到第j段里，要么独自划分到第j段,也就是我们要找到i之前的数划分为j-1段的最优值，这个可以只需一个变量标记最大值岂可。<Finish/></txt><txt ptr="0xa897aa30" next="0xa897aac0" prev="0xa897a9a0" upper="0xa6bfe908" lower="(nil)">转移复杂度：O(1),总复杂度O(n*m)<Finish/></txt><txt ptr="0xa897aac0" next="(nil)" prev="0xa897aa30" upper="0xa6bfe908" lower="(nil)">int g[N];<Finish/></txt></body></column><column ptr="0xa6c0092c" next="(nil)" prev="0xa6c008c8" upper="0xa8978188" lower="0xa6bfe968"><body ptr="0xa6bfe968" next="(nil)" prev="(nil)" upper="0xa6c0092c" lower="0xa897ab50"><txt ptr="0xa897ab50" next="0xa897abe0" prev="(nil)" upper="0xa6bfe968" lower="(nil)">int max_m_sum(int* str,int n,int m){<Finish/></txt><txt ptr="0xa897abe0" next="0xa897ac70" prev="0xa897ab50" upper="0xa6bfe968" lower="(nil)">    memset(g,0,sizeof(g));<Finish/></txt><txt ptr="0xa897ac70" next="0xa897ad00" prev="0xa897abe0" upper="0xa6bfe968" lower="(nil)">    int i,j,_max,tmp;<Finish/></txt><txt ptr="0xa897ad00" next="0xa897ad90" prev="0xa897ac70" upper="0xa6bfe968" lower="(nil)"><Finish/></txt><txt ptr="0xa897ad90" next="0xa897ae20" prev="0xa897ad00" upper="0xa6bfe968" lower="(nil)">    for(i=1;i&lt;=m;i++){<Finish/></txt><txt ptr="0xa897ae20" next="0xa897aeb0" prev="0xa897ad90" upper="0xa6bfe968" lower="(nil)">        _max = g[i-1];<Finish/></txt><txt ptr="0xa897aeb0" next="0xa897af40" prev="0xa897ae20" upper="0xa6bfe968" lower="(nil)">        for(j=i;j&lt;=n;j++){<Finish/></txt><txt ptr="0xa897af40" next="0xa897c2e4" prev="0xa897aeb0" upper="0xa6bfe968" lower="(nil)">            tmp = _max;<Finish/></txt><txt ptr="0xa897c2e4" next="0xa897c374" prev="0xa897af40" upper="0xa6bfe968" lower="(nil)">            _max = max(_max,g[j]);<Finish/></txt><txt ptr="0xa897c374" next="0xa897c404" prev="0xa897c2e4" upper="0xa6bfe968" lower="(nil)">            g[j] = max(g[j-1],tmp) + str[j];<Finish/></txt><txt ptr="0xa897c404" next="0xa897c494" prev="0xa897c374" upper="0xa6bfe968" lower="(nil)">        }<Finish/></txt><txt ptr="0xa897c494" next="0xa897c524" prev="0xa897c404" upper="0xa6bfe968" lower="(nil)">    }<Finish/></txt><txt ptr="0xa897c524" next="0xa897c5b4" prev="0xa897c494" upper="0xa6bfe968" lower="(nil)">    _max = g[m];<Finish/></txt><txt ptr="0xa897c5b4" next="0xa897c644" prev="0xa897c524" upper="0xa6bfe968" lower="(nil)">    for(i=m;i&lt;=n;i++){<Finish/></txt><txt ptr="0xa897c644" next="0xa897c6d4" prev="0xa897c5b4" upper="0xa6bfe968" lower="(nil)">        _max = max(_max,g[i]);<Finish/></txt><txt ptr="0xa897c6d4" next="0xa897c764" prev="0xa897c644" upper="0xa6bfe968" lower="(nil)">    }<Finish/></txt><txt ptr="0xa897c764" next="0xa897c7f4" prev="0xa897c6d4" upper="0xa6bfe968" lower="(nil)">    return _max;<Finish/></txt><txt ptr="0xa897c7f4" next="0xa897c884" prev="0xa897c764" upper="0xa6bfe968" lower="(nil)">}<Finish/></txt><txt ptr="0xa897c884" next="0xa897c914" prev="0xa897c7f4" upper="0xa6bfe968" lower="(nil)">最长公共递增子序列(记录路径) <Finish/></txt><txt ptr="0xa897c914" next="0xa897c9a4" prev="0xa897c884" upper="0xa6bfe968" lower="(nil)">int f[N][N], dp[N];<Finish/></txt><txt ptr="0xa897c9a4" next="0xa897ca34" prev="0xa897c914" upper="0xa6bfe968" lower="(nil)">// a[1…la], b[1…lb] O(n^2)<Finish/></txt><txt ptr="0xa897ca34" next="0xa897cac4" prev="0xa897c9a4" upper="0xa6bfe968" lower="(nil)">int gcis(int a*, int la, int b*, int lb, int ans*){<Finish/></txt><txt ptr="0xa897cac4" next="0xa897cb54" prev="0xa897ca34" upper="0xa6bfe968" lower="(nil)">*int i, j, k, mx;<Finish/></txt><txt ptr="0xa897cb54" next="0xa897cbe4" prev="0xa897cac4" upper="0xa6bfe968" lower="(nil)">*memset(f, 0, sizeof(f));<Finish/></txt><txt ptr="0xa897cbe4" next="0xa897cc74" prev="0xa897cb54" upper="0xa6bfe968" lower="(nil)">*memset(dp, 0, sizeof(dp));<Finish/></txt><txt ptr="0xa897cc74" next="0xa897cd04" prev="0xa897cbe4" upper="0xa6bfe968" lower="(nil)">*for (i = 1; i &lt;= la; i++) {<Finish/></txt><txt ptr="0xa897cd04" next="(nil)" prev="0xa897cc74" upper="0xa6bfe968" lower="(nil)">**memcpy(f[i], f[i-1], sizeof(f[0]));<Finish/></txt></body></column></section></body><footer ptr="0xa89988a0" next="(nil)" prev="0xa999c488" upper="0xa8993ae0" lower="0xa99a11cc"><txt ptr="0xa99a11cc" next="0xa99a137c" prev="(nil)" upper="0xa89988a0" lower="(nil)"><anchored><fly ptr="0xa4f9578" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99a125c"><txt ptr="0xa99a125c" next="0xa99a12ec" prev="(nil)" upper="0xa4f9578" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99a12ec" next="(nil)" prev="0xa99a125c" upper="0xa4f9578" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="2"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="6"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99a137c" next="(nil)" prev="0xa99a11cc" upper="0xa89988a0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993b54" next="0xa8993bc8" prev="0xa8993ae0" upper="0xb0726b0" lower="0xa8996900"><header ptr="0xa8996900" next="0xa999c608" prev="(nil)" upper="0xa8993b54" lower="0xa99a26e0"><txt ptr="0xa99a26e0" next="(nil)" prev="(nil)" upper="0xa8996900" lower="(nil)"><Finish/></txt></header><body ptr="0xa999c608" next="0xa8998900" prev="0xa8996900" upper="0xa8993b54" lower="0xa998cf04"><section ptr="0xa998cf04" next="(nil)" prev="(nil)" upper="0xa999c608" lower="0xa6c00abc" follow="0xa894b00c" precede="0xa8978188"><column ptr="0xa6c00abc" next="0xa6c00b20" prev="(nil)" upper="0xa998cf04" lower="0xa6bfeae8"><body ptr="0xa6bfeae8" next="(nil)" prev="(nil)" upper="0xa6c00abc" lower="0xa897cd94"><txt ptr="0xa897cd94" next="0xa897ce24" prev="(nil)" upper="0xa6bfeae8" lower="(nil)">**for (k = 0, j = 1; j &lt;= lb; j++) {<Finish/></txt><txt ptr="0xa897ce24" next="0xa897ceb4" prev="0xa897cd94" upper="0xa6bfeae8" lower="(nil)">***if (b[j-1] &lt; a[i-1] &amp;&amp; dp[j] &gt; dp[k]) k = j;<Finish/></txt><txt ptr="0xa897ceb4" next="0xa897cf44" prev="0xa897ce24" upper="0xa6bfeae8" lower="(nil)">**if (b[j-1] == a[i-1] &amp;&amp; dp[k] + 1 &gt; dp[j]) {<Finish/></txt><txt ptr="0xa897cf44" next="0xa897d018" prev="0xa897ceb4" upper="0xa6bfeae8" lower="(nil)">****dp[j] = dp[k] + 1,<Finish/></txt><txt ptr="0xa897d018" next="0xa897d0a8" prev="0xa897cf44" upper="0xa6bfeae8" lower="(nil)">****f[i][j] = i * (lb + 1) + k;<Finish/></txt><txt ptr="0xa897d0a8" next="0xa897d138" prev="0xa897d018" upper="0xa6bfeae8" lower="(nil)">***}<Finish/></txt><txt ptr="0xa897d138" next="0xa897d1c8" prev="0xa897d0a8" upper="0xa6bfeae8" lower="(nil)">**}<Finish/></txt><txt ptr="0xa897d1c8" next="0xa897d258" prev="0xa897d138" upper="0xa6bfeae8" lower="(nil)">*}<Finish/></txt><txt ptr="0xa897d258" next="0xa897d2e8" prev="0xa897d1c8" upper="0xa6bfeae8" lower="(nil)">*for (mx = 0, i = 1; i &lt;= lb; i++)<Finish/></txt><txt ptr="0xa897d2e8" next="0xa897d378" prev="0xa897d258" upper="0xa6bfeae8" lower="(nil)">*if (dp[i] &gt; dp[mx]) mx = i;<Finish/></txt><txt ptr="0xa897d378" next="0xa897d408" prev="0xa897d2e8" upper="0xa6bfeae8" lower="(nil)">*for(i=la*lb+la+mx,j=dp[mx]; j;i=f[i/(lb+1)][i%(lb+1)],j--)<Finish/></txt><txt ptr="0xa897d408" next="0xa897d498" prev="0xa897d378" upper="0xa6bfeae8" lower="(nil)">**ans[j-1] = b[i % (lb + 1) - 1];<Finish/></txt><txt ptr="0xa897d498" next="0xa897d528" prev="0xa897d408" upper="0xa6bfeae8" lower="(nil)">*return dp[mx];<Finish/></txt><txt ptr="0xa897d528" next="0xa897d888" prev="0xa897d498" upper="0xa6bfeae8" lower="(nil)">}<Finish/></txt><txt ptr="0xa897d888" next="0xa897d918" prev="0xa897d528" upper="0xa6bfeae8" lower="(nil)"><Finish/></txt><txt ptr="0xa897d918" next="0xa897d9a8" prev="0xa897d888" upper="0xa6bfeae8" lower="(nil)">最长公共子序列<Finish/></txt><txt ptr="0xa897d9a8" next="0xa897da38" prev="0xa897d918" upper="0xa6bfeae8" lower="(nil)">int LCS(const char *s1, const char *s2){<Finish/></txt><txt ptr="0xa897da38" next="0xa897dac8" prev="0xa897d9a8" upper="0xa6bfeae8" lower="(nil)">*int m = strlen(s1), n = strlen(s2);<Finish/></txt><txt ptr="0xa897dac8" next="0xa897db58" prev="0xa897da38" upper="0xa6bfeae8" lower="(nil)">*int i, j;<Finish/></txt><txt ptr="0xa897db58" next="0xa897dbe8" prev="0xa897dac8" upper="0xa6bfeae8" lower="(nil)">*a[0][0] = 0;<Finish/></txt><txt ptr="0xa897dbe8" next="0xa897dc78" prev="0xa897db58" upper="0xa6bfeae8" lower="(nil)">*for( i=1; i &lt;= m; ++i ) a[i][0] = 0;<Finish/></txt><txt ptr="0xa897dc78" next="0xa897dd08" prev="0xa897dbe8" upper="0xa6bfeae8" lower="(nil)">*for( i=1; i &lt;= n; ++i ) a[0][i] = 0;<Finish/></txt><txt ptr="0xa897dd08" next="0xa897dd98" prev="0xa897dc78" upper="0xa6bfeae8" lower="(nil)">*<Finish/></txt><txt ptr="0xa897dd98" next="0xa897de28" prev="0xa897dd08" upper="0xa6bfeae8" lower="(nil)">*for( i=1; i &lt;= m; ++i )<Finish/></txt><txt ptr="0xa897de28" next="0xa897deb8" prev="0xa897dd98" upper="0xa6bfeae8" lower="(nil)">*for( j=1; j &lt;= n; ++j ){<Finish/></txt><txt ptr="0xa897deb8" next="(nil)" prev="0xa897de28" upper="0xa6bfeae8" lower="(nil)">**if(s1[i-1]==s2[j-1]) a[i][j] = a[i-1][j-1]+1;<Finish/></txt></body></column><column ptr="0xa6c00b20" next="0xa6c00b84" prev="0xa6c00abc" upper="0xa998cf04" lower="0xa6bfeb48"><body ptr="0xa6bfeb48" next="(nil)" prev="(nil)" upper="0xa6c00b20" lower="0xa897df48"><txt ptr="0xa897df48" next="0xa895e01c" prev="(nil)" upper="0xa6bfeb48" lower="(nil)">**else if(a[i-1][j]&gt;a[i][j-1])a[i][j]= a[i-1][j];<Finish/></txt><txt ptr="0xa895e01c" next="0xa895e0ac" prev="0xa897df48" upper="0xa6bfeb48" lower="(nil)">**else a[i][j] = a[i][j-1];<Finish/></txt><txt ptr="0xa895e0ac" next="0xa895e13c" prev="0xa895e01c" upper="0xa6bfeb48" lower="(nil)">*}<Finish/></txt><txt ptr="0xa895e13c" next="0xa895e1cc" prev="0xa895e0ac" upper="0xa6bfeb48" lower="(nil)">*return a[m][n];<Finish/></txt><txt ptr="0xa895e1cc" next="0xa895e25c" prev="0xa895e13c" upper="0xa6bfeb48" lower="(nil)">}<Finish/></txt><txt ptr="0xa895e25c" next="0xa895e2ec" prev="0xa895e1cc" upper="0xa6bfeb48" lower="(nil)"><Finish/></txt><txt ptr="0xa895e2ec" next="0xa895e37c" prev="0xa895e25c" upper="0xa6bfeb48" lower="(nil)"><Finish/></txt><txt ptr="0xa895e37c" next="0xa895e40c" prev="0xa895e2ec" upper="0xa6bfeb48" lower="(nil)">最大连续子矩阵<Finish/></txt><txt ptr="0xa895e40c" next="0xa895e49c" prev="0xa895e37c" upper="0xa6bfeb48" lower="(nil)">RMQ问题<Finish/></txt><txt ptr="0xa895e49c" next="0xa895e52c" prev="0xa895e40c" upper="0xa6bfeb48" lower="(nil)">题目描述<Finish/></txt><txt ptr="0xa895e52c" next="0xa895e5bc" prev="0xa895e49c" upper="0xa6bfeb48" lower="(nil)">RMQ问题是求给定区间中的最值问题。<Finish/></txt><txt ptr="0xa895e5bc" next="0xa895e64c" prev="0xa895e52c" upper="0xa6bfeb48" lower="(nil)">当然，最简单的算法是O(n)的，但是对于查询次数很多（设置多大100万次），O(n)的算法效率不够。可以用线段树将算法优化到O（logn)（在线段树中保存线段的最值）。<Finish/></txt><txt ptr="0xa895e64c" next="0xa895e6dc" prev="0xa895e5bc" upper="0xa6bfeb48" lower="(nil)">不过，Sparse_Table算法才是最好的：它可以在O(nlogn)的预处理以后实现O(1)的查询效率。<Finish/></txt><txt ptr="0xa895e6dc" next="0xa895e76c" prev="0xa895e64c" upper="0xa6bfeb48" lower="(nil)"><Finish/></txt><txt ptr="0xa895e76c" next="0xa895e7fc" prev="0xa895e6dc" upper="0xa6bfeb48" lower="(nil)">思路分析：<Finish/></txt><txt ptr="0xa895e7fc" next="0xa895e88c" prev="0xa895e76c" upper="0xa6bfeb48" lower="(nil)"><Finish/></txt><txt ptr="0xa895e88c" next="0xa895e91c" prev="0xa895e7fc" upper="0xa6bfeb48" lower="(nil)">下面把Sparse Table算法分成预处理和查询两部分来说明(以求最小值为例)。<Finish/></txt><txt ptr="0xa895e91c" next="0xa895e9ac" prev="0xa895e88c" upper="0xa6bfeb48" lower="(nil)"><Finish/></txt><txt ptr="0xa895e9ac" next="0xa895ea3c" prev="0xa895e91c" upper="0xa6bfeb48" lower="(nil)"> <Finish/></txt><txt ptr="0xa895ea3c" next="(nil)" prev="0xa895e9ac" upper="0xa6bfeb48" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa6c00b84" next="(nil)" prev="0xa6c00b20" upper="0xa998cf04" lower="0xa6bfeba8"><body ptr="0xa6bfeba8" next="(nil)" prev="(nil)" upper="0xa6c00b84" lower="0xa895eacc"><txt ptr="0xa895eacc" next="0xa895ee2c" prev="(nil)" upper="0xa6bfeba8" lower="(nil)">预处理:<Finish/></txt><txt ptr="0xa895ee2c" next="0xa895eebc" prev="0xa895eacc" upper="0xa6bfeba8" lower="(nil)">预处理使用DP的思想，f(i, j)表示[i, i+2^j - 1]区间中的最小值，我们可以开辟一个数组专门来保存f(i, j)的值。<Finish/></txt><txt ptr="0xa895eebc" next="0xa895ef4c" prev="0xa895ee2c" upper="0xa6bfeba8" lower="(nil)">例如，f(0, 0)表示[0,0]之间的最小值,就是num[0], f(0, 2)表示[0, 3]之间的最小值, f(2, 4)表示[2, 17]之间的最小值<Finish/></txt><txt ptr="0xa895ef4c" next="0xa895f020" prev="0xa895eebc" upper="0xa6bfeba8" lower="(nil)">注意, 因为f(i, j)可以由f(i, j - 1)和f(i+2^(j-1), j-1)导出, 而递推的初值(所有的f(i, 0) = i)都是已知的<Finish/></txt><txt ptr="0xa895f020" next="0xa895f0b0" prev="0xa895ef4c" upper="0xa6bfeba8" lower="(nil)">所以我们可以采用自底向上的算法递推地给出所有符合条件的f(i, j)的值。<Finish/></txt><txt ptr="0xa895f0b0" next="0xa895f140" prev="0xa895f020" upper="0xa6bfeba8" lower="(nil)"><Finish/></txt><txt ptr="0xa895f140" next="0xa895f1d0" prev="0xa895f0b0" upper="0xa6bfeba8" lower="(nil)">查询:<Finish/></txt><txt ptr="0xa895f1d0" next="0xa895f260" prev="0xa895f140" upper="0xa6bfeba8" lower="(nil)"><Finish/></txt><txt ptr="0xa895f260" next="0xa895f2f0" prev="0xa895f1d0" upper="0xa6bfeba8" lower="(nil)">假设要查询从m到n这一段的最小值, 那么我们先求出一个最大的k, 使得k满足2^k &lt;= (n - m + 1).<Finish/></txt><txt ptr="0xa895f2f0" next="0xa895f380" prev="0xa895f260" upper="0xa6bfeba8" lower="(nil)">于是我们就可以把[m, n]分成两个(部分重叠的)长度为2^k的区间: [m, m+2^k-1], [n-2^k+1, n];<Finish/></txt><txt ptr="0xa895f380" next="0xa895f410" prev="0xa895f2f0" upper="0xa6bfeba8" lower="(nil)">而我们之前已经求出了f(m, k)为[m, m+2^k-1]的最小值, f(n-2^k+1, k)为[n-2^k+1, n]的最小值<Finish/></txt><txt ptr="0xa895f410" next="0xa895f4a0" prev="0xa895f380" upper="0xa6bfeba8" lower="(nil)">我们只要返回其中更小的那个, 就是我们想要的答案, 这个算法的时间复杂度是O(1)的.<Finish/></txt><txt ptr="0xa895f4a0" next="0xa895f530" prev="0xa895f410" upper="0xa6bfeba8" lower="(nil)">例如, rmq(0, 11) = min(f(0, 3), f(4, 3))<Finish/></txt><txt ptr="0xa895f530" next="0xa895f5c0" prev="0xa895f4a0" upper="0xa6bfeba8" lower="(nil)"><Finish/></txt><txt ptr="0xa895f5c0" next="0xa895f650" prev="0xa895f530" upper="0xa6bfeba8" lower="(nil)">样例代码<Finish/></txt><txt ptr="0xa895f650" next="0xa895f6e0" prev="0xa895f5c0" upper="0xa6bfeba8" lower="(nil)">int st[20][N], ln[N], val[N];<Finish/></txt><txt ptr="0xa895f6e0" next="0xa895f770" prev="0xa895f650" upper="0xa6bfeba8" lower="(nil)">void initrmq(int n) {<Finish/></txt><txt ptr="0xa895f770" next="(nil)" prev="0xa895f6e0" upper="0xa6bfeba8" lower="(nil)">    int i, j, k, sk;<Finish/></txt></body></column></section></body><footer ptr="0xa8998900" next="(nil)" prev="0xa999c608" upper="0xa8993b54" lower="0xa99a2770"><txt ptr="0xa99a2770" next="0xa99a2920" prev="(nil)" upper="0xa8998900" lower="(nil)"><anchored><fly ptr="0xb65f768" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99a2800"><txt ptr="0xa99a2800" next="0xa99a2890" prev="(nil)" upper="0xb65f768" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99a2890" next="(nil)" prev="0xa99a2800" upper="0xb65f768" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="2"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="7"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99a2920" next="(nil)" prev="0xa99a2770" upper="0xa8998900" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993bc8" next="0xa8993c3c" prev="0xa8993b54" upper="0xb0726b0" lower="0xa8996960"><header ptr="0xa8996960" next="0xa999c788" prev="(nil)" upper="0xa8993bc8" lower="0xa99a3c84"><txt ptr="0xa99a3c84" next="(nil)" prev="(nil)" upper="0xa8996960" lower="(nil)"><Finish/></txt></header><body ptr="0xa999c788" next="0xa8998960" prev="0xa8996960" upper="0xa8993bc8" lower="0xa894b00c"><section ptr="0xa894b00c" next="(nil)" prev="(nil)" upper="0xa999c788" lower="0xa8955e8c" follow="0xa998cc04" precede="0xa998cf04"><column ptr="0xa8955e8c" next="0xa8955ef0" prev="(nil)" upper="0xa894b00c" lower="0xa895dc80"><body ptr="0xa895dc80" next="(nil)" prev="(nil)" upper="0xa8955e8c" lower="0xa895f800"><txt ptr="0xa895f800" next="0xa895f890" prev="(nil)" upper="0xa895dc80" lower="(nil)">    ln[0] = ln[1] = 0;<Finish/></txt><txt ptr="0xa895f890" next="0xa895f920" prev="0xa895f800" upper="0xa895dc80" lower="(nil)">    for (i = 0; i &lt; n; i++) st[0][i] = val[i];<Finish/></txt><txt ptr="0xa895f920" next="0xa895f9b0" prev="0xa895f890" upper="0xa895dc80" lower="(nil)">    for (i = 1, k = 2; k &lt; n; i++, k &lt;&lt;= 1) {<Finish/></txt><txt ptr="0xa895f9b0" next="0xa895fa40" prev="0xa895f920" upper="0xa895dc80" lower="(nil)">        for (j = 0, sk = (k &gt;&gt; 1); j &lt; n; ++j, ++sk) {<Finish/></txt><txt ptr="0xa895fa40" next="0xa895fad0" prev="0xa895f9b0" upper="0xa895dc80" lower="(nil)">            st[i][j] = st[i-1][j];<Finish/></txt><txt ptr="0xa895fad0" next="0xa895fb60" prev="0xa895fa40" upper="0xa895dc80" lower="(nil)">            if (sk &lt; n &amp;&amp; st[i][j] &gt; st[i-1][sk])<Finish/></txt><txt ptr="0xa895fb60" next="0xa895fbf0" prev="0xa895fad0" upper="0xa895dc80" lower="(nil)">                st[i][j] = st[i-1][sk];<Finish/></txt><txt ptr="0xa895fbf0" next="0xa895fc80" prev="0xa895fb60" upper="0xa895dc80" lower="(nil)">        }<Finish/></txt><txt ptr="0xa895fc80" next="0xa895fd10" prev="0xa895fbf0" upper="0xa895dc80" lower="(nil)">        for (j=(k&gt;&gt;1)+1; j &lt;= k; ++j) ln[j] = ln[k&gt;&gt;1] + 1;<Finish/></txt><txt ptr="0xa895fd10" next="0xa895fda0" prev="0xa895fc80" upper="0xa895dc80" lower="(nil)">    }<Finish/></txt><txt ptr="0xa895fda0" next="0xa895fe30" prev="0xa895fd10" upper="0xa895dc80" lower="(nil)">    for (j=(k&gt;&gt;1)+1; j &lt;= k; ++j) ln[j] = ln[k&gt;&gt;1] + 1;<Finish/></txt><txt ptr="0xa895fe30" next="0xa895fec0" prev="0xa895fda0" upper="0xa895dc80" lower="(nil)">}<Finish/></txt><txt ptr="0xa895fec0" next="0xa895ff50" prev="0xa895fe30" upper="0xa895dc80" lower="(nil)">int query(int x, int y) { // min of { val[x] ... val[y] }<Finish/></txt><txt ptr="0xa895ff50" next="0xa8960024" prev="0xa895fec0" upper="0xa895dc80" lower="(nil)">    int bl = ln[y - x + 1];<Finish/></txt><txt ptr="0xa8960024" next="0xa89600b4" prev="0xa895ff50" upper="0xa895dc80" lower="(nil)">    return min(st[bl][x], st[bl][y-(1&lt;&lt;bl)+1]);<Finish/></txt><txt ptr="0xa89600b4" next="0xa8960414" prev="0xa8960024" upper="0xa895dc80" lower="(nil)">}<Finish/></txt><txt ptr="0xa8960414" next="0xa89604a4" prev="0xa89600b4" upper="0xa895dc80" lower="(nil)">LCA问题<Finish/></txt><txt ptr="0xa89604a4" next="0xa8960534" prev="0xa8960414" upper="0xa895dc80" lower="(nil)">对于该问题，最容易想到的算法是分别从节点u和v回溯到根节点，获取u和v到根节点的路径P1，P2，其中P1和P2可以看成两条单链表，这就转换成常见的一道面试题：【判断两个单链表是否相交，如果相交，给出相交的第一个点。】。该算法总的复杂度是O（n）（其中n是树节点个数）。<Finish/></txt><txt ptr="0xa8960534" next="(nil)" prev="0xa89604a4" upper="0xa895dc80" lower="(nil)">本节介绍了两种比较高效的算法解决这个问题，其中一个是在线算法（DFS+ST），另一个是离线算法（Tarjan算法）。<Finish/></txt></body></column><column ptr="0xa8955ef0" next="0xa8955f54" prev="0xa8955e8c" upper="0xa894b00c" lower="0xa895dce0"><body ptr="0xa895dce0" next="(nil)" prev="(nil)" upper="0xa8955ef0" lower="0xa89605c4"><txt ptr="0xa89605c4" next="0xa8960654" prev="(nil)" upper="0xa895dce0" lower="(nil)">在线算法DFS+ST<Finish/></txt><txt ptr="0xa8960654" next="0xa89606e4" prev="0xa89605c4" upper="0xa895dce0" lower="(nil)">(思想是：将树看成一个无向图，u和v的公共祖先一定在u与v之间的最短路径上)：<Finish/></txt><txt ptr="0xa89606e4" next="0xa8960774" prev="0xa8960654" upper="0xa895dce0" lower="(nil)">（1）DFS：从树T的根开始，进行深度优先遍历（将树T看成一个无向图），并记录下每次到达的顶点。第一个的结点是root(T)，每经过一条边都记录它的端点。由于每条边恰好经过2次，因此一共记录了2n-1个结点，用E[1, ... , 2n-1]来表示。<Finish/></txt><txt ptr="0xa8960774" next="0xa8960804" prev="0xa89606e4" upper="0xa895dce0" lower="(nil)">（2）计算R：用R[i]表示E数组中第一个值为i的元素下标，即如果R[u] &lt; R[v]时，DFS访问的顺序是E[R[u], R[u]+1, …, R[v]]。虽然其中包含u的后代，但深度最小的还是u与v的公共祖先。<Finish/></txt><txt ptr="0xa8960804" next="0xa8960894" prev="0xa8960774" upper="0xa895dce0" lower="(nil)">（3）RMQ：当R[u] ≥ R[v]时，LCA[T, u, v] = RMQ(L, R[v], R[u])；否则LCA[T, u, v] = RMQ(L, R[u], R[v])，计算RMQ。<Finish/></txt><txt ptr="0xa8960894" next="0xa8960924" prev="0xa8960804" upper="0xa895dce0" lower="(nil)">由于RMQ中使用的ST算法是在线算法，所以这个算法也是在线算法。<Finish/></txt><txt ptr="0xa8960924" next="0xa89609b4" prev="0xa8960894" upper="0xa895dce0" lower="(nil)">代码实现<Finish/></txt><txt ptr="0xa89609b4" next="0xa8960a44" prev="0xa8960924" upper="0xa895dce0" lower="(nil)">const int N = 10001; // 1&lt;&lt;20;<Finish/></txt><txt ptr="0xa8960a44" next="0xa8960ad4" prev="0xa89609b4" upper="0xa895dce0" lower="(nil)">int pnt[N], next[N], head[N]; // 邻接表<Finish/></txt><txt ptr="0xa8960ad4" next="0xa8960b64" prev="0xa8960a44" upper="0xa895dce0" lower="(nil)">int e; // 边数<Finish/></txt><txt ptr="0xa8960b64" next="0xa8960bf4" prev="0xa8960ad4" upper="0xa895dce0" lower="(nil)">bool visited[N]; // 初始为0，从根遍历<Finish/></txt><txt ptr="0xa8960bf4" next="0xa8960c84" prev="0xa8960b64" upper="0xa895dce0" lower="(nil)">int id;<Finish/></txt><txt ptr="0xa8960c84" next="0xa8960d14" prev="0xa8960bf4" upper="0xa895dce0" lower="(nil)">int dep[2*N+1], E[2*N+1], R[N]; // dep:dfs遍历节点深度, E:dfs序列, R:第一次被遍历的下标<Finish/></txt><txt ptr="0xa8960d14" next="0xa8960da4" prev="0xa8960c84" upper="0xa895dce0" lower="(nil)">void DFS(int u, int d);<Finish/></txt><txt ptr="0xa8960da4" next="0xa8960e34" prev="0xa8960d14" upper="0xa895dce0" lower="(nil)">int d[20], st[2*N+1][20];<Finish/></txt><txt ptr="0xa8960e34" next="(nil)" prev="0xa8960da4" upper="0xa895dce0" lower="(nil)">int n;<Finish/></txt></body></column><column ptr="0xa8955f54" next="(nil)" prev="0xa8955ef0" upper="0xa894b00c" lower="0xa895dd40"><body ptr="0xa895dd40" next="(nil)" prev="(nil)" upper="0xa8955f54" lower="0xa8960ec4"><txt ptr="0xa8960ec4" next="0xa8960f54" prev="(nil)" upper="0xa895dd40" lower="(nil)">void InitRMQ(const int &amp;id) {<Finish/></txt><txt ptr="0xa8960f54" next="0xa8962028" prev="0xa8960ec4" upper="0xa895dd40" lower="(nil)">    int i, j;<Finish/></txt><txt ptr="0xa8962028" next="0xa89620b8" prev="0xa8960f54" upper="0xa895dd40" lower="(nil)">    for( d[0]=1, i=1; i &lt; 20; ++i ) d[i] = 2*d[i-1];<Finish/></txt><txt ptr="0xa89620b8" next="0xa8962148" prev="0xa8962028" upper="0xa895dd40" lower="(nil)">    for( i=0; i &lt; id; ++i ) st[i][0] = i;<Finish/></txt><txt ptr="0xa8962148" next="0xa89621d8" prev="0xa89620b8" upper="0xa895dd40" lower="(nil)">    int k = int( log(double(n))/log(2.0) ) + 1;<Finish/></txt><txt ptr="0xa89621d8" next="0xa8962268" prev="0xa8962148" upper="0xa895dd40" lower="(nil)">    for( j=1; j &lt; k; ++j )<Finish/></txt><txt ptr="0xa8962268" next="0xa89622f8" prev="0xa89621d8" upper="0xa895dd40" lower="(nil)">        for( i=0; i &lt; id; ++i ) {<Finish/></txt><txt ptr="0xa89622f8" next="0xa8962388" prev="0xa8962268" upper="0xa895dd40" lower="(nil)">            if( i+d[j-1]-1 &lt; id ) {<Finish/></txt><txt ptr="0xa8962388" next="0xa8962418" prev="0xa89622f8" upper="0xa895dd40" lower="(nil)">                st[i][j] = dep[ st[i][j-1] ] &gt; dep[ st[i+d[j-1]][j-1] ] ? st[i+d[j-1]][j-1] : st[i][j-1];<Finish/></txt><txt ptr="0xa8962418" next="0xa89624a8" prev="0xa8962388" upper="0xa895dd40" lower="(nil)">            } else break; // st[i][j] = st[i][j-1];<Finish/></txt><txt ptr="0xa89624a8" next="0xa8962538" prev="0xa8962418" upper="0xa895dd40" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8962538" next="0xa89625c8" prev="0xa89624a8" upper="0xa895dd40" lower="(nil)">}<Finish/></txt><txt ptr="0xa89625c8" next="0xa8962658" prev="0xa8962538" upper="0xa895dd40" lower="(nil)">int Query(int x, int y) {<Finish/></txt><txt ptr="0xa8962658" next="0xa89629b8" prev="0xa89625c8" upper="0xa895dd40" lower="(nil)">    int k; // x, y均为下标:0...n-1<Finish/></txt><txt ptr="0xa89629b8" next="0xa8962a48" prev="0xa8962658" upper="0xa895dd40" lower="(nil)">    k = int( log(double(y-x+1))/log(2.0) );<Finish/></txt><txt ptr="0xa8962a48" next="0xa8962ad8" prev="0xa89629b8" upper="0xa895dd40" lower="(nil)">    return dep[ st[x][k] ] &gt; dep[ st[y-d[k]+1][k] ] ? st[y-d[k]+1][k] : st[x][k];<Finish/></txt><txt ptr="0xa8962ad8" next="0xa8962b68" prev="0xa8962a48" upper="0xa895dd40" lower="(nil)">}<Finish/></txt><txt ptr="0xa8962b68" next="0xa8962bf8" prev="0xa8962ad8" upper="0xa895dd40" lower="(nil)"><Finish/></txt><txt ptr="0xa8962bf8" next="0xa8962c88" prev="0xa8962b68" upper="0xa895dd40" lower="(nil)">void Answer(void) {<Finish/></txt><txt ptr="0xa8962c88" next="0xa8962d18" prev="0xa8962bf8" upper="0xa895dd40" lower="(nil)">    int i, Q;<Finish/></txt><txt ptr="0xa8962d18" next="0xa8962da8" prev="0xa8962c88" upper="0xa895dd40" lower="(nil)">    scanf(&quot;%d&quot;, &amp;Q);<Finish/></txt><txt ptr="0xa8962da8" next="0xa8962e38" prev="0xa8962d18" upper="0xa895dd40" lower="(nil)">    for( i=0; i &lt; Q; ++i ) {<Finish/></txt><txt ptr="0xa8962e38" next="0xa8962ec8" prev="0xa8962da8" upper="0xa895dd40" lower="(nil)">        int x, y;<Finish/></txt><txt ptr="0xa8962ec8" next="0xa8962f58" prev="0xa8962e38" upper="0xa895dd40" lower="(nil)">        scanf(&quot;%d%d&quot;, &amp;x, &amp;y); // 查询x,y的LCA<Finish/></txt><txt ptr="0xa8962f58" next="0xa8963000" prev="0xa8962ec8" upper="0xa895dd40" lower="(nil)">        x = R[x];<Finish/></txt><txt ptr="0xa8963000" next="(nil)" prev="0xa8962f58" upper="0xa895dd40" lower="(nil)">        y = R[y];<Finish/></txt></body></column></section></body><footer ptr="0xa8998960" next="(nil)" prev="0xa999c788" upper="0xa8993bc8" lower="0xa99a3d14"><txt ptr="0xa99a3d14" next="0xa99a3ec4" prev="(nil)" upper="0xa8998960" lower="(nil)"><anchored><fly ptr="0xadc0b70" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99a3da4"><txt ptr="0xa99a3da4" next="0xa99a3e34" prev="(nil)" upper="0xadc0b70" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99a3e34" next="(nil)" prev="0xa99a3da4" upper="0xadc0b70" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="2"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="8"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99a3ec4" next="(nil)" prev="0xa99a3d14" upper="0xa8998960" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993c3c" next="0xa8993cb0" prev="0xa8993bc8" upper="0xb0726b0" lower="0xa89969c0"><header ptr="0xa89969c0" next="0xa999c908" prev="(nil)" upper="0xa8993c3c" lower="0xa99a7240"><txt ptr="0xa99a7240" next="(nil)" prev="(nil)" upper="0xa89969c0" lower="(nil)"><Finish/></txt></header><body ptr="0xa999c908" next="0xa89989c0" prev="0xa89969c0" upper="0xa8993c3c" lower="0xa998cc04"><section ptr="0xa998cc04" next="(nil)" prev="(nil)" upper="0xa999c908" lower="0xa6c00e40" follow="0xa998ca84" precede="0xa894b00c"><column ptr="0xa6c00e40" next="0xa6c00ea4" prev="(nil)" upper="0xa998cc04" lower="0xa6bfee48"><body ptr="0xa6bfee48" next="(nil)" prev="(nil)" upper="0xa6c00e40" lower="0xa8963090"><txt ptr="0xa8963090" next="0xa8963120" prev="(nil)" upper="0xa6bfee48" lower="(nil)">        if( x &gt; y ) {<Finish/></txt><txt ptr="0xa8963120" next="0xa89631b0" prev="0xa8963090" upper="0xa6bfee48" lower="(nil)">            int tmp = x;<Finish/></txt><txt ptr="0xa89631b0" next="0xa8963240" prev="0xa8963120" upper="0xa6bfee48" lower="(nil)">            x = y;<Finish/></txt><txt ptr="0xa8963240" next="0xa89632d0" prev="0xa89631b0" upper="0xa6bfee48" lower="(nil)">            y = tmp;<Finish/></txt><txt ptr="0xa89632d0" next="0xa8963360" prev="0xa8963240" upper="0xa6bfee48" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8963360" next="0xa89633f0" prev="0xa89632d0" upper="0xa6bfee48" lower="(nil)">        printf(&quot;%d\n&quot;, E[ Query(x, y) ]);<Finish/></txt><txt ptr="0xa89633f0" next="0xa8963480" prev="0xa8963360" upper="0xa6bfee48" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8963480" next="0xa8963510" prev="0xa89633f0" upper="0xa6bfee48" lower="(nil)">}<Finish/></txt><txt ptr="0xa8963510" next="0xa89635a0" prev="0xa8963480" upper="0xa6bfee48" lower="(nil)">void DFS(int u, int d) {<Finish/></txt><txt ptr="0xa89635a0" next="0xa8963630" prev="0xa8963510" upper="0xa6bfee48" lower="(nil)">    visited[u] = 1;<Finish/></txt><txt ptr="0xa8963630" next="0xa89636c0" prev="0xa89635a0" upper="0xa6bfee48" lower="(nil)">    R[u] = id;<Finish/></txt><txt ptr="0xa89636c0" next="0xa8963750" prev="0xa8963630" upper="0xa6bfee48" lower="(nil)">    E[id] = u;<Finish/></txt><txt ptr="0xa8963750" next="0xa89637e0" prev="0xa89636c0" upper="0xa6bfee48" lower="(nil)">    dep[id++] = d;<Finish/></txt><txt ptr="0xa89637e0" next="0xa8963870" prev="0xa8963750" upper="0xa6bfee48" lower="(nil)">    for( int i=head[u]; i != -1; i=next[i] )<Finish/></txt><txt ptr="0xa8963870" next="0xa8963900" prev="0xa89637e0" upper="0xa6bfee48" lower="(nil)">        if( visited[ pnt[i] ] == 0 ) {<Finish/></txt><txt ptr="0xa8963900" next="0xa8963990" prev="0xa8963870" upper="0xa6bfee48" lower="(nil)">            DFS(pnt[i], d+1);<Finish/></txt><txt ptr="0xa8963990" next="0xa8963a20" prev="0xa8963900" upper="0xa6bfee48" lower="(nil)">            E[id] = u;<Finish/></txt><txt ptr="0xa8963a20" next="0xa8963ab0" prev="0xa8963990" upper="0xa6bfee48" lower="(nil)">            dep[id++] = d;<Finish/></txt><txt ptr="0xa8963ab0" next="0xa8963b40" prev="0xa8963a20" upper="0xa6bfee48" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8963b40" next="0xa8963bd0" prev="0xa8963ab0" upper="0xa6bfee48" lower="(nil)">}<Finish/></txt><txt ptr="0xa8963bd0" next="0xa8963f30" prev="0xa8963b40" upper="0xa6bfee48" lower="(nil)"><Finish/></txt><txt ptr="0xa8963f30" next="0xa8964004" prev="0xa8963bd0" upper="0xa6bfee48" lower="(nil)">离线算法（Tarjan算法）<Finish/></txt><txt ptr="0xa8964004" next="0xa8964094" prev="0xa8963f30" upper="0xa6bfee48" lower="(nil)">所谓离线算法，是指首先读入所有的询问（求一次LCA叫做一次询问），然后重新组织查询处理顺序以便得到更高效的处理方法。Tarjan算法是一个常见的用于解决LCA问题的离线算法，它结合了深度优先遍历和并查集，整个算法为线性处理时间。<Finish/></txt><txt ptr="0xa8964094" next="(nil)" prev="0xa8964004" upper="0xa6bfee48" lower="(nil)" follow="0xa88eeab4">Tarjan算法是基于并查集的，利用并查集优越的时空复杂度，可以实现LCA问题的O(n+Q)算法，这里Q表示询问 的次数。<Finish/></txt></body></column><column ptr="0xa6c00ea4" next="0xa6c00f08" prev="0xa6c00e40" upper="0xa998cc04" lower="0xa6bfeea8"><body ptr="0xa6bfeea8" next="(nil)" prev="(nil)" upper="0xa6c00ea4" lower="0xa88eeab4"><txt ptr="0xa88eeab4" next="0xa8964124" prev="(nil)" upper="0xa6bfeea8" lower="(nil)" precede="0xa8964094">Tarjan算法是基于并查集的，利用并查集优越的时空复杂度，可以实现LCA问题的O(n+Q)算法，这里Q表示询问 的次数。<Finish/></txt><txt ptr="0xa8964124" next="0xa89641b4" prev="0xa88eeab4" upper="0xa6bfeea8" lower="(nil)">同上一个算法一样，Tarjan算法也要用到深度优先搜索，算法大体流程如下：对于新搜索到的一个结点，首先创建由这个结点构成的集合，再对当前结点的每一个子树进行搜索，每搜索完一棵子树，则可确定子树内的LCA询问都已解决。其他的LCA询问的结果必然在这个子树之外，这时把子树所形成的集合与当前结点的集合合并，并将当前结点设为这个集合的祖先。之后继续搜索下一棵子树，直到当前结点的所有子树搜索完。这时把当前结点也设为已被检查过的，同时可以处理有关当前结点的LCA询问，如果有一个从当前结点到结点v的询问，且v已被检查过，则由于进行的是深度优先搜索，当前结点与v的最近公共祖先一定还没有被检查，而这个最近公共祖先的包涵v的子树一定已经搜索过了，那么这个最近公共祖先一定是v所在集合的祖先。<Finish/></txt><txt ptr="0xa89641b4" next="0xa8964244" prev="0xa8964124" upper="0xa6bfeea8" lower="(nil)">代码实现<Finish/></txt><txt ptr="0xa8964244" next="0xa89642d4" prev="0xa89641b4" upper="0xa6bfeea8" lower="(nil)">int id[N];//初始化-1<Finish/></txt><txt ptr="0xa89642d4" next="0xa8964364" prev="0xa8964244" upper="0xa6bfeea8" lower="(nil)">int lcs[N][N], <Finish/></txt><txt ptr="0xa8964364" next="0xa89643f4" prev="0xa89642d4" upper="0xa6bfeea8" lower="(nil)">int g[N][N];//邻接矩阵<Finish/></txt><txt ptr="0xa89643f4" next="0xa8964484" prev="0xa8964364" upper="0xa6bfeea8" lower="(nil)">int get(int i) {<Finish/></txt><txt ptr="0xa8964484" next="0xa8964514" prev="0xa89643f4" upper="0xa6bfeea8" lower="(nil)">    if (id[i] == i) return i;<Finish/></txt><txt ptr="0xa8964514" next="0xa89645a4" prev="0xa8964484" upper="0xa6bfeea8" lower="(nil)">    return id[i] = get(id[i]);<Finish/></txt><txt ptr="0xa89645a4" next="0xa8964634" prev="0xa8964514" upper="0xa6bfeea8" lower="(nil)">}<Finish/></txt><txt ptr="0xa8964634" next="0xa89646c4" prev="0xa89645a4" upper="0xa6bfeea8" lower="(nil)">void unin(int i, int j) {<Finish/></txt><txt ptr="0xa89646c4" next="0xa8964754" prev="0xa8964634" upper="0xa6bfeea8" lower="(nil)">    id[get(i)] = get(j);<Finish/></txt><txt ptr="0xa8964754" next="(nil)" prev="0xa89646c4" upper="0xa6bfeea8" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa6c00f08" next="(nil)" prev="0xa6c00ea4" upper="0xa998cc04" lower="0xa6bfef08"><body ptr="0xa6bfef08" next="(nil)" prev="(nil)" upper="0xa6c00f08" lower="0xa89647e4"><txt ptr="0xa89647e4" next="0xa8964874" prev="(nil)" upper="0xa6bfef08" lower="(nil)">void dfs(int rt, int n) {<Finish/></txt><txt ptr="0xa8964874" next="0xa8964904" prev="0xa89647e4" upper="0xa6bfef08" lower="(nil)">    int i;<Finish/></txt><txt ptr="0xa8964904" next="0xa8964994" prev="0xa8964874" upper="0xa6bfef08" lower="(nil)">    id[rt] = rt;<Finish/></txt><txt ptr="0xa8964994" next="0xa8964a24" prev="0xa8964904" upper="0xa6bfef08" lower="(nil)">    for (i = 0; i &lt; n; ++i) if (g[rt][i] &amp;&amp; -1 == id[i]) {<Finish/></txt><txt ptr="0xa8964a24" next="0xa8964ab4" prev="0xa8964994" upper="0xa6bfef08" lower="(nil)">            dfs(i, n);<Finish/></txt><txt ptr="0xa8964ab4" next="0xa8964b44" prev="0xa8964a24" upper="0xa6bfef08" lower="(nil)">            unin(i, rt);<Finish/></txt><txt ptr="0xa8964b44" next="0xa8964bd4" prev="0xa8964ab4" upper="0xa6bfef08" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8964bd4" next="0xa8964c64" prev="0xa8964b44" upper="0xa6bfef08" lower="(nil)">    for (i = 0; i &lt; n; ++i) if (-1 != id[i])<Finish/></txt><txt ptr="0xa8964c64" next="0xa8964cf4" prev="0xa8964bd4" upper="0xa6bfef08" lower="(nil)">            lcs[rt][i] = lcs[i][rt] = get(i);<Finish/></txt><txt ptr="0xa8964cf4" next="0xa8964d84" prev="0xa8964c64" upper="0xa6bfef08" lower="(nil)">}<Finish/></txt><txt ptr="0xa8964d84" next="0xa8964e14" prev="0xa8964cf4" upper="0xa6bfef08" lower="(nil)">矩阵相乘DP<Finish/></txt><txt ptr="0xa8964e14" next="0xa8964ea4" prev="0xa8964d84" upper="0xa6bfef08" lower="(nil)">求矩阵状态<Finish/></txt><txt ptr="0xa8964ea4" next="0xa8964f34" prev="0xa8964e14" upper="0xa6bfef08" lower="(nil)"><Finish/></txt><txt ptr="0xa8964f34" next="0xa8965008" prev="0xa8964ea4" upper="0xa6bfef08" lower="(nil)">bool state[513];<Finish/></txt><txt ptr="0xa8965008" next="0xa8965098" prev="0xa8964f34" upper="0xa6bfef08" lower="(nil)">int _map[513];<Finish/></txt><txt ptr="0xa8965098" next="0xa8965128" prev="0xa8965008" upper="0xa6bfef08" lower="(nil)">int _map_num;<Finish/></txt><txt ptr="0xa8965128" next="0xa89651b8" prev="0xa8965098" upper="0xa6bfef08" lower="(nil)">int str[513][513];<Finish/></txt><txt ptr="0xa89651b8" next="0xa8965518" prev="0xa8965128" upper="0xa6bfef08" lower="(nil)">int _val_map[513];<Finish/></txt><txt ptr="0xa8965518" next="0xa89655a8" prev="0xa89651b8" upper="0xa6bfef08" lower="(nil)"><Finish/></txt><txt ptr="0xa89655a8" next="0xa8965638" prev="0xa8965518" upper="0xa6bfef08" lower="(nil)">//第bit位置为1 val,val可以是0或1，bit是1~8<Finish/></txt><txt ptr="0xa8965638" next="0xa89656c8" prev="0xa89655a8" upper="0xa6bfef08" lower="(nil)">void setBit(int&amp; now,int bit,int val = 1) {<Finish/></txt><txt ptr="0xa89656c8" next="0xa8965758" prev="0xa8965638" upper="0xa6bfef08" lower="(nil)">    bit--;<Finish/></txt><txt ptr="0xa8965758" next="0xa89657e8" prev="0xa89656c8" upper="0xa6bfef08" lower="(nil)">    if(val == 1) {<Finish/></txt><txt ptr="0xa89657e8" next="0xa8965878" prev="0xa8965758" upper="0xa6bfef08" lower="(nil)">        now |= (1&lt;&lt;bit);<Finish/></txt><txt ptr="0xa8965878" next="0xa8965908" prev="0xa89657e8" upper="0xa6bfef08" lower="(nil)">    } else {<Finish/></txt><txt ptr="0xa8965908" next="0xa8965998" prev="0xa8965878" upper="0xa6bfef08" lower="(nil)">        now &amp;= ~(1&lt;&lt;bit);<Finish/></txt><txt ptr="0xa8965998" next="(nil)" prev="0xa8965908" upper="0xa6bfef08" lower="(nil)">    }<Finish/></txt></body></column></section></body><footer ptr="0xa89989c0" next="(nil)" prev="0xa999c908" upper="0xa8993c3c" lower="0xa99a72d0"><txt ptr="0xa99a72d0" next="0xa99a7480" prev="(nil)" upper="0xa89989c0" lower="(nil)"><anchored><fly ptr="0xa4fdcc8" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99a7360"><txt ptr="0xa99a7360" next="0xa99a73f0" prev="(nil)" upper="0xa4fdcc8" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99a73f0" next="(nil)" prev="0xa99a7360" upper="0xa4fdcc8" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="2"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="9"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99a7480" next="(nil)" prev="0xa99a72d0" upper="0xa89989c0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993cb0" next="0xa8993d24" prev="0xa8993c3c" upper="0xb0726b0" lower="0xa8996a20"><header ptr="0xa8996a20" next="0xa999ca88" prev="(nil)" upper="0xa8993cb0" lower="0xa99a87e4"><txt ptr="0xa99a87e4" next="(nil)" prev="(nil)" upper="0xa8996a20" lower="(nil)"><Finish/></txt></header><body ptr="0xa999ca88" next="0xa8998a20" prev="0xa8996a20" upper="0xa8993cb0" lower="0xa998ca84"><section ptr="0xa998ca84" next="(nil)" prev="(nil)" upper="0xa999ca88" lower="0xa6c010fc" follow="0xa998c904" precede="0xa998cc04"><column ptr="0xa6c010fc" next="0xa6c01160" prev="(nil)" upper="0xa998ca84" lower="0xa6c020cc"><body ptr="0xa6c020cc" next="(nil)" prev="(nil)" upper="0xa6c010fc" lower="0xa8965a28"><txt ptr="0xa8965a28" next="0xa8965ab8" prev="(nil)" upper="0xa6c020cc" lower="(nil)">}<Finish/></txt><txt ptr="0xa8965ab8" next="0xa8965b48" prev="0xa8965a28" upper="0xa6c020cc" lower="(nil)">//得到第bit位的值<Finish/></txt><txt ptr="0xa8965b48" next="0xa8965bd8" prev="0xa8965ab8" upper="0xa6c020cc" lower="(nil)">int getBit(int now,int bit) {<Finish/></txt><txt ptr="0xa8965bd8" next="0xa8965c68" prev="0xa8965b48" upper="0xa6c020cc" lower="(nil)">    bit--;<Finish/></txt><txt ptr="0xa8965c68" next="0xa8965cf8" prev="0xa8965bd8" upper="0xa6c020cc" lower="(nil)">    return (now&gt;&gt;bit)&amp;1;<Finish/></txt><txt ptr="0xa8965cf8" next="0xa8965d88" prev="0xa8965c68" upper="0xa6c020cc" lower="(nil)">}<Finish/></txt><txt ptr="0xa8965d88" next="0xa8965e18" prev="0xa8965cf8" upper="0xa6c020cc" lower="(nil)">//输出c的二进制<Finish/></txt><txt ptr="0xa8965e18" next="0xa8965ea8" prev="0xa8965d88" upper="0xa6c020cc" lower="(nil)">void outputState(int c) {<Finish/></txt><txt ptr="0xa8965ea8" next="0xa8965f38" prev="0xa8965e18" upper="0xa6c020cc" lower="(nil)">    printf(&quot;,\&quot;&quot;);<Finish/></txt><txt ptr="0xa8965f38" next="0xa896600c" prev="0xa8965ea8" upper="0xa6c020cc" lower="(nil)">    for(int i=8; i; i--) {<Finish/></txt><txt ptr="0xa896600c" next="0xa896609c" prev="0xa8965f38" upper="0xa6c020cc" lower="(nil)">        printf(&quot;%d&quot;,getBit(c,i));<Finish/></txt><txt ptr="0xa896609c" next="0xa896612c" prev="0xa896600c" upper="0xa6c020cc" lower="(nil)">    }<Finish/></txt><txt ptr="0xa896612c" next="0xa89661bc" prev="0xa896609c" upper="0xa6c020cc" lower="(nil)">    printf(&quot;\&quot;\n&quot;);<Finish/></txt><txt ptr="0xa89661bc" next="0xa896624c" prev="0xa896612c" upper="0xa6c020cc" lower="(nil)">}<Finish/></txt><txt ptr="0xa896624c" next="0xa89662dc" prev="0xa89661bc" upper="0xa6c020cc" lower="(nil)">//添加状态c<Finish/></txt><txt ptr="0xa89662dc" next="0xa896636c" prev="0xa896624c" upper="0xa6c020cc" lower="(nil)">int addState(int c) {<Finish/></txt><txt ptr="0xa896636c" next="0xa89663fc" prev="0xa89662dc" upper="0xa6c020cc" lower="(nil)">    if(state[c] == false) {<Finish/></txt><txt ptr="0xa89663fc" next="0xa896648c" prev="0xa896636c" upper="0xa6c020cc" lower="(nil)">        state[c] = true;<Finish/></txt><txt ptr="0xa896648c" next="0xa896651c" prev="0xa89663fc" upper="0xa6c020cc" lower="(nil)">        _map[_map_num] = c;<Finish/></txt><txt ptr="0xa896651c" next="0xa89665ac" prev="0xa896648c" upper="0xa6c020cc" lower="(nil)">        _val_map[c] = _map_num;<Finish/></txt><txt ptr="0xa89665ac" next="0xa896663c" prev="0xa896651c" upper="0xa6c020cc" lower="(nil)">        _map_num++;<Finish/></txt><txt ptr="0xa896663c" next="0xa89666cc" prev="0xa89665ac" upper="0xa6c020cc" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89666cc" next="0xa896675c" prev="0xa896663c" upper="0xa6c020cc" lower="(nil)">    return _val_map[c];<Finish/></txt><txt ptr="0xa896675c" next="0xa8966abc" prev="0xa89666cc" upper="0xa6c020cc" lower="(nil)">}<Finish/></txt><txt ptr="0xa8966abc" next="0xa8966b4c" prev="0xa896675c" upper="0xa6c020cc" lower="(nil)">//判断now是否全1<Finish/></txt><txt ptr="0xa8966b4c" next="0xa8966bdc" prev="0xa8966abc" upper="0xa6c020cc" lower="(nil)">bool isPutAll(int now) {<Finish/></txt><txt ptr="0xa8966bdc" next="0xa8966c6c" prev="0xa8966b4c" upper="0xa6c020cc" lower="(nil)">    return now == 255;<Finish/></txt><txt ptr="0xa8966c6c" next="(nil)" prev="0xa8966bdc" upper="0xa6c020cc" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa6c01160" next="0xa6c011c4" prev="0xa6c010fc" upper="0xa998ca84" lower="0xa6c0212c"><body ptr="0xa6c0212c" next="(nil)" prev="(nil)" upper="0xa6c01160" lower="0xa8966cfc"><txt ptr="0xa8966cfc" next="0xa8966d8c" prev="(nil)" upper="0xa6c0212c" lower="(nil)">//深搜得到状态<Finish/></txt><txt ptr="0xa8966d8c" next="0xa8966e1c" prev="0xa8966cfc" upper="0xa6c0212c" lower="(nil)">void dfs(int lev,int now,int next) {<Finish/></txt><txt ptr="0xa8966e1c" next="0xa8966eac" prev="0xa8966d8c" upper="0xa6c0212c" lower="(nil)">    int nextState,i;<Finish/></txt><txt ptr="0xa8966eac" next="0xa8966f3c" prev="0xa8966e1c" upper="0xa6c0212c" lower="(nil)"><Finish/></txt><txt ptr="0xa8966f3c" next="0xa8968010" prev="0xa8966eac" upper="0xa6c0212c" lower="(nil)">    if(isPutAll(now)) {<Finish/></txt><txt ptr="0xa8968010" next="0xa89680a0" prev="0xa8966f3c" upper="0xa6c0212c" lower="(nil)">        nextState = addState(next);<Finish/></txt><txt ptr="0xa89680a0" next="0xa8968130" prev="0xa8968010" upper="0xa6c0212c" lower="(nil)">        str[lev][nextState]++;<Finish/></txt><txt ptr="0xa8968130" next="0xa89681c0" prev="0xa89680a0" upper="0xa6c0212c" lower="(nil)">        return ;<Finish/></txt><txt ptr="0xa89681c0" next="0xa8968250" prev="0xa8968130" upper="0xa6c0212c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8968250" next="0xa89682e0" prev="0xa89681c0" upper="0xa6c0212c" lower="(nil)"><Finish/></txt><txt ptr="0xa89682e0" next="0xa8968370" prev="0xa8968250" upper="0xa6c0212c" lower="(nil)">    //视情况修改<Finish/></txt><txt ptr="0xa8968370" next="0xa8968400" prev="0xa89682e0" upper="0xa6c0212c" lower="(nil)">    if(getBit(now,8) == 0 &amp;&amp; getBit(now,1) == 0) {<Finish/></txt><txt ptr="0xa8968400" next="0xa8968490" prev="0xa8968370" upper="0xa6c0212c" lower="(nil)">        setBit(now,8,1);<Finish/></txt><txt ptr="0xa8968490" next="0xa8968520" prev="0xa8968400" upper="0xa6c0212c" lower="(nil)">        setBit(now,1,1);<Finish/></txt><txt ptr="0xa8968520" next="0xa89685b0" prev="0xa8968490" upper="0xa6c0212c" lower="(nil)">        dfs(lev,now,next);<Finish/></txt><txt ptr="0xa89685b0" next="0xa8968640" prev="0xa8968520" upper="0xa6c0212c" lower="(nil)">        setBit(now,8,0);<Finish/></txt><txt ptr="0xa8968640" next="0xa89686d0" prev="0xa89685b0" upper="0xa6c0212c" lower="(nil)">        setBit(now,1,0);<Finish/></txt><txt ptr="0xa89686d0" next="0xa8968760" prev="0xa8968640" upper="0xa6c0212c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8968760" next="0xa89687f0" prev="0xa89686d0" upper="0xa6c0212c" lower="(nil)"><Finish/></txt><txt ptr="0xa89687f0" next="0xa8968880" prev="0xa8968760" upper="0xa6c0212c" lower="(nil)">    for(i=8; i&gt;0; i--) {<Finish/></txt><txt ptr="0xa8968880" next="0xa8968910" prev="0xa89687f0" upper="0xa6c0212c" lower="(nil)">        if(getBit(now,i) == 0) {<Finish/></txt><txt ptr="0xa8968910" next="0xa89689a0" prev="0xa8968880" upper="0xa6c0212c" lower="(nil)">            setBit(now,i,1);<Finish/></txt><txt ptr="0xa89689a0" next="0xa8968a30" prev="0xa8968910" upper="0xa6c0212c" lower="(nil)">            setBit(next,i,1);<Finish/></txt><txt ptr="0xa8968a30" next="0xa8968ac0" prev="0xa89689a0" upper="0xa6c0212c" lower="(nil)">            dfs(lev,now,next);<Finish/></txt><txt ptr="0xa8968ac0" next="0xa8968b50" prev="0xa8968a30" upper="0xa6c0212c" lower="(nil)">            setBit(now,i,0);<Finish/></txt><txt ptr="0xa8968b50" next="0xa8968be0" prev="0xa8968ac0" upper="0xa6c0212c" lower="(nil)">            setBit(next,i,0);<Finish/></txt><txt ptr="0xa8968be0" next="0xa8968c70" prev="0xa8968b50" upper="0xa6c0212c" lower="(nil)">            break;<Finish/></txt><txt ptr="0xa8968c70" next="(nil)" prev="0xa8968be0" upper="0xa6c0212c" lower="(nil)">        }<Finish/></txt></body></column><column ptr="0xa6c011c4" next="(nil)" prev="0xa6c01160" upper="0xa998ca84" lower="0xa6c0218c"><body ptr="0xa6c0218c" next="(nil)" prev="(nil)" upper="0xa6c011c4" lower="0xa8968d00"><txt ptr="0xa8968d00" next="0xa89690a4" prev="(nil)" upper="0xa6c0218c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89690a4" next="0xa8969134" prev="0xa8968d00" upper="0xa6c0218c" lower="(nil)"><Finish/></txt><txt ptr="0xa8969134" next="0xa89691c4" prev="0xa89690a4" upper="0xa6c0218c" lower="(nil)">    for(i=8; i&gt;1; i--) {<Finish/></txt><txt ptr="0xa89691c4" next="0xa8969254" prev="0xa8969134" upper="0xa6c0218c" lower="(nil)">        if(getBit(now,i) == 0) {<Finish/></txt><txt ptr="0xa8969254" next="0xa89692e4" prev="0xa89691c4" upper="0xa6c0218c" lower="(nil)">            if(getBit(now,i-1) == 0) {<Finish/></txt><txt ptr="0xa89692e4" next="0xa8969374" prev="0xa8969254" upper="0xa6c0218c" lower="(nil)">                setBit(now,i,1);<Finish/></txt><txt ptr="0xa8969374" next="0xa8969404" prev="0xa89692e4" upper="0xa6c0218c" lower="(nil)">                setBit(now,i-1,1);<Finish/></txt><txt ptr="0xa8969404" next="0xa8969494" prev="0xa8969374" upper="0xa6c0218c" lower="(nil)">                dfs(lev,now,next);<Finish/></txt><txt ptr="0xa8969494" next="0xa8969524" prev="0xa8969404" upper="0xa6c0218c" lower="(nil)">                setBit(now,i,0);<Finish/></txt><txt ptr="0xa8969524" next="0xa89695b4" prev="0xa8969494" upper="0xa6c0218c" lower="(nil)">                setBit(now,i-1,0);<Finish/></txt><txt ptr="0xa89695b4" next="0xa8969644" prev="0xa8969524" upper="0xa6c0218c" lower="(nil)">            }<Finish/></txt><txt ptr="0xa8969644" next="0xa89696d4" prev="0xa89695b4" upper="0xa6c0218c" lower="(nil)">            break;<Finish/></txt><txt ptr="0xa89696d4" next="0xa8969764" prev="0xa8969644" upper="0xa6c0218c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8969764" next="0xa89697f4" prev="0xa89696d4" upper="0xa6c0218c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89697f4" next="0xa8969884" prev="0xa8969764" upper="0xa6c0218c" lower="(nil)">}<Finish/></txt><txt ptr="0xa8969884" next="0xa8969914" prev="0xa89697f4" upper="0xa6c0218c" lower="(nil)">//生成状态<Finish/></txt><txt ptr="0xa8969914" next="0xa89699a4" prev="0xa8969884" upper="0xa6c0218c" lower="(nil)">void bornState() {<Finish/></txt><txt ptr="0xa89699a4" next="0xa8969a34" prev="0xa8969914" upper="0xa6c0218c" lower="(nil)"><Finish/></txt><txt ptr="0xa8969a34" next="0xa8969ac4" prev="0xa89699a4" upper="0xa6c0218c" lower="(nil)">    memset(state,false,sizeof(state));<Finish/></txt><txt ptr="0xa8969ac4" next="0xa8969b54" prev="0xa8969a34" upper="0xa6c0218c" lower="(nil)">    _map_num = 0;<Finish/></txt><txt ptr="0xa8969b54" next="0xa8969be4" prev="0xa8969ac4" upper="0xa6c0218c" lower="(nil)">    memset(str,0,sizeof(str));<Finish/></txt><txt ptr="0xa8969be4" next="0xa8969c74" prev="0xa8969b54" upper="0xa6c0218c" lower="(nil)"><Finish/></txt><txt ptr="0xa8969c74" next="0xa8969d04" prev="0xa8969be4" upper="0xa6c0218c" lower="(nil)">    addState(0);<Finish/></txt><txt ptr="0xa8969d04" next="0xa8969d94" prev="0xa8969c74" upper="0xa6c0218c" lower="(nil)"><Finish/></txt><txt ptr="0xa8969d94" next="0xa8969e24" prev="0xa8969d04" upper="0xa6c0218c" lower="(nil)">    for(int i=0; i&lt;_map_num; i++) {<Finish/></txt><txt ptr="0xa8969e24" next="0xa8969eb4" prev="0xa8969d94" upper="0xa6c0218c" lower="(nil)">        dfs(i,_map[i],0);<Finish/></txt><txt ptr="0xa8969eb4" next="0xa8969f44" prev="0xa8969e24" upper="0xa6c0218c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8969f44" next="(nil)" prev="0xa8969eb4" upper="0xa6c0218c" lower="(nil)">}<Finish/></txt></body></column></section></body><footer ptr="0xa8998a20" next="(nil)" prev="0xa999ca88" upper="0xa8993cb0" lower="0xa99a8874"><txt ptr="0xa99a8874" next="0xa99a8a24" prev="(nil)" upper="0xa8998a20" lower="(nil)"><anchored><fly ptr="0xa527e98" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99a8904"><txt ptr="0xa99a8904" next="0xa99a8994" prev="(nil)" upper="0xa527e98" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99a8994" next="(nil)" prev="0xa99a8904" upper="0xa527e98" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="3"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="0"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99a8a24" next="(nil)" prev="0xa99a8874" upper="0xa8998a20" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993d24" next="0xa8993d98" prev="0xa8993cb0" upper="0xb0726b0" lower="0xa8996a80"><header ptr="0xa8996a80" next="0xa999cc08" prev="(nil)" upper="0xa8993d24" lower="0xa99a9d88"><txt ptr="0xa99a9d88" next="(nil)" prev="(nil)" upper="0xa8996a80" lower="(nil)"><Finish/></txt></header><body ptr="0xa999cc08" next="0xa8998a80" prev="0xa8996a80" upper="0xa8993d24" lower="0xa998c904"><section ptr="0xa998c904" next="(nil)" prev="(nil)" upper="0xa999cc08" lower="0xa6c01354" follow="0xa998c704" precede="0xa998ca84"><column ptr="0xa6c01354" next="0xa6c013b8" prev="(nil)" upper="0xa998c904" lower="0xa6c0230c"><body ptr="0xa6c0230c" next="(nil)" prev="(nil)" upper="0xa6c01354" lower="0xa896a018"><txt ptr="0xa896a018" next="0xa896a0a8" prev="(nil)" upper="0xa6c0230c" lower="(nil)">使用矩阵幂求答案<Finish/></txt><txt ptr="0xa896a0a8" next="0xa896a138" prev="0xa896a018" upper="0xa6c0230c" lower="(nil)">    bornState();<Finish/></txt><txt ptr="0xa896a138" next="0xa896a1c8" prev="0xa896a0a8" upper="0xa6c0230c" lower="(nil)">    sz = _map_num;<Finish/></txt><txt ptr="0xa896a1c8" next="0xa896a258" prev="0xa896a138" upper="0xa6c0230c" lower="(nil)">    Matrix matrix,ans;<Finish/></txt><txt ptr="0xa896a258" next="0xa896a2e8" prev="0xa896a1c8" upper="0xa6c0230c" lower="(nil)">    int n,m;<Finish/></txt><txt ptr="0xa896a2e8" next="0xa896a648" prev="0xa896a258" upper="0xa6c0230c" lower="(nil)">    matrix.init(str);//矩阵需要添加这个函数<Finish/></txt><txt ptr="0xa896a648" next="0xa896a6d8" prev="0xa896a2e8" upper="0xa6c0230c" lower="(nil)">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m),n) {<Finish/></txt><txt ptr="0xa896a6d8" next="0xa896a768" prev="0xa896a648" upper="0xa6c0230c" lower="(nil)">        MOD = m;<Finish/></txt><txt ptr="0xa896a768" next="0xa896a7f8" prev="0xa896a6d8" upper="0xa6c0230c" lower="(nil)">        ans = matrix.pow(n);<Finish/></txt><txt ptr="0xa896a7f8" next="0xa896a888" prev="0xa896a768" upper="0xa6c0230c" lower="(nil)">        printf(&quot;%d\n&quot;,ans.a[0][0]);<Finish/></txt><txt ptr="0xa896a888" next="0xa896a918" prev="0xa896a7f8" upper="0xa6c0230c" lower="(nil)">}<Finish/></txt><txt ptr="0xa896a918" next="0xa896a9a8" prev="0xa896a888" upper="0xa6c0230c" lower="(nil)"><Finish/></txt><txt ptr="0xa896a9a8" next="0xa896aa38" prev="0xa896a918" upper="0xa6c0230c" lower="(nil)"><Finish/></txt><txt ptr="0xa896aa38" next="0xa896aac8" prev="0xa896a9a8" upper="0xa6c0230c" lower="(nil)"><Finish/></txt><txt ptr="0xa896aac8" next="0xa896ab58" prev="0xa896aa38" upper="0xa6c0230c" lower="(nil)"><Finish/></txt><txt ptr="0xa896ab58" next="0xa896abe8" prev="0xa896aac8" upper="0xa6c0230c" lower="(nil)"><Finish/></txt><txt ptr="0xa896abe8" next="0xa896ac78" prev="0xa896ab58" upper="0xa6c0230c" lower="(nil)"><Finish/></txt><txt ptr="0xa896ac78" next="0xa896ad08" prev="0xa896abe8" upper="0xa6c0230c" lower="(nil)">DFA+DP<Finish/></txt><txt ptr="0xa896ad08" next="0xa896ad98" prev="0xa896ac78" upper="0xa6c0230c" lower="(nil)">区间个数询问<Finish/></txt><txt ptr="0xa896ad98" next="0xa896ae28" prev="0xa896ad08" upper="0xa6c0230c" lower="(nil)">对于一个数字，首先把这个数字存在数组中<Finish/></txt><txt ptr="0xa896ae28" next="0xa896aeb8" prev="0xa896ad98" upper="0xa6c0230c" lower="(nil)">typedef  long long LL;<Finish/></txt><txt ptr="0xa896aeb8" next="0xa896af48" prev="0xa896ae28" upper="0xa6c0230c" lower="(nil)">int str[100];<Finish/></txt><txt ptr="0xa896af48" next="0xa896b01c" prev="0xa896aeb8" upper="0xa6c0230c" lower="(nil)">LL _sum[100][30][30];<Finish/></txt><txt ptr="0xa896b01c" next="0xa896b0ac" prev="0xa896af48" upper="0xa6c0230c" lower="(nil)">int len;<Finish/></txt><txt ptr="0xa896b0ac" next="0xa896b13c" prev="0xa896b01c" upper="0xa6c0230c" lower="(nil)">int x,y;<Finish/></txt><txt ptr="0xa896b13c" next="0xa896b1cc" prev="0xa896b0ac" upper="0xa6c0230c" lower="(nil)">LL dfs(int pos, int x_num, int y_num, bool yes) {<Finish/></txt><txt ptr="0xa896b1cc" next="(nil)" prev="0xa896b13c" upper="0xa6c0230c" lower="(nil)">    if(pos &lt; 0) {//判断是否结束<Finish/></txt></body></column><column ptr="0xa6c013b8" next="0xa6c0141c" prev="0xa6c01354" upper="0xa998c904" lower="0xa6c0236c"><body ptr="0xa6c0236c" next="(nil)" prev="(nil)" upper="0xa6c013b8" lower="0xa896b25c"><txt ptr="0xa896b25c" next="0xa896b2ec" prev="(nil)" upper="0xa6c0236c" lower="(nil)">        return x_num == x &amp;&amp; y_num == y;<Finish/></txt><txt ptr="0xa896b2ec" next="0xa896b37c" prev="0xa896b25c" upper="0xa6c0236c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa896b37c" next="0xa896b40c" prev="0xa896b2ec" upper="0xa6c0236c" lower="(nil)">    if(x_num &gt; x || y_num &gt; y) {<Finish/></txt><txt ptr="0xa896b40c" next="0xa896b49c" prev="0xa896b37c" upper="0xa6c0236c" lower="(nil)">        return 0;//判断是否已经不满足条件<Finish/></txt><txt ptr="0xa896b49c" next="0xa896b52c" prev="0xa896b40c" upper="0xa6c0236c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa896b52c" next="0xa896b5bc" prev="0xa896b49c" upper="0xa6c0236c" lower="(nil)">//判断是否已经是999且已经计算过。<Finish/></txt><txt ptr="0xa896b5bc" next="0xa896b64c" prev="0xa896b52c" upper="0xa6c0236c" lower="(nil)">    if(yes &amp;&amp; _sum[pos][x_num][y_num] != -1) {<Finish/></txt><txt ptr="0xa896b64c" next="0xa896b6dc" prev="0xa896b5bc" upper="0xa6c0236c" lower="(nil)">        return _sum[pos][x_num][y_num];<Finish/></txt><txt ptr="0xa896b6dc" next="0xa896b76c" prev="0xa896b64c" upper="0xa6c0236c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa896b76c" next="0xa896b7fc" prev="0xa896b6dc" upper="0xa6c0236c" lower="(nil)">//没计算过，开始计算<Finish/></txt><txt ptr="0xa896b7fc" next="0xa896b88c" prev="0xa896b76c" upper="0xa6c0236c" lower="(nil)">    LL ans = 0;<Finish/></txt><txt ptr="0xa896b88c" next="0xa896bbec" prev="0xa896b7fc" upper="0xa6c0236c" lower="(nil)">    int _max = yes ? 9 : str[pos];<Finish/></txt><txt ptr="0xa896bbec" next="0xa896bc7c" prev="0xa896b88c" upper="0xa6c0236c" lower="(nil)">    for(int i=0; i&lt;=_max; i++) {<Finish/></txt><txt ptr="0xa896bc7c" next="0xa896bd0c" prev="0xa896bbec" upper="0xa6c0236c" lower="(nil)">        ans += dfs(pos-1, x_num + (i == 4), y_num + (i == 7), yes || i&lt;str[pos]);<Finish/></txt><txt ptr="0xa896bd0c" next="0xa896bd9c" prev="0xa896bc7c" upper="0xa6c0236c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa896bd9c" next="0xa896be2c" prev="0xa896bd0c" upper="0xa6c0236c" lower="(nil)">//保存计算过的<Finish/></txt><txt ptr="0xa896be2c" next="0xa896bebc" prev="0xa896bd9c" upper="0xa6c0236c" lower="(nil)">    if(yes) {<Finish/></txt><txt ptr="0xa896bebc" next="0xa896bf4c" prev="0xa896be2c" upper="0xa6c0236c" lower="(nil)">        _sum[pos][x_num][y_num] = ans;<Finish/></txt><txt ptr="0xa896bf4c" next="0xa896d020" prev="0xa896bebc" upper="0xa6c0236c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa896d020" next="0xa896d0b0" prev="0xa896bf4c" upper="0xa6c0236c" lower="(nil)"><Finish/></txt><txt ptr="0xa896d0b0" next="0xa896d140" prev="0xa896d020" upper="0xa6c0236c" lower="(nil)">    return ans;<Finish/></txt><txt ptr="0xa896d140" next="0xa896d1d0" prev="0xa896d0b0" upper="0xa6c0236c" lower="(nil)">}<Finish/></txt><txt ptr="0xa896d1d0" next="0xa896d260" prev="0xa896d140" upper="0xa6c0236c" lower="(nil)">//查询，一般是用[0, val]<Finish/></txt><txt ptr="0xa896d260" next="0xa896d2f0" prev="0xa896d1d0" upper="0xa6c0236c" lower="(nil)">LL query(LL val) {<Finish/></txt><txt ptr="0xa896d2f0" next="0xa896d380" prev="0xa896d260" upper="0xa6c0236c" lower="(nil)">    if(val &lt; 0) {<Finish/></txt><txt ptr="0xa896d380" next="0xa896d410" prev="0xa896d2f0" upper="0xa6c0236c" lower="(nil)">        return 0;<Finish/></txt><txt ptr="0xa896d410" next="(nil)" prev="0xa896d380" upper="0xa6c0236c" lower="(nil)">    }<Finish/></txt></body></column><column ptr="0xa6c0141c" next="(nil)" prev="0xa6c013b8" upper="0xa998c904" lower="0xa6c023cc"><body ptr="0xa6c023cc" next="(nil)" prev="(nil)" upper="0xa6c0141c" lower="0xa896d4a0"><txt ptr="0xa896d4a0" next="0xa896d530" prev="(nil)" upper="0xa6c023cc" lower="(nil)">    len = 0;<Finish/></txt><txt ptr="0xa896d530" next="0xa896d5c0" prev="0xa896d4a0" upper="0xa6c023cc" lower="(nil)">    if(val == 0) {<Finish/></txt><txt ptr="0xa896d5c0" next="0xa896d650" prev="0xa896d530" upper="0xa6c023cc" lower="(nil)">        str[len++] = val;<Finish/></txt><txt ptr="0xa896d650" next="0xa896d6e0" prev="0xa896d5c0" upper="0xa6c023cc" lower="(nil)">    } else {<Finish/></txt><txt ptr="0xa896d6e0" next="0xa896d770" prev="0xa896d650" upper="0xa6c023cc" lower="(nil)">        while(val) {<Finish/></txt><txt ptr="0xa896d770" next="0xa896d800" prev="0xa896d6e0" upper="0xa6c023cc" lower="(nil)">            str[len++] = val%10;<Finish/></txt><txt ptr="0xa896d800" next="0xa896d890" prev="0xa896d770" upper="0xa6c023cc" lower="(nil)">            val /= 10;<Finish/></txt><txt ptr="0xa896d890" next="0xa896d920" prev="0xa896d800" upper="0xa6c023cc" lower="(nil)">        }<Finish/></txt><txt ptr="0xa896d920" next="0xa896d9b0" prev="0xa896d890" upper="0xa6c023cc" lower="(nil)">    }<Finish/></txt><txt ptr="0xa896d9b0" next="0xa896da40" prev="0xa896d920" upper="0xa6c023cc" lower="(nil)">    return dfs(len-1,0,0,false);<Finish/></txt><txt ptr="0xa896da40" next="0xa896dad0" prev="0xa896d9b0" upper="0xa6c023cc" lower="(nil)">}<Finish/></txt><txt ptr="0xa896dad0" next="0xa896db60" prev="0xa896da40" upper="0xa6c023cc" lower="(nil)">区间内[left,right]第k个满足条件的<Finish/></txt><txt ptr="0xa896db60" next="0xa896dbf0" prev="0xa896dad0" upper="0xa6c023cc" lower="(nil)">二分查找<Finish/></txt><txt ptr="0xa896dbf0" next="0xa896dc80" prev="0xa896db60" upper="0xa6c023cc" lower="(nil)">LL query(LL left, LL right,  LL k) {<Finish/></txt><txt ptr="0xa896dc80" next="0xa896dd10" prev="0xa896dbf0" upper="0xa6c023cc" lower="(nil)"><Finish/></txt><txt ptr="0xa896dd10" next="0xa896dda0" prev="0xa896dc80" upper="0xa6c023cc" lower="(nil)">    LL ans_num =  query(left-1) + k;<Finish/></txt><txt ptr="0xa896dda0" next="0xa896de30" prev="0xa896dd10" upper="0xa6c023cc" lower="(nil)">    LL mid, mid_num;<Finish/></txt><txt ptr="0xa896de30" next="0xa894e1d4" prev="0xa896dda0" upper="0xa6c023cc" lower="(nil)">    while(left &lt; right) {<Finish/></txt><txt ptr="0xa894e1d4" next="0xa894e264" prev="0xa896de30" upper="0xa6c023cc" lower="(nil)">        mid = (left + right)/2;<Finish/></txt><txt ptr="0xa894e264" next="0xa894e2f4" prev="0xa894e1d4" upper="0xa6c023cc" lower="(nil)">        mid_num = query(mid);<Finish/></txt><txt ptr="0xa894e2f4" next="0xa894e384" prev="0xa894e264" upper="0xa6c023cc" lower="(nil)">        if(mid_num == ans_num){<Finish/></txt><txt ptr="0xa894e384" next="0xa894e414" prev="0xa894e2f4" upper="0xa6c023cc" lower="(nil)">            right = mid;<Finish/></txt><txt ptr="0xa894e414" next="0xa894e4a4" prev="0xa894e384" upper="0xa6c023cc" lower="(nil)">        }else if(mid_num &gt; ans_num) {<Finish/></txt><txt ptr="0xa894e4a4" next="0xa894e534" prev="0xa894e414" upper="0xa6c023cc" lower="(nil)">            right = mid - 1;<Finish/></txt><txt ptr="0xa894e534" next="0xa894e5c4" prev="0xa894e4a4" upper="0xa6c023cc" lower="(nil)">        } else {<Finish/></txt><txt ptr="0xa894e5c4" next="0xa894e654" prev="0xa894e534" upper="0xa6c023cc" lower="(nil)">            left = mid + 1;<Finish/></txt><txt ptr="0xa894e654" next="0xa894e6e4" prev="0xa894e5c4" upper="0xa6c023cc" lower="(nil)">        }<Finish/></txt><txt ptr="0xa894e6e4" next="(nil)" prev="0xa894e654" upper="0xa6c023cc" lower="(nil)">    }<Finish/></txt></body></column></section></body><footer ptr="0xa8998a80" next="(nil)" prev="0xa999cc08" upper="0xa8993d24" lower="0xa99a9e18"><txt ptr="0xa99a9e18" next="0xa998a00c" prev="(nil)" upper="0xa8998a80" lower="(nil)"><anchored><fly ptr="0xb4a7268" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99a9ea8"><txt ptr="0xa99a9ea8" next="0xa99a9f38" prev="(nil)" upper="0xb4a7268" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99a9f38" next="(nil)" prev="0xa99a9ea8" upper="0xb4a7268" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="3"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="1"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa998a00c" next="(nil)" prev="0xa99a9e18" upper="0xa8998a80" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993d98" next="0xa8993e0c" prev="0xa8993d24" upper="0xb0726b0" lower="0xa8996ae0"><header ptr="0xa8996ae0" next="0xa999cd88" prev="(nil)" upper="0xa8993d98" lower="0xa998b370"><txt ptr="0xa998b370" next="(nil)" prev="(nil)" upper="0xa8996ae0" lower="(nil)"><Finish/></txt></header><body ptr="0xa999cd88" next="0xa8998ae0" prev="0xa8996ae0" upper="0xa8993d98" lower="0xa998c704"><section ptr="0xa998c704" next="(nil)" prev="(nil)" upper="0xa999cd88" lower="0xa6c015ac" follow="0xa998c584" precede="0xa998c904"><column ptr="0xa6c015ac" next="0xa6c01610" prev="(nil)" upper="0xa998c704" lower="0xa6c0254c"><body ptr="0xa6c0254c" next="(nil)" prev="(nil)" upper="0xa6c015ac" lower="0xa894e774"><txt ptr="0xa894e774" next="0xa894e804" prev="(nil)" upper="0xa6c0254c" lower="(nil)">    return left;<Finish/></txt><txt ptr="0xa894e804" next="0xa894e894" prev="0xa894e774" upper="0xa6c0254c" lower="(nil)">}<Finish/></txt><txt ptr="0xa894e894" next="0xa894e924" prev="0xa894e804" upper="0xa6c0254c" lower="(nil)">DFA查找<Finish/></txt><txt ptr="0xa894e924" next="0xa894e9b4" prev="0xa894e894" upper="0xa6c0254c" lower="(nil)">按位查找，从最高位开始确定应该是那个数字<Finish/></txt><txt ptr="0xa894e9b4" next="0xa894ea44" prev="0xa894e924" upper="0xa6c0254c" lower="(nil)">调用前ans = 0;<Finish/></txt><txt ptr="0xa894ea44" next="0xa894ead4" prev="0xa894e9b4" upper="0xa6c0254c" lower="(nil)">调用dfs(len-1,0,0,false,query(left-1) + k);<Finish/></txt><txt ptr="0xa894ead4" next="0xa894eb64" prev="0xa894ea44" upper="0xa6c0254c" lower="(nil)">void dfs(int pos, int x_num, int y_num, bool yes, LL k) {<Finish/></txt><txt ptr="0xa894eb64" next="0xa894ebf4" prev="0xa894ead4" upper="0xa6c0254c" lower="(nil)">    if(pos &lt; 0)return ;<Finish/></txt><txt ptr="0xa894ebf4" next="0xa894ec84" prev="0xa894eb64" upper="0xa6c0254c" lower="(nil)">    int _max = yes ? 9 : str[pos];<Finish/></txt><txt ptr="0xa894ec84" next="0xa894ed14" prev="0xa894ebf4" upper="0xa6c0254c" lower="(nil)">    LL tmp;<Finish/></txt><txt ptr="0xa894ed14" next="0xa894eda4" prev="0xa894ec84" upper="0xa6c0254c" lower="(nil)">    for(int i=0; i&lt;=_max; i++) {<Finish/></txt><txt ptr="0xa894eda4" next="0xa894ee34" prev="0xa894ed14" upper="0xa6c0254c" lower="(nil)">tmp = dfs(pos-1, x_num+(i == 4), y_num + (i == 7), yes || i&lt;str[pos]);<Finish/></txt><txt ptr="0xa894ee34" next="0xa894eec4" prev="0xa894eda4" upper="0xa6c0254c" lower="(nil)">        if(tmp&gt;=k){<Finish/></txt><txt ptr="0xa894eec4" next="0xa894ef54" prev="0xa894ee34" upper="0xa6c0254c" lower="(nil)">            ans = ans*10+i;<Finish/></txt><txt ptr="0xa894ef54" next="0xa894f028" prev="0xa894eec4" upper="0xa6c0254c" lower="(nil)">            dfs(pos-1,x_num + (i == 4), y_num + (i == 7), yes || i&lt;str[pos],k);<Finish/></txt><txt ptr="0xa894f028" next="0xa894f0b8" prev="0xa894ef54" upper="0xa6c0254c" lower="(nil)">            return;<Finish/></txt><txt ptr="0xa894f0b8" next="0xa894f148" prev="0xa894f028" upper="0xa6c0254c" lower="(nil)">        }else{<Finish/></txt><txt ptr="0xa894f148" next="0xa894f1d8" prev="0xa894f0b8" upper="0xa6c0254c" lower="(nil)">            k -= tmp;<Finish/></txt><txt ptr="0xa894f1d8" next="0xa894f268" prev="0xa894f148" upper="0xa6c0254c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa894f268" next="0xa894f2f8" prev="0xa894f1d8" upper="0xa6c0254c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa894f2f8" next="0xa894f388" prev="0xa894f268" upper="0xa6c0254c" lower="(nil)">}<Finish/></txt><txt ptr="0xa894f388" next="(nil)" prev="0xa894f2f8" upper="0xa6c0254c" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa6c01610" next="0xa6c01674" prev="0xa6c015ac" upper="0xa998c704" lower="0xa6c025ac"><body ptr="0xa6c025ac" next="(nil)" prev="(nil)" upper="0xa6c01610" lower="0xa894f418"><txt ptr="0xa894f418" next="0xa894f778" prev="(nil)" upper="0xa6c025ac" lower="(nil)">搜索<Finish/></txt><txt ptr="0xa894f778" next="0xa894f808" prev="0xa894f418" upper="0xa6c025ac" lower="(nil)">KMP 匹配算法O(M+N)<Finish/></txt><txt ptr="0xa894f808" next="0xa894f898" prev="0xa894f778" upper="0xa6c025ac" lower="(nil)">const int P=100;<Finish/></txt><txt ptr="0xa894f898" next="0xa894f928" prev="0xa894f808" upper="0xa6c025ac" lower="(nil)">int next[P];<Finish/></txt><txt ptr="0xa894f928" next="0xa894f9b8" prev="0xa894f898" upper="0xa6c025ac" lower="(nil)"><Finish/></txt><txt ptr="0xa894f9b8" next="0xa894fa48" prev="0xa894f928" upper="0xa6c025ac" lower="(nil)">//next[i]的意义<Finish/></txt><txt ptr="0xa894fa48" next="0xa894fad8" prev="0xa894f9b8" upper="0xa6c025ac" lower="(nil)">//s为匹配串,t为s的前i个字符组成的子串<Finish/></txt><txt ptr="0xa894fad8" next="0xa894fb68" prev="0xa894fa48" upper="0xa6c025ac" lower="(nil)">//t = s[0]s[1]...s[i-1]<Finish/></txt><txt ptr="0xa894fb68" next="0xa894fbf8" prev="0xa894fad8" upper="0xa6c025ac" lower="(nil)">//设串s[0]s[1]...s[k]和串s[i-1-k]s[i-1-(k-1)]...s[i-1]相等，<Finish/></txt><txt ptr="0xa894fbf8" next="0xa894fc88" prev="0xa894fb68" upper="0xa6c025ac" lower="(nil)">//next[i]就是这样的k的最大值<Finish/></txt><txt ptr="0xa894fc88" next="0xa894fd18" prev="0xa894fbf8" upper="0xa6c025ac" lower="(nil)">//<Finish/></txt><txt ptr="0xa894fd18" next="0xa894fda8" prev="0xa894fc88" upper="0xa6c025ac" lower="(nil)"><Finish/></txt><txt ptr="0xa894fda8" next="0xa894fe38" prev="0xa894fd18" upper="0xa6c025ac" lower="(nil)">void get_next(char *pat){<Finish/></txt><txt ptr="0xa894fe38" next="0xa894fec8" prev="0xa894fda8" upper="0xa6c025ac" lower="(nil)">*memset(next,-1,sizeof(next));<Finish/></txt><txt ptr="0xa894fec8" next="0xa894ff58" prev="0xa894fe38" upper="0xa6c025ac" lower="(nil)">*for(int i=1,k;pat[i];++i){<Finish/></txt><txt ptr="0xa894ff58" next="0xa8950000" prev="0xa894fec8" upper="0xa6c025ac" lower="(nil)">**for(k=next[i-1];k&gt;=0 &amp;&amp; pat[i]!=pat[k+1];k=next[k]);<Finish/></txt><txt ptr="0xa8950000" next="0xa8950090" prev="0xa894ff58" upper="0xa6c025ac" lower="(nil)">**if(pat[k+1] == pat[i])next[i]=k+1;<Finish/></txt><txt ptr="0xa8950090" next="0xa8950120" prev="0xa8950000" upper="0xa6c025ac" lower="(nil)">*}<Finish/></txt><txt ptr="0xa8950120" next="0xa89501b0" prev="0xa8950090" upper="0xa6c025ac" lower="(nil)">}<Finish/></txt><txt ptr="0xa89501b0" next="0xa8950240" prev="0xa8950120" upper="0xa6c025ac" lower="(nil)"><Finish/></txt><txt ptr="0xa8950240" next="0xa89502d0" prev="0xa89501b0" upper="0xa6c025ac" lower="(nil)">//返回匹配的第一个位置<Finish/></txt><txt ptr="0xa89502d0" next="0xa8950360" prev="0xa8950240" upper="0xa6c025ac" lower="(nil)">//返回匹配的个数  ans<Finish/></txt><txt ptr="0xa8950360" next="0xa89503f0" prev="0xa89502d0" upper="0xa6c025ac" lower="(nil)">int kmp(char* str, char* pat){<Finish/></txt><txt ptr="0xa89503f0" next="0xa8950480" prev="0xa8950360" upper="0xa6c025ac" lower="(nil)">*get_next(pat);<Finish/></txt><txt ptr="0xa8950480" next="(nil)" prev="0xa89503f0" upper="0xa6c025ac" lower="(nil)">*int i=0, j=0,ans=0;<Finish/></txt></body></column><column ptr="0xa6c01674" next="(nil)" prev="0xa6c01610" upper="0xa998c704" lower="0xa6c0260c"><body ptr="0xa6c0260c" next="(nil)" prev="(nil)" upper="0xa6c01674" lower="0xa8950510"><txt ptr="0xa8950510" next="0xa89505a0" prev="(nil)" upper="0xa6c0260c" lower="(nil)"><Finish/></txt><txt ptr="0xa89505a0" next="0xa8950630" prev="0xa8950510" upper="0xa6c0260c" lower="(nil)">*while( str[i] &amp;&amp; pat[j] ){<Finish/></txt><txt ptr="0xa8950630" next="0xa89506c0" prev="0xa89505a0" upper="0xa6c0260c" lower="(nil)">**if( pat[j] == str[i] ){<Finish/></txt><txt ptr="0xa89506c0" next="0xa8950750" prev="0xa8950630" upper="0xa6c0260c" lower="(nil)">*** ++i;<Finish/></txt><txt ptr="0xa8950750" next="0xa89507e0" prev="0xa89506c0" upper="0xa6c0260c" lower="(nil)">***if(!pat[++j])ans++;<Finish/></txt><txt ptr="0xa89507e0" next="0xa8950870" prev="0xa8950750" upper="0xa6c0260c" lower="(nil)">**}<Finish/></txt><txt ptr="0xa8950870" next="0xa8950900" prev="0xa89507e0" upper="0xa6c0260c" lower="(nil)">**else if(j == 0)++i;<Finish/></txt><txt ptr="0xa8950900" next="0xa8950990" prev="0xa8950870" upper="0xa6c0260c" lower="(nil)">**else j = next[j-1]+1;<Finish/></txt><txt ptr="0xa8950990" next="0xa8950cf0" prev="0xa8950900" upper="0xa6c0260c" lower="(nil)">*}<Finish/></txt><txt ptr="0xa8950cf0" next="0xa8950d80" prev="0xa8950990" upper="0xa6c0260c" lower="(nil)">*// return ans;<Finish/></txt><txt ptr="0xa8950d80" next="0xa8950e10" prev="0xa8950cf0" upper="0xa6c0260c" lower="(nil)">*if( pat[j] ) return -1;<Finish/></txt><txt ptr="0xa8950e10" next="0xa8950ea0" prev="0xa8950d80" upper="0xa6c0260c" lower="(nil)">*else return i-j;<Finish/></txt><txt ptr="0xa8950ea0" next="0xa8950f30" prev="0xa8950e10" upper="0xa6c0260c" lower="(nil)">}<Finish/></txt><txt ptr="0xa8950f30" next="0xa8951004" prev="0xa8950ea0" upper="0xa6c0260c" lower="(nil)"> 回文串<Finish/></txt><txt ptr="0xa8951004" next="0xa8951094" prev="0xa8950f30" upper="0xa6c0260c" lower="(nil)">Manacher算法<Finish/></txt><txt ptr="0xa8951094" next="0xa8951124" prev="0xa8951004" upper="0xa6c0260c" lower="(nil)"><Finish/></txt><txt ptr="0xa8951124" next="0xa89511b4" prev="0xa8951094" upper="0xa6c0260c" lower="(nil)">主要用于求解最长回文子串。<Finish/></txt><txt ptr="0xa89511b4" next="0xa8951244" prev="0xa8951124" upper="0xa6c0260c" lower="(nil)"><Finish/></txt><txt ptr="0xa8951244" next="0xa89512d4" prev="0xa89511b4" upper="0xa6c0260c" lower="(nil)">这个算法有一个很巧妙的地方，它把奇数的回文串和偶数的回文串统一起来考虑了。<Finish/></txt><txt ptr="0xa89512d4" next="0xa8951364" prev="0xa8951244" upper="0xa6c0260c" lower="(nil)">这个算法还有一个很好的地方就是充分利用了字符匹配的特殊性，避免了大量不必要的重复匹配。<Finish/></txt><txt ptr="0xa8951364" next="0xa89513f4" prev="0xa89512d4" upper="0xa6c0260c" lower="(nil)"><Finish/></txt><txt ptr="0xa89513f4" next="0xa8951484" prev="0xa8951364" upper="0xa6c0260c" lower="(nil)">const int MAX = 110003 &lt;&lt; 2;<Finish/></txt><txt ptr="0xa8951484" next="0xa8951514" prev="0xa89513f4" upper="0xa6c0260c" lower="(nil)">char oldstr[MAX];//原字符串<Finish/></txt><txt ptr="0xa8951514" next="0xa89515a4" prev="0xa8951484" upper="0xa6c0260c" lower="(nil)">char str[MAX];<Finish/></txt><txt ptr="0xa89515a4" next="(nil)" prev="0xa8951514" upper="0xa6c0260c" lower="(nil)">int p[MAX];//表示以i为中心的回文半径，<Finish/></txt></body></column></section></body><footer ptr="0xa8998ae0" next="(nil)" prev="0xa999cd88" upper="0xa8993d98" lower="0xa998b400"><txt ptr="0xa998b400" next="0xa998b5b0" prev="(nil)" upper="0xa8998ae0" lower="(nil)"><anchored><fly ptr="0xb485d70" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa998b490"><txt ptr="0xa998b490" next="0xa998b520" prev="(nil)" upper="0xb485d70" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa998b520" next="(nil)" prev="0xa998b490" upper="0xb485d70" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="3"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="2"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa998b5b0" next="(nil)" prev="0xa998b400" upper="0xa8998ae0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993e0c" next="0xa8993e80" prev="0xa8993d98" upper="0xb0726b0" lower="0xa8996b40"><header ptr="0xa8996b40" next="0xa999cf08" prev="(nil)" upper="0xa8993e0c" lower="0xa998d914"><txt ptr="0xa998d914" next="(nil)" prev="(nil)" upper="0xa8996b40" lower="(nil)"><Finish/></txt></header><body ptr="0xa999cf08" next="0xa8998b40" prev="0xa8996b40" upper="0xa8993e0c" lower="0xa998c584"><section ptr="0xa998c584" next="(nil)" prev="(nil)" upper="0xa999cf08" lower="0xa6c01804" follow="0xa998c304" precede="0xa998c704"><column ptr="0xa6c01804" next="0xa6c01868" prev="(nil)" upper="0xa998c584" lower="0xa6c0278c"><body ptr="0xa6c0278c" next="(nil)" prev="(nil)" upper="0xa6c01804" lower="0xa8951634"><txt ptr="0xa8951634" next="0xa89516c4" prev="(nil)" upper="0xa6c0278c" lower="(nil)">/*<Finish/></txt><txt ptr="0xa89516c4" next="0xa8951754" prev="0xa8951634" upper="0xa6c0278c" lower="(nil)">p[i]-1刚好是原字符串以第i个为中心的回文串长度。<Finish/></txt><txt ptr="0xa8951754" next="0xa89517e4" prev="0xa89516c4" upper="0xa6c0278c" lower="(nil)">*/<Finish/></txt><txt ptr="0xa89517e4" next="0xa8951874" prev="0xa8951754" upper="0xa6c0278c" lower="(nil)"><Finish/></txt><txt ptr="0xa8951874" next="0xa8951904" prev="0xa89517e4" upper="0xa6c0278c" lower="(nil)">void Manacher(int n) {<Finish/></txt><txt ptr="0xa8951904" next="0xa8951994" prev="0xa8951874" upper="0xa6c0278c" lower="(nil)">    int mx=0;<Finish/></txt><txt ptr="0xa8951994" next="0xa8951a24" prev="0xa8951904" upper="0xa6c0278c" lower="(nil)">    int id;//最长影响串的位置;<Finish/></txt><txt ptr="0xa8951a24" next="0xa8951ab4" prev="0xa8951994" upper="0xa6c0278c" lower="(nil)">    p[0]=0;<Finish/></txt><txt ptr="0xa8951ab4" next="0xa8951b44" prev="0xa8951a24" upper="0xa6c0278c" lower="(nil)"><Finish/></txt><txt ptr="0xa8951b44" next="0xa8951bd4" prev="0xa8951ab4" upper="0xa6c0278c" lower="(nil)">    for(int i = 1; i &lt; n; i++) {<Finish/></txt><txt ptr="0xa8951bd4" next="0xa8951c64" prev="0xa8951b44" upper="0xa6c0278c" lower="(nil)">        p[i]=1;//至少是1<Finish/></txt><txt ptr="0xa8951c64" next="0xa8951cf4" prev="0xa8951bd4" upper="0xa6c0278c" lower="(nil)">        if(mx&gt;i) {<Finish/></txt><txt ptr="0xa8951cf4" next="0xa8951d84" prev="0xa8951c64" upper="0xa6c0278c" lower="(nil)">            p[i] = p[2 * id - i];<Finish/></txt><txt ptr="0xa8951d84" next="0xa8951e14" prev="0xa8951cf4" upper="0xa6c0278c" lower="(nil)">            if(mx - i &lt; p[i]) p[i] = mx - i;<Finish/></txt><txt ptr="0xa8951e14" next="0xa8951ea4" prev="0xa8951d84" upper="0xa6c0278c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8951ea4" next="0xa8951f34" prev="0xa8951e14" upper="0xa6c0278c" lower="(nil)"><Finish/></txt><txt ptr="0xa8951f34" next="0xa89522d8" prev="0xa8951ea4" upper="0xa6c0278c" lower="(nil)">        //向两端配匹<Finish/></txt><txt ptr="0xa89522d8" next="0xa8952368" prev="0xa8951f34" upper="0xa6c0278c" lower="(nil)">        while(str[i - p[i]] == str[i + p[i]]) p[i]++;<Finish/></txt><txt ptr="0xa8952368" next="0xa89523f8" prev="0xa89522d8" upper="0xa6c0278c" lower="(nil)">        if(i + p[i] &gt; mx) {<Finish/></txt><txt ptr="0xa89523f8" next="0xa8952488" prev="0xa8952368" upper="0xa6c0278c" lower="(nil)">            mx = i + p[i];<Finish/></txt><txt ptr="0xa8952488" next="0xa8952518" prev="0xa89523f8" upper="0xa6c0278c" lower="(nil)">            id = i;<Finish/></txt><txt ptr="0xa8952518" next="0xa89525a8" prev="0xa8952488" upper="0xa6c0278c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa89525a8" next="0xa8952638" prev="0xa8952518" upper="0xa6c0278c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8952638" next="0xa89526c8" prev="0xa89525a8" upper="0xa6c0278c" lower="(nil)">}<Finish/></txt><txt ptr="0xa89526c8" next="0xa8952758" prev="0xa8952638" upper="0xa6c0278c" lower="(nil)"><Finish/></txt><txt ptr="0xa8952758" next="0xa89527e8" prev="0xa89526c8" upper="0xa6c0278c" lower="(nil)">/*<Finish/></txt><txt ptr="0xa89527e8" next="0xa8952878" prev="0xa8952758" upper="0xa6c0278c" lower="(nil)">预处理字符串<Finish/></txt><txt ptr="0xa8952878" next="(nil)" prev="0xa89527e8" upper="0xa6c0278c" lower="(nil)">*/<Finish/></txt></body></column><column ptr="0xa6c01868" next="0xa6c018cc" prev="0xa6c01804" upper="0xa998c584" lower="0xa6c027ec"><body ptr="0xa6c027ec" next="(nil)" prev="(nil)" upper="0xa6c01868" lower="0xa8952908"><txt ptr="0xa8952908" next="0xa8952998" prev="(nil)" upper="0xa6c027ec" lower="(nil)">int pre(char head='$', char middle='#', char end = '?') {<Finish/></txt><txt ptr="0xa8952998" next="0xa8952a28" prev="0xa8952908" upper="0xa6c027ec" lower="(nil)">    int n=0;<Finish/></txt><txt ptr="0xa8952a28" next="0xa8952ab8" prev="0xa8952998" upper="0xa6c027ec" lower="(nil)">    str[n++]=head;<Finish/></txt><txt ptr="0xa8952ab8" next="0xa8952b48" prev="0xa8952a28" upper="0xa6c027ec" lower="(nil)">    str[n++]=middle;<Finish/></txt><txt ptr="0xa8952b48" next="0xa8952bd8" prev="0xa8952ab8" upper="0xa6c027ec" lower="(nil)">    for(int i = 0; oldstr[i]; i++) {<Finish/></txt><txt ptr="0xa8952bd8" next="0xa8952c68" prev="0xa8952b48" upper="0xa6c027ec" lower="(nil)">        str[n++] = oldstr[i];<Finish/></txt><txt ptr="0xa8952c68" next="0xa8952cf8" prev="0xa8952bd8" upper="0xa6c027ec" lower="(nil)">        str[n++] = middle;<Finish/></txt><txt ptr="0xa8952cf8" next="0xa8952d88" prev="0xa8952c68" upper="0xa6c027ec" lower="(nil)"><Finish/></txt><txt ptr="0xa8952d88" next="0xa8952e18" prev="0xa8952cf8" upper="0xa6c027ec" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8952e18" next="0xa8952ea8" prev="0xa8952d88" upper="0xa6c027ec" lower="(nil)">    str[n]=end;<Finish/></txt><txt ptr="0xa8952ea8" next="0xa8952f38" prev="0xa8952e18" upper="0xa6c027ec" lower="(nil)">    return n;<Finish/></txt><txt ptr="0xa8952f38" next="0xa895300c" prev="0xa8952ea8" upper="0xa6c027ec" lower="(nil)">}<Finish/></txt><txt ptr="0xa895300c" next="0xa895309c" prev="0xa8952f38" upper="0xa6c027ec" lower="(nil)"><Finish/></txt><txt ptr="0xa895309c" next="0xa895312c" prev="0xa895300c" upper="0xa6c027ec" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa895312c" next="0xa89531bc" prev="0xa895309c" upper="0xa6c027ec" lower="(nil)">    int n;<Finish/></txt><txt ptr="0xa89531bc" next="0xa895324c" prev="0xa895312c" upper="0xa6c027ec" lower="(nil)">    while(scanf(&quot;%s&quot;, oldstr) != EOF) {<Finish/></txt><txt ptr="0xa895324c" next="0xa89532dc" prev="0xa89531bc" upper="0xa6c027ec" lower="(nil)">        n = pre();<Finish/></txt><txt ptr="0xa89532dc" next="0xa895336c" prev="0xa895324c" upper="0xa6c027ec" lower="(nil)">        Manacher(n);<Finish/></txt><txt ptr="0xa895336c" next="0xa89533fc" prev="0xa89532dc" upper="0xa6c027ec" lower="(nil)">        int ans=0;<Finish/></txt><txt ptr="0xa89533fc" next="0xa895348c" prev="0xa895336c" upper="0xa6c027ec" lower="(nil)">        for(int i = 1; i &lt; n; i++) {<Finish/></txt><txt ptr="0xa895348c" next="0xa895351c" prev="0xa89533fc" upper="0xa6c027ec" lower="(nil)">            if(p[i] &gt; ans) ans = p[i];<Finish/></txt><txt ptr="0xa895351c" next="0xa895387c" prev="0xa895348c" upper="0xa6c027ec" lower="(nil)"><Finish/></txt><txt ptr="0xa895387c" next="0xa895390c" prev="0xa895351c" upper="0xa6c027ec" lower="(nil)">        }<Finish/></txt><txt ptr="0xa895390c" next="0xa895399c" prev="0xa895387c" upper="0xa6c027ec" lower="(nil)">        printf(&quot;%d\n&quot;, ans - 1);<Finish/></txt><txt ptr="0xa895399c" next="0xa8953a2c" prev="0xa895390c" upper="0xa6c027ec" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8953a2c" next="0xa8953abc" prev="0xa895399c" upper="0xa6c027ec" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa8953abc" next="(nil)" prev="0xa8953a2c" upper="0xa6c027ec" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa6c018cc" next="(nil)" prev="0xa6c01868" upper="0xa998c584" lower="0xa6c0284c"><body ptr="0xa6c0284c" next="(nil)" prev="(nil)" upper="0xa6c018cc" lower="0xa8953b4c"><txt ptr="0xa8953b4c" next="0xa8953bdc" prev="(nil)" upper="0xa6c0284c" lower="(nil)">迭代加深搜索<Finish/></txt><txt ptr="0xa8953bdc" next="0xa8953c6c" prev="0xa8953b4c" upper="0xa6c0284c" lower="(nil)">对于一般的搜索，复杂度是O(2^n)的复杂度。<Finish/></txt><txt ptr="0xa8953c6c" next="0xa8953cfc" prev="0xa8953bdc" upper="0xa6c0284c" lower="(nil)">对于不知道比较好的算法时，只有进行暴力搜索了。<Finish/></txt><txt ptr="0xa8953cfc" next="0xa8953d8c" prev="0xa8953c6c" upper="0xa6c0284c" lower="(nil)">但是DFS可能进去出不来，对于BFS又可能爆栈。这是就要进行迭代搜索了。<Finish/></txt><txt ptr="0xa8953d8c" next="0xa8953e1c" prev="0xa8953cfc" upper="0xa6c0284c" lower="(nil)">每当加深一层深度时，次层的搜索的时间可以忽略不计了，因为相差一个数量级。<Finish/></txt><txt ptr="0xa8953e1c" next="0xa8953eac" prev="0xa8953d8c" upper="0xa6c0284c" lower="(nil)">IDA*<Finish/></txt><txt ptr="0xa8953eac" next="0xa8953f3c" prev="0xa8953e1c" upper="0xa6c0284c" lower="(nil)">这里以一个例子来讲解IDA*.<Finish/></txt><txt ptr="0xa8953f3c" next="0xa8954010" prev="0xa8953eac" upper="0xa6c0284c" lower="(nil)">问题：n个数互不相同，可以对相邻的连续区间进行交换，最终使n个数达到升序。求最少交换次数。<Finish/></txt><txt ptr="0xa8954010" next="0xa89540a0" prev="0xa8953f3c" upper="0xa6c0284c" lower="(nil)">这里假设是1到n的n个数。不是话可以进行映射。<Finish/></txt><txt ptr="0xa89540a0" next="0xa8954130" prev="0xa8954010" upper="0xa6c0284c" lower="(nil)"><Finish/></txt><txt ptr="0xa8954130" next="0xa89541c0" prev="0xa89540a0" upper="0xa6c0284c" lower="(nil)">int n,str[20], _maxDepth;<Finish/></txt><txt ptr="0xa89541c0" next="0xa8954250" prev="0xa8954130" upper="0xa6c0284c" lower="(nil)">int hfunc() {//估计函数：还有多少个断点<Finish/></txt><txt ptr="0xa8954250" next="0xa89542e0" prev="0xa89541c0" upper="0xa6c0284c" lower="(nil)">    int depth = 0;<Finish/></txt><txt ptr="0xa89542e0" next="0xa8954370" prev="0xa8954250" upper="0xa6c0284c" lower="(nil)">    for(int i=1; i&lt;n; i++) {<Finish/></txt><txt ptr="0xa8954370" next="0xa8954400" prev="0xa89542e0" upper="0xa6c0284c" lower="(nil)">        if(str[i] != str[i-1]+1) {<Finish/></txt><txt ptr="0xa8954400" next="0xa8954490" prev="0xa8954370" upper="0xa6c0284c" lower="(nil)">            depth++;<Finish/></txt><txt ptr="0xa8954490" next="0xa8954520" prev="0xa8954400" upper="0xa6c0284c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8954520" next="0xa89545b0" prev="0xa8954490" upper="0xa6c0284c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89545b0" next="0xa8954640" prev="0xa8954520" upper="0xa6c0284c" lower="(nil)">    return depth;<Finish/></txt><txt ptr="0xa8954640" next="0xa89546d0" prev="0xa89545b0" upper="0xa6c0284c" lower="(nil)">}<Finish/></txt><txt ptr="0xa89546d0" next="0xa8954760" prev="0xa8954640" upper="0xa6c0284c" lower="(nil)">//交换区间<Finish/></txt><txt ptr="0xa8954760" next="0xa89547f0" prev="0xa89546d0" upper="0xa6c0284c" lower="(nil)">void move(int left, int mid, int right) {<Finish/></txt><txt ptr="0xa89547f0" next="0xa8954880" prev="0xa8954760" upper="0xa6c0284c" lower="(nil)">    int i, j, tmp[20];;<Finish/></txt><txt ptr="0xa8954880" next="(nil)" prev="0xa89547f0" upper="0xa6c0284c" lower="(nil)">    for(i=mid+1,j=0; i&lt;=right; i++,j++) {<Finish/></txt></body></column></section></body><footer ptr="0xa8998b40" next="(nil)" prev="0xa999cf08" upper="0xa8993e0c" lower="0xa998d9a4"><txt ptr="0xa998d9a4" next="0xa998db54" prev="(nil)" upper="0xa8998b40" lower="(nil)"><anchored><fly ptr="0xb6ffcb0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa998da34"><txt ptr="0xa998da34" next="0xa998dac4" prev="(nil)" upper="0xb6ffcb0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa998dac4" next="(nil)" prev="0xa998da34" upper="0xb6ffcb0" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="3"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="3"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa998db54" next="(nil)" prev="0xa998d9a4" upper="0xa8998b40" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993e80" next="0xa8993ef4" prev="0xa8993e0c" upper="0xb0726b0" lower="0xa8996ba0"><header ptr="0xa8996ba0" next="0xa998e0cc" prev="(nil)" upper="0xa8993e80" lower="0xa998feb8"><txt ptr="0xa998feb8" next="(nil)" prev="(nil)" upper="0xa8996ba0" lower="(nil)"><Finish/></txt></header><body ptr="0xa998e0cc" next="0xa8998ba0" prev="0xa8996ba0" upper="0xa8993e80" lower="0xa998c304"><section ptr="0xa998c304" next="(nil)" prev="(nil)" upper="0xa998e0cc" lower="0xa6c01b88" follow="0xa998c284" precede="0xa998c584"><column ptr="0xa6c01b88" next="0xa6c01bec" prev="(nil)" upper="0xa998c304" lower="0xa6c02aec"><body ptr="0xa6c02aec" next="(nil)" prev="(nil)" upper="0xa6c01b88" lower="0xa8954910"><txt ptr="0xa8954910" next="0xa89549a0" prev="(nil)" upper="0xa6c02aec" lower="(nil)">        tmp[j] = str[i];<Finish/></txt><txt ptr="0xa89549a0" next="0xa8954a30" prev="0xa8954910" upper="0xa6c02aec" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8954a30" next="0xa8954ac0" prev="0xa89549a0" upper="0xa6c02aec" lower="(nil)">    for(i=left; i&lt;=mid; i++,j++) {<Finish/></txt><txt ptr="0xa8954ac0" next="0xa8954e20" prev="0xa8954a30" upper="0xa6c02aec" lower="(nil)">        tmp[j] = str[i];<Finish/></txt><txt ptr="0xa8954e20" next="0xa8954eb0" prev="0xa8954ac0" upper="0xa6c02aec" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8954eb0" next="0xa8954f40" prev="0xa8954e20" upper="0xa6c02aec" lower="(nil)">    for(i=left,j=0; i&lt;=right; i++,j++) {<Finish/></txt><txt ptr="0xa8954f40" next="0xa8956014" prev="0xa8954eb0" upper="0xa6c02aec" lower="(nil)">        str[i] = tmp[j];<Finish/></txt><txt ptr="0xa8956014" next="0xa89560a4" prev="0xa8954f40" upper="0xa6c02aec" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89560a4" next="0xa8956134" prev="0xa8956014" upper="0xa6c02aec" lower="(nil)">}<Finish/></txt><txt ptr="0xa8956134" next="0xa89561c4" prev="0xa89560a4" upper="0xa6c02aec" lower="(nil)">//迭代加深搜索<Finish/></txt><txt ptr="0xa89561c4" next="0xa8956254" prev="0xa8956134" upper="0xa6c02aec" lower="(nil)">//三个while是我加的优化，我们只能从断点开始划分交换区间，一个连续区间分开后显然答案不忧。<Finish/></txt><txt ptr="0xa8956254" next="0xa89562e4" prev="0xa89561c4" upper="0xa6c02aec" lower="(nil)">//一次交换最优情况下可以减少三个断点。<Finish/></txt><txt ptr="0xa89562e4" next="0xa8956374" prev="0xa8956254" upper="0xa6c02aec" lower="(nil)">int dfs(int depth) {<Finish/></txt><txt ptr="0xa8956374" next="0xa8956404" prev="0xa89562e4" upper="0xa6c02aec" lower="(nil)">    int left,mid,right,h;<Finish/></txt><txt ptr="0xa8956404" next="0xa8956494" prev="0xa8956374" upper="0xa6c02aec" lower="(nil)">    for(left=0; left&lt;n-1; left++) {<Finish/></txt><txt ptr="0xa8956494" next="0xa8956524" prev="0xa8956404" upper="0xa6c02aec" lower="(nil)">while(left &amp;&amp; str[left] == str[left-1]+1)left++;<Finish/></txt><txt ptr="0xa8956524" next="0xa89565b4" prev="0xa8956494" upper="0xa6c02aec" lower="(nil)">        for(mid = left; mid&lt;n-1; mid++) {<Finish/></txt><txt ptr="0xa89565b4" next="0xa8956644" prev="0xa8956524" upper="0xa6c02aec" lower="(nil)">while(mid&lt;n-1 &amp;&amp; (str[mid]+1 == str[mid+1]))mid++;<Finish/></txt><txt ptr="0xa8956644" next="0xa89566d4" prev="0xa89565b4" upper="0xa6c02aec" lower="(nil)">            for(right = mid+1; right &lt; n; right++) {<Finish/></txt><txt ptr="0xa89566d4" next="0xa8956764" prev="0xa8956644" upper="0xa6c02aec" lower="(nil)">while(right&lt;n-1&amp;&amp;(str[right]+1 == str[right+1]))right++;<Finish/></txt><txt ptr="0xa8956764" next="0xa89567f4" prev="0xa89566d4" upper="0xa6c02aec" lower="(nil)">                move(left, mid,right);<Finish/></txt><txt ptr="0xa89567f4" next="0xa8956884" prev="0xa8956764" upper="0xa6c02aec" lower="(nil)">                if((h = hfunc()) == 0)return 1;<Finish/></txt><txt ptr="0xa8956884" next="0xa8956914" prev="0xa89567f4" upper="0xa6c02aec" lower="(nil)">                if(depth*3 + h &lt;= _maxDepth*3) {<Finish/></txt><txt ptr="0xa8956914" next="0xa89569a4" prev="0xa8956884" upper="0xa6c02aec" lower="(nil)">                    if(dfs(depth+1)) {<Finish/></txt><txt ptr="0xa89569a4" next="0xa8956a34" prev="0xa8956914" upper="0xa6c02aec" lower="(nil)">                        return 1;<Finish/></txt><txt ptr="0xa8956a34" next="0xa8956ac4" prev="0xa89569a4" upper="0xa6c02aec" lower="(nil)">                    }<Finish/></txt><txt ptr="0xa8956ac4" next="(nil)" prev="0xa8956a34" upper="0xa6c02aec" lower="(nil)">                }<Finish/></txt></body></column><column ptr="0xa6c01bec" next="0xa6c01c50" prev="0xa6c01b88" upper="0xa998c304" lower="0xa6c02b4c"><body ptr="0xa6c02b4c" next="(nil)" prev="(nil)" upper="0xa6c01bec" lower="0xa8956b54"><txt ptr="0xa8956b54" next="0xa8956be4" prev="(nil)" upper="0xa6c02b4c" lower="(nil)">                move(left,left + (right-mid-1),right);<Finish/></txt><txt ptr="0xa8956be4" next="0xa8956c74" prev="0xa8956b54" upper="0xa6c02b4c" lower="(nil)">            }<Finish/></txt><txt ptr="0xa8956c74" next="0xa8956d04" prev="0xa8956be4" upper="0xa6c02b4c" lower="(nil)"><Finish/></txt><txt ptr="0xa8956d04" next="0xa8956d94" prev="0xa8956c74" upper="0xa6c02b4c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8956d94" next="0xa8956e24" prev="0xa8956d04" upper="0xa6c02b4c" lower="(nil)"><Finish/></txt><txt ptr="0xa8956e24" next="0xa8956eb4" prev="0xa8956d94" upper="0xa6c02b4c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8956eb4" next="0xa8956f44" prev="0xa8956e24" upper="0xa6c02b4c" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa8956f44" next="0xa8957018" prev="0xa8956eb4" upper="0xa6c02b4c" lower="(nil)">}<Finish/></txt><txt ptr="0xa8957018" next="0xa89570a8" prev="0xa8956f44" upper="0xa6c02b4c" lower="(nil)"><Finish/></txt><txt ptr="0xa89570a8" next="0xa8957408" prev="0xa8957018" upper="0xa6c02b4c" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa8957408" next="0xa8957498" prev="0xa89570a8" upper="0xa6c02b4c" lower="(nil)">    int cas,i;<Finish/></txt><txt ptr="0xa8957498" next="0xa8957528" prev="0xa8957408" upper="0xa6c02b4c" lower="(nil)">    scanf(&quot;%d&quot;,&amp;n);<Finish/></txt><txt ptr="0xa8957528" next="0xa89575b8" prev="0xa8957498" upper="0xa6c02b4c" lower="(nil)">    for(i=0; i&lt;n; i++) {<Finish/></txt><txt ptr="0xa89575b8" next="0xa8957648" prev="0xa8957528" upper="0xa6c02b4c" lower="(nil)">        scanf(&quot;%d&quot;,&amp;str[i]);<Finish/></txt><txt ptr="0xa8957648" next="0xa89576d8" prev="0xa89575b8" upper="0xa6c02b4c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89576d8" next="0xa8957768" prev="0xa8957648" upper="0xa6c02b4c" lower="(nil)">    _maxDepth = (hfunc()+2)/3;<Finish/></txt><txt ptr="0xa8957768" next="0xa89577f8" prev="0xa89576d8" upper="0xa6c02b4c" lower="(nil)">    if(_maxDepth) {<Finish/></txt><txt ptr="0xa89577f8" next="0xa8957888" prev="0xa8957768" upper="0xa6c02b4c" lower="(nil)">        while(dfs(1) == 0) {<Finish/></txt><txt ptr="0xa8957888" next="0xa8957918" prev="0xa89577f8" upper="0xa6c02b4c" lower="(nil)">            _maxDepth++;<Finish/></txt><txt ptr="0xa8957918" next="0xa89579a8" prev="0xa8957888" upper="0xa6c02b4c" lower="(nil)">        }<Finish/></txt><txt ptr="0xa89579a8" next="0xa8957a38" prev="0xa8957918" upper="0xa6c02b4c" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8957a38" next="0xa8957ac8" prev="0xa89579a8" upper="0xa6c02b4c" lower="(nil)">    printf(&quot;%d\n&quot;,_maxDepth);<Finish/></txt><txt ptr="0xa8957ac8" next="0xa8957b58" prev="0xa8957a38" upper="0xa6c02b4c" lower="(nil)">return 0;<Finish/></txt><txt ptr="0xa8957b58" next="(nil)" prev="0xa8957ac8" upper="0xa6c02b4c" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa6c01c50" next="(nil)" prev="0xa6c01bec" upper="0xa998c304" lower="0xa6c02bac"><body ptr="0xa6c02bac" next="(nil)" prev="(nil)" upper="0xa6c01c50" lower="0xa8957be8"><txt ptr="0xa8957be8" next="0xa8957c78" prev="(nil)" upper="0xa6c02bac" lower="(nil)"><Finish/></txt><txt ptr="0xa8957c78" next="0xa8957d08" prev="0xa8957be8" upper="0xa6c02bac" lower="(nil)">棋盘多项式与禁位排列<Finish/></txt><txt ptr="0xa8957d08" next="0xa8957d98" prev="0xa8957c78" upper="0xa6c02bac" lower="(nil)">一个n*n个方格组成的图形去掉其中某些方格，称为是一个棋盘(每行每列至多一个)<Finish/></txt><txt ptr="0xa8957d98" next="0xa8957e28" prev="0xa8957d08" upper="0xa6c02bac" lower="(nil)">棋盘方案数Rk(C):有C个格子构成的一个棋盘，放了k个棋子。<Finish/></txt><txt ptr="0xa8957e28" next="0xa8957eb8" prev="0xa8957d98" upper="0xa6c02bac" lower="(nil)">棋盘多项式:R(C)=r0(C)+r1(C)x+r2(C)x2+...+ri(C)xi <Finish/></txt><txt ptr="0xa8957eb8" next="0xa8957f48" prev="0xa8957e28" upper="0xa6c02bac" lower="(nil)">称为是棋盘C的棋盘多项式。（r0(C)=1）<Finish/></txt><txt ptr="0xa8957f48" next="0xa895801c" prev="0xa8957eb8" upper="0xa6c02bac" lower="(nil)">在棋盘C 中任取一个格，将这个格去掉，得到的棋盘记作C(e) 把这个格所在的行和列的格都去掉得到的棋盘记作C(x)<Finish/></txt><txt ptr="0xa895801c" next="0xa89580ac" prev="0xa8957f48" upper="0xa6c02bac" lower="(nil)">Rk(C)=Rk-1(C(x))+Rk(C(e))<Finish/></txt><txt ptr="0xa89580ac" next="0xa895813c" prev="0xa895801c" upper="0xa6c02bac" lower="(nil)">有禁区的排列<Finish/></txt><txt ptr="0xa895813c" next="0xa89581cc" prev="0xa89580ac" upper="0xa6c02bac" lower="(nil)">可以用棋盘和容斥原理解决这类问题。<Finish/></txt><txt ptr="0xa89581cc" next="0xa895825c" prev="0xa895813c" upper="0xa6c02bac" lower="(nil)"><Finish/></txt><txt ptr="0xa895825c" next="0xa89582ec" prev="0xa89581cc" upper="0xa6c02bac" lower="(nil)">容斥原理<Finish/></txt><txt ptr="0xa89582ec" next="0xa895837c" prev="0xa895825c" upper="0xa6c02bac" lower="(nil)">容斥可以用dfs搜索实现<Finish/></txt><txt ptr="0xa895837c" next="0xa895840c" prev="0xa89582ec" upper="0xa6c02bac" lower="(nil)">用一个例子来看怎么实现容斥<Finish/></txt><txt ptr="0xa895840c" next="0xa895849c" prev="0xa895837c" upper="0xa6c02bac" lower="(nil)">给定一个集合和一个数n，求小于n的数中，满足可以被集合中的其中一个数整除的个数。<Finish/></txt><txt ptr="0xa895849c" next="0xa895852c" prev="0xa895840c" upper="0xa6c02bac" lower="(nil)">TT arr[N]，ans; <Finish/></txt><txt ptr="0xa895852c" next="0xa89585bc" prev="0xa895849c" upper="0xa6c02bac" lower="(nil)">TT gcd(TT a,TT b){<Finish/></txt><txt ptr="0xa89585bc" next="0xa895864c" prev="0xa895852c" upper="0xa6c02bac" lower="(nil)">    return (!b)?a:gcd(b,a%b);<Finish/></txt><txt ptr="0xa895864c" next="0xa89589ac" prev="0xa89585bc" upper="0xa6c02bac" lower="(nil)">}<Finish/></txt><txt ptr="0xa89589ac" next="(nil)" prev="0xa895864c" upper="0xa6c02bac" lower="(nil)">void dfs(int i,int cnt,TT lcm){<Finish/></txt></body></column></section></body><footer ptr="0xa8998ba0" next="(nil)" prev="0xa998e0cc" upper="0xa8993e80" lower="0xa998ff48"><txt ptr="0xa998ff48" next="0xa999013c" prev="(nil)" upper="0xa8998ba0" lower="(nil)"><anchored><fly ptr="0xb485f80" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa999001c"><txt ptr="0xa999001c" next="0xa99900ac" prev="(nil)" upper="0xb485f80" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99900ac" next="(nil)" prev="0xa999001c" upper="0xb485f80" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="3"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="4"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa999013c" next="(nil)" prev="0xa998ff48" upper="0xa8998ba0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993ef4" next="0xa8993f68" prev="0xa8993e80" upper="0xb0726b0" lower="0xa8996c00"><header ptr="0xa8996c00" next="0xa998e24c" prev="(nil)" upper="0xa8993ef4" lower="0xa99924a0"><txt ptr="0xa99924a0" next="(nil)" prev="(nil)" upper="0xa8996c00" lower="(nil)"><Finish/></txt></header><body ptr="0xa998e24c" next="0xa8998c00" prev="0xa8996c00" upper="0xa8993ef4" lower="0xa998c284"><section ptr="0xa998c284" next="(nil)" prev="(nil)" upper="0xa998e24c" lower="0xa6c01cb4" follow="0xa894bb0c" precede="0xa998c304"><column ptr="0xa6c01cb4" next="0xa6c01d18" prev="(nil)" upper="0xa998c284" lower="0xa6c02c0c"><body ptr="0xa6c02c0c" next="(nil)" prev="(nil)" upper="0xa6c01cb4" lower="0xa8958a3c"><txt ptr="0xa8958a3c" next="0xa8958acc" prev="(nil)" upper="0xa6c02c0c" lower="(nil)">    lcm=lcm/gcd(lcm,arr[i])*arr[i];<Finish/></txt><txt ptr="0xa8958acc" next="0xa8958b5c" prev="0xa8958a3c" upper="0xa6c02c0c" lower="(nil)">    if(cnt&amp;1)ans+=(n-1)/lcm;<Finish/></txt><txt ptr="0xa8958b5c" next="0xa8958bec" prev="0xa8958acc" upper="0xa6c02c0c" lower="(nil)">    else ans-=(n-1)/lcm;<Finish/></txt><txt ptr="0xa8958bec" next="0xa8958c7c" prev="0xa8958b5c" upper="0xa6c02c0c" lower="(nil)">    for(int j=i+1;j&lt;m;j++)<Finish/></txt><txt ptr="0xa8958c7c" next="0xa8958d0c" prev="0xa8958bec" upper="0xa6c02c0c" lower="(nil)">        dfs(j,cnt+1,lcm);<Finish/></txt><txt ptr="0xa8958d0c" next="0xa8958d9c" prev="0xa8958c7c" upper="0xa6c02c0c" lower="(nil)">}<Finish/></txt><txt ptr="0xa8958d9c" next="0xa8958e2c" prev="0xa8958d0c" upper="0xa6c02c0c" lower="(nil)">void rongchi(){<Finish/></txt><txt ptr="0xa8958e2c" next="0xa8958ebc" prev="0xa8958d9c" upper="0xa6c02c0c" lower="(nil)">    for(int i=0;i&lt;m;i++)<Finish/></txt><txt ptr="0xa8958ebc" next="0xa8958f4c" prev="0xa8958e2c" upper="0xa6c02c0c" lower="(nil)">        dfs(i,1,arr[i]);<Finish/></txt><txt ptr="0xa8958f4c" next="0xa8959020" prev="0xa8958ebc" upper="0xa6c02c0c" lower="(nil)">}<Finish/></txt><txt ptr="0xa8959020" next="0xa89590b0" prev="0xa8958f4c" upper="0xa6c02c0c" lower="(nil)">小于n的个数字的个数<Finish/></txt><txt ptr="0xa89590b0" next="0xa8959140" prev="0xa8959020" upper="0xa6c02c0c" lower="(nil)">//调用count(n) <Finish/></txt><txt ptr="0xa8959140" next="0xa89591d0" prev="0xa89590b0" upper="0xa6c02c0c" lower="(nil)">int d[11];//初始化为0<Finish/></txt><txt ptr="0xa89591d0" next="0xa8959260" prev="0xa8959140" upper="0xa6c02c0c" lower="(nil)">void count(int n,int value=1){<Finish/></txt><txt ptr="0xa8959260" next="0xa89592f0" prev="0xa89591d0" upper="0xa6c02c0c" lower="(nil)">*if(n&lt;=0)return ;<Finish/></txt><txt ptr="0xa89592f0" next="0xa8959380" prev="0xa8959260" upper="0xa6c02c0c" lower="(nil)">*int one=n%10;<Finish/></txt><txt ptr="0xa8959380" next="0xa8959410" prev="0xa89592f0" upper="0xa6c02c0c" lower="(nil)">*int ten=n;<Finish/></txt><txt ptr="0xa8959410" next="0xa89594a0" prev="0xa8959380" upper="0xa6c02c0c" lower="(nil)">*for(int i=0;i&lt;=one;i++)d[i]+=value;<Finish/></txt><txt ptr="0xa89594a0" next="0xa8959530" prev="0xa8959410" upper="0xa6c02c0c" lower="(nil)">*one++;<Finish/></txt><txt ptr="0xa8959530" next="0xa89595c0" prev="0xa89594a0" upper="0xa6c02c0c" lower="(nil)">*while(ten/=10)d[ten%10]+=one*value;<Finish/></txt><txt ptr="0xa89595c0" next="0xa8959650" prev="0xa8959530" upper="0xa6c02c0c" lower="(nil)">*n/=10;<Finish/></txt><txt ptr="0xa8959650" next="0xa89596e0" prev="0xa89595c0" upper="0xa6c02c0c" lower="(nil)">*for(int i=0;i&lt;10;i++)d[i]+=value*n;<Finish/></txt><txt ptr="0xa89596e0" next="0xa8959770" prev="0xa8959650" upper="0xa6c02c0c" lower="(nil)">*d[0]-=value;<Finish/></txt><txt ptr="0xa8959770" next="0xa8959800" prev="0xa89596e0" upper="0xa6c02c0c" lower="(nil)">*count(n-1,value);<Finish/></txt><txt ptr="0xa8959800" next="0xa8959890" prev="0xa8959770" upper="0xa6c02c0c" lower="(nil)">} <Finish/></txt><txt ptr="0xa8959890" next="(nil)" prev="0xa8959800" upper="0xa6c02c0c" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa6c01d18" next="0xa6c01d7c" prev="0xa6c01cb4" upper="0xa998c284" lower="0xa6c02c6c"><body ptr="0xa6c02c6c" next="(nil)" prev="(nil)" upper="0xa6c01d18" lower="0xa8959920"><txt ptr="0xa8959920" next="0xa89599b0" prev="(nil)" upper="0xa6c02c6c" lower="(nil)">DFA+DP<Finish/></txt><txt ptr="0xa89599b0" next="0xa8959a40" prev="0xa8959920" upper="0xa6c02c6c" lower="(nil)">一般用于解决与位有关系的搜索<Finish/></txt><txt ptr="0xa8959a40" next="0xa8959ad0" prev="0xa89599b0" upper="0xa6c02c6c" lower="(nil)">求区间内满足条件的个数<Finish/></txt><txt ptr="0xa8959ad0" next="0xa8959b60" prev="0xa8959a40" upper="0xa6c02c6c" lower="(nil)">一个10进制number称为balanced的，如果存在一个digit关于这个digit的力矩和为0.<Finish/></txt><txt ptr="0xa8959b60" next="0xa8959bf0" prev="0xa8959ad0" upper="0xa6c02c6c" lower="(nil)">例如4209关于0的力矩和是4*2+2*1-9*1=0.题目要求在区间[a,b]内的balanced number的个数。（ZJU 3416）<Finish/></txt><txt ptr="0xa8959bf0" next="0xa8959f50" prev="0xa8959b60" upper="0xa6c02c6c" lower="(nil)">typedef long long LL ;<Finish/></txt><txt ptr="0xa8959f50" next="0xa895a024" prev="0xa8959bf0" upper="0xa6c02c6c" lower="(nil)">LL dp[19][19][2000];<Finish/></txt><txt ptr="0xa895a024" next="0xa895a0b4" prev="0xa8959f50" upper="0xa6c02c6c" lower="(nil)">int digit[19],o;<Finish/></txt><txt ptr="0xa895a0b4" next="0xa895a144" prev="0xa895a024" upper="0xa6c02c6c" lower="(nil)"><Finish/></txt><txt ptr="0xa895a144" next="0xa895a1d4" prev="0xa895a0b4" upper="0xa6c02c6c" lower="(nil)">LL dfs(int L,int sum,int yes){<Finish/></txt><txt ptr="0xa895a1d4" next="0xa895a264" prev="0xa895a144" upper="0xa6c02c6c" lower="(nil)">*if(L == -1) return sum==0;<Finish/></txt><txt ptr="0xa895a264" next="0xa895a2f4" prev="0xa895a1d4" upper="0xa6c02c6c" lower="(nil)">*if(!yes &amp;&amp; dp[L][o][sum]!=-1)<Finish/></txt><txt ptr="0xa895a2f4" next="0xa895a384" prev="0xa895a264" upper="0xa6c02c6c" lower="(nil)">return dp[L][o][sum];<Finish/></txt><txt ptr="0xa895a384" next="0xa895a414" prev="0xa895a2f4" upper="0xa6c02c6c" lower="(nil)">*int mymax = yes?digit[L]:9;<Finish/></txt><txt ptr="0xa895a414" next="0xa895a4a4" prev="0xa895a384" upper="0xa6c02c6c" lower="(nil)">*LL ans = 0;<Finish/></txt><txt ptr="0xa895a4a4" next="0xa895a534" prev="0xa895a414" upper="0xa6c02c6c" lower="(nil)">*for(int i=0;i&lt;=mymax;i++)<Finish/></txt><txt ptr="0xa895a534" next="0xa895a5c4" prev="0xa895a4a4" upper="0xa6c02c6c" lower="(nil)">**ans+=dfs(L-1,sum+(L-o)*i,yes&amp;(i==mymax));<Finish/></txt><txt ptr="0xa895a5c4" next="0xa895a654" prev="0xa895a534" upper="0xa6c02c6c" lower="(nil)">*if(!yes)dp[L][o][sum]=ans;<Finish/></txt><txt ptr="0xa895a654" next="0xa895a6e4" prev="0xa895a5c4" upper="0xa6c02c6c" lower="(nil)">*return ans;<Finish/></txt><txt ptr="0xa895a6e4" next="0xa895a774" prev="0xa895a654" upper="0xa6c02c6c" lower="(nil)">*<Finish/></txt><txt ptr="0xa895a774" next="0xa895a804" prev="0xa895a6e4" upper="0xa6c02c6c" lower="(nil)">}<Finish/></txt><txt ptr="0xa895a804" next="0xa895a894" prev="0xa895a774" upper="0xa6c02c6c" lower="(nil)">LL call(LL x){<Finish/></txt><txt ptr="0xa895a894" next="0xa895a924" prev="0xa895a804" upper="0xa6c02c6c" lower="(nil)">*int pos=0;<Finish/></txt><txt ptr="0xa895a924" next="(nil)" prev="0xa895a894" upper="0xa6c02c6c" lower="(nil)">*LL ans=0;<Finish/></txt></body></column><column ptr="0xa6c01d7c" next="(nil)" prev="0xa6c01d18" upper="0xa998c284" lower="0xa6c02ccc"><body ptr="0xa6c02ccc" next="(nil)" prev="(nil)" upper="0xa6c01d7c" lower="0xa895a9b4"><txt ptr="0xa895a9b4" next="0xa895aa44" prev="(nil)" upper="0xa6c02ccc" lower="(nil)">*while(x)digit[pos++]=x%10,x/=10;<Finish/></txt><txt ptr="0xa895aa44" next="0xa895aad4" prev="0xa895a9b4" upper="0xa6c02ccc" lower="(nil)">*for(o=0;o&lt;pos;o++)ans+=dfs(pos-1,0,1);<Finish/></txt><txt ptr="0xa895aad4" next="0xa895ab64" prev="0xa895aa44" upper="0xa6c02ccc" lower="(nil)">*return ans-pos+1;<Finish/></txt><txt ptr="0xa895ab64" next="0xa895abf4" prev="0xa895aad4" upper="0xa6c02ccc" lower="(nil)">}<Finish/></txt><txt ptr="0xa895abf4" next="0xa895ac84" prev="0xa895ab64" upper="0xa6c02ccc" lower="(nil)"><Finish/></txt><txt ptr="0xa895ac84" next="0xa895ad14" prev="0xa895abf4" upper="0xa6c02ccc" lower="(nil)">int main(){<Finish/></txt><txt ptr="0xa895ad14" next="0xa895ada4" prev="0xa895ac84" upper="0xa6c02ccc" lower="(nil)">**printf(&quot;%lld\n&quot;,call(b)-call(a-1));<Finish/></txt><txt ptr="0xa895ada4" next="0xa895ae34" prev="0xa895ad14" upper="0xa6c02ccc" lower="(nil)">}<Finish/></txt><txt ptr="0xa895ae34" next="0xa895aec4" prev="0xa895ada4" upper="0xa6c02ccc" lower="(nil)">求区间内第几个满足条件的数<Finish/></txt><txt ptr="0xa895aec4" next="0xa895af54" prev="0xa895ae34" upper="0xa6c02ccc" lower="(nil)">区间（P,Q）之间第K大的Nya数（含x个4，y个7）<Finish/></txt><txt ptr="0xa895af54" next="0xa895b028" prev="0xa895aec4" upper="0xa6c02ccc" lower="(nil)"><Finish/></txt><txt ptr="0xa895b028" next="0xa895b0b8" prev="0xa895af54" upper="0xa6c02ccc" lower="(nil)">typedef __int64 LL;<Finish/></txt><txt ptr="0xa895b0b8" next="0xa895b148" prev="0xa895b028" upper="0xa6c02ccc" lower="(nil)">LL dp[21][21][21][2];<Finish/></txt><txt ptr="0xa895b148" next="0xa895b1d8" prev="0xa895b0b8" upper="0xa6c02ccc" lower="(nil)">LL p,q,ans;<Finish/></txt><txt ptr="0xa895b1d8" next="0xa895b538" prev="0xa895b148" upper="0xa6c02ccc" lower="(nil)">int x,y;<Finish/></txt><txt ptr="0xa895b538" next="0xa895b5c8" prev="0xa895b1d8" upper="0xa6c02ccc" lower="(nil)">int dig[32],len;<Finish/></txt><txt ptr="0xa895b5c8" next="0xa895b658" prev="0xa895b538" upper="0xa6c02ccc" lower="(nil)"><Finish/></txt><txt ptr="0xa895b658" next="0xa895b6e8" prev="0xa895b5c8" upper="0xa6c02ccc" lower="(nil)">LL cnt(int d,int n4,int n7,bool yes){<Finish/></txt><txt ptr="0xa895b6e8" next="0xa895b778" prev="0xa895b658" upper="0xa6c02ccc" lower="(nil)">*<Finish/></txt><txt ptr="0xa895b778" next="0xa895b808" prev="0xa895b6e8" upper="0xa6c02ccc" lower="(nil)">*if(n4 &gt; x || n7&gt;y)return 0;<Finish/></txt><txt ptr="0xa895b808" next="0xa895b898" prev="0xa895b778" upper="0xa6c02ccc" lower="(nil)">*if(d==-1)return n4==x &amp;&amp; n7==y;<Finish/></txt><txt ptr="0xa895b898" next="0xa895b928" prev="0xa895b808" upper="0xa6c02ccc" lower="(nil)">*LL &amp;ret = dp[d][n4][n7][yes];<Finish/></txt><txt ptr="0xa895b928" next="0xa895b9b8" prev="0xa895b898" upper="0xa6c02ccc" lower="(nil)">*if(ret!=-1)return ret;<Finish/></txt><txt ptr="0xa895b9b8" next="0xa895ba48" prev="0xa895b928" upper="0xa6c02ccc" lower="(nil)">*ret = 0;<Finish/></txt><txt ptr="0xa895ba48" next="0xa895bad8" prev="0xa895b9b8" upper="0xa6c02ccc" lower="(nil)">*int t = yes?dig[d]:9;<Finish/></txt><txt ptr="0xa895bad8" next="0xa895bb68" prev="0xa895ba48" upper="0xa6c02ccc" lower="(nil)">*for(int i=0;i&lt;=t;i++)<Finish/></txt><txt ptr="0xa895bb68" next="(nil)" prev="0xa895bad8" upper="0xa6c02ccc" lower="(nil)" follow="0xa893b00c">**ret+=cnt(d-1,n4+(i==4),n7+(i==7),yes&amp;&amp;i==t);<Finish/></txt></body></column></section></body><footer ptr="0xa8998c00" next="(nil)" prev="0xa998e24c" upper="0xa8993ef4" lower="0xa9992530"><txt ptr="0xa9992530" next="0xa99926e0" prev="(nil)" upper="0xa8998c00" lower="(nil)"><anchored><fly ptr="0xb7404b8" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99925c0"><txt ptr="0xa99925c0" next="0xa9992650" prev="(nil)" upper="0xb7404b8" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa9992650" next="(nil)" prev="0xa99925c0" upper="0xb7404b8" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="3"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="5"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99926e0" next="(nil)" prev="0xa9992530" upper="0xa8998c00" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa8993f68" next="0xa9996004" prev="0xa8993ef4" upper="0xb0726b0" lower="0xa8996c60"><header ptr="0xa8996c60" next="0xa998e3cc" prev="(nil)" upper="0xa8993f68" lower="0xa9993a44"><txt ptr="0xa9993a44" next="(nil)" prev="(nil)" upper="0xa8996c60" lower="(nil)"><Finish/></txt></header><body ptr="0xa998e3cc" next="0xa8998c60" prev="0xa8996c60" upper="0xa8993f68" lower="0xa894bb0c"><section ptr="0xa894bb0c" next="(nil)" prev="(nil)" upper="0xa998e3cc" lower="0xa892391c" follow="0xa894bc0c" precede="0xa998c284"><column ptr="0xa892391c" next="0xa8923980" prev="(nil)" upper="0xa894bb0c" lower="0xa8920e08"><body ptr="0xa8920e08" next="(nil)" prev="(nil)" upper="0xa892391c" lower="0xa893b00c"><txt ptr="0xa893b00c" next="0xa895bbf8" prev="(nil)" upper="0xa8920e08" lower="(nil)" precede="0xa895bb68">**ret+=cnt(d-1,n4+(i==4),n7+(i==7),yes&amp;&amp;i==t);<Finish/></txt><txt ptr="0xa895bbf8" next="0xa895bc88" prev="0xa893b00c" upper="0xa8920e08" lower="(nil)">*<Finish/></txt><txt ptr="0xa895bc88" next="0xa895bd18" prev="0xa895bbf8" upper="0xa8920e08" lower="(nil)">*return ret;*<Finish/></txt><txt ptr="0xa895bd18" next="0xa895bda8" prev="0xa895bc88" upper="0xa8920e08" lower="(nil)">}<Finish/></txt><txt ptr="0xa895bda8" next="0xa895be38" prev="0xa895bd18" upper="0xa8920e08" lower="(nil)">LL count(LL a){<Finish/></txt><txt ptr="0xa895be38" next="0xa895bec8" prev="0xa895bda8" upper="0xa8920e08" lower="(nil)">*memset(dp,-1,sizeof(dp));<Finish/></txt><txt ptr="0xa895bec8" next="0xa895bf58" prev="0xa895be38" upper="0xa8920e08" lower="(nil)">*len=0;<Finish/></txt><txt ptr="0xa895bf58" next="0xa895c000" prev="0xa895bec8" upper="0xa8920e08" lower="(nil)">*if(a==0)dig[len++]=0;<Finish/></txt><txt ptr="0xa895c000" next="0xa895c090" prev="0xa895bf58" upper="0xa8920e08" lower="(nil)">*else{<Finish/></txt><txt ptr="0xa895c090" next="0xa895c120" prev="0xa895c000" upper="0xa8920e08" lower="(nil)">**while(a)dig[len++]=a%10,a/=10;<Finish/></txt><txt ptr="0xa895c120" next="0xa895c1b0" prev="0xa895c090" upper="0xa8920e08" lower="(nil)">*}<Finish/></txt><txt ptr="0xa895c1b0" next="0xa895c240" prev="0xa895c120" upper="0xa8920e08" lower="(nil)">*return cnt(len-1,0,0,1);<Finish/></txt><txt ptr="0xa895c240" next="0xa895c2d0" prev="0xa895c1b0" upper="0xa8920e08" lower="(nil)">}<Finish/></txt><txt ptr="0xa895c2d0" next="0xa895c360" prev="0xa895c240" upper="0xa8920e08" lower="(nil)"><Finish/></txt><txt ptr="0xa895c360" next="0xa895c3f0" prev="0xa895c2d0" upper="0xa8920e08" lower="(nil)">void findK(int d,int n4,int n7,bool yes,LL k){<Finish/></txt><txt ptr="0xa895c3f0" next="0xa895c480" prev="0xa895c360" upper="0xa8920e08" lower="(nil)">*if(d&lt;0)return ;<Finish/></txt><txt ptr="0xa895c480" next="0xa895c510" prev="0xa895c3f0" upper="0xa8920e08" lower="(nil)">*int t=yes?dig[d]:9,i;<Finish/></txt><txt ptr="0xa895c510" next="0xa895c5a0" prev="0xa895c480" upper="0xa8920e08" lower="(nil)">*for(i=0;i&lt;=t;i++){<Finish/></txt><txt ptr="0xa895c5a0" next="0xa895c630" prev="0xa895c510" upper="0xa8920e08" lower="(nil)">**LL tmp=cnt(d-1,n4+(i==4),n7+(i==7),yes&amp;&amp;i==t);<Finish/></txt><txt ptr="0xa895c630" next="0xa895c6c0" prev="0xa895c5a0" upper="0xa8920e08" lower="(nil)">**if(tmp&gt;=k){<Finish/></txt><txt ptr="0xa895c6c0" next="0xa895c750" prev="0xa895c630" upper="0xa8920e08" lower="(nil)">***ans = ans*10+i;<Finish/></txt><txt ptr="0xa895c750" next="0xa895cab0" prev="0xa895c6c0" upper="0xa8920e08" lower="(nil)">***findK(d-1,n4+(i==4),n7+(i==7),yes&amp;&amp;i==t,k);<Finish/></txt><txt ptr="0xa895cab0" next="0xa895cb40" prev="0xa895c750" upper="0xa8920e08" lower="(nil)">***return ;<Finish/></txt><txt ptr="0xa895cb40" next="0xa895cbd0" prev="0xa895cab0" upper="0xa8920e08" lower="(nil)">**}else{<Finish/></txt><txt ptr="0xa895cbd0" next="0xa895cc60" prev="0xa895cb40" upper="0xa8920e08" lower="(nil)">***k-=tmp;<Finish/></txt><txt ptr="0xa895cc60" next="(nil)" prev="0xa895cbd0" upper="0xa8920e08" lower="(nil)">**}<Finish/></txt></body></column><column ptr="0xa8923980" next="0xa89239e4" prev="0xa892391c" upper="0xa894bb0c" lower="0xa8920e68"><body ptr="0xa8920e68" next="(nil)" prev="(nil)" upper="0xa8923980" lower="0xa895ccf0"><txt ptr="0xa895ccf0" next="0xa895cd80" prev="(nil)" upper="0xa8920e68" lower="(nil)">**<Finish/></txt><txt ptr="0xa895cd80" next="0xa895ce10" prev="0xa895ccf0" upper="0xa8920e68" lower="(nil)">*}<Finish/></txt><txt ptr="0xa895ce10" next="0xa895cea0" prev="0xa895cd80" upper="0xa8920e68" lower="(nil)">*<Finish/></txt><txt ptr="0xa895cea0" next="0xa895cf30" prev="0xa895ce10" upper="0xa8920e68" lower="(nil)">*<Finish/></txt><txt ptr="0xa895cf30" next="0xa893e004" prev="0xa895cea0" upper="0xa8920e68" lower="(nil)">}<Finish/></txt><txt ptr="0xa893e004" next="0xa893e094" prev="0xa895cf30" upper="0xa8920e68" lower="(nil)"><Finish/></txt><txt ptr="0xa893e094" next="0xa893e124" prev="0xa893e004" upper="0xa8920e68" lower="(nil)">int main(){<Finish/></txt><txt ptr="0xa893e124" next="0xa893e1b4" prev="0xa893e094" upper="0xa8920e68" lower="(nil)">*int T ,cas=0;<Finish/></txt><txt ptr="0xa893e1b4" next="0xa893e244" prev="0xa893e124" upper="0xa8920e68" lower="(nil)">*for(scanf(&quot;%d&quot;,&amp;T);T--;){<Finish/></txt><txt ptr="0xa893e244" next="0xa893e2d4" prev="0xa893e1b4" upper="0xa8920e68" lower="(nil)">**scanf(&quot;%I64d%I64d%d%d&quot;,&amp;p,&amp;q,&amp;x,&amp;y);<Finish/></txt><txt ptr="0xa893e2d4" next="0xa893e364" prev="0xa893e244" upper="0xa8920e68" lower="(nil)">**LL l = count(p),r=count(q);<Finish/></txt><txt ptr="0xa893e364" next="0xa893e3f4" prev="0xa893e2d4" upper="0xa8920e68" lower="(nil)">**int n;<Finish/></txt><txt ptr="0xa893e3f4" next="0xa893e484" prev="0xa893e364" upper="0xa8920e68" lower="(nil)">**scanf(&quot;%d&quot;,&amp;n);<Finish/></txt><txt ptr="0xa893e484" next="0xa893e514" prev="0xa893e3f4" upper="0xa8920e68" lower="(nil)">**printf(&quot;Case #%d:\n&quot;,++cas);<Finish/></txt><txt ptr="0xa893e514" next="0xa893e5a4" prev="0xa893e484" upper="0xa8920e68" lower="(nil)">**while(n--){<Finish/></txt><txt ptr="0xa893e5a4" next="0xa893e634" prev="0xa893e514" upper="0xa8920e68" lower="(nil)">***int k;<Finish/></txt><txt ptr="0xa893e634" next="0xa893e6c4" prev="0xa893e5a4" upper="0xa8920e68" lower="(nil)">***scanf(&quot;%d&quot;,&amp;k);<Finish/></txt><txt ptr="0xa893e6c4" next="0xa893e754" prev="0xa893e634" upper="0xa8920e68" lower="(nil)">***if(k&gt;r-l)puts(&quot;Nya!&quot;);<Finish/></txt><txt ptr="0xa893e754" next="0xa893e7e4" prev="0xa893e6c4" upper="0xa8920e68" lower="(nil)">***else{<Finish/></txt><txt ptr="0xa893e7e4" next="0xa893e874" prev="0xa893e754" upper="0xa8920e68" lower="(nil)">****ans=0;<Finish/></txt><txt ptr="0xa893e874" next="0xa893e904" prev="0xa893e7e4" upper="0xa8920e68" lower="(nil)">****findK(len,0,0,1,l+k);<Finish/></txt><txt ptr="0xa893e904" next="0xa893e994" prev="0xa893e874" upper="0xa8920e68" lower="(nil)">****printf(&quot;%I64d\n&quot;,ans);<Finish/></txt><txt ptr="0xa893e994" next="0xa893ea24" prev="0xa893e904" upper="0xa8920e68" lower="(nil)">***}<Finish/></txt><txt ptr="0xa893ea24" next="0xa893eab4" prev="0xa893e994" upper="0xa8920e68" lower="(nil)">**}<Finish/></txt><txt ptr="0xa893eab4" next="0xa893eb44" prev="0xa893ea24" upper="0xa8920e68" lower="(nil)">**<Finish/></txt><txt ptr="0xa893eb44" next="0xa893ebd4" prev="0xa893eab4" upper="0xa8920e68" lower="(nil)">*}<Finish/></txt><txt ptr="0xa893ebd4" next="0xa893ec64" prev="0xa893eb44" upper="0xa8920e68" lower="(nil)">*<Finish/></txt><txt ptr="0xa893ec64" next="(nil)" prev="0xa893ebd4" upper="0xa8920e68" lower="(nil)">*return 0;<Finish/></txt></body></column><column ptr="0xa89239e4" next="(nil)" prev="0xa8923980" upper="0xa894bb0c" lower="0xa8920ec8"><body ptr="0xa8920ec8" next="(nil)" prev="(nil)" upper="0xa89239e4" lower="0xa893ecf4"><txt ptr="0xa893ecf4" next="0xa8941098" prev="(nil)" upper="0xa8920ec8" lower="(nil)">}<Finish/></txt><txt ptr="0xa8941098" next="0xa8941128" prev="0xa893ecf4" upper="0xa8920ec8" lower="(nil)">STL<Finish/></txt><txt ptr="0xa8941128" next="0xa89411b8" prev="0xa8941098" upper="0xa8920ec8" lower="(nil)">vector<Finish/></txt><txt ptr="0xa89411b8" next="0xa8941248" prev="0xa8941128" upper="0xa8920ec8" lower="(nil)">sront() 返回首元素。<Finish/></txt><txt ptr="0xa8941248" next="0xa89412d8" prev="0xa89411b8" upper="0xa8920ec8" lower="(nil)">back() 返回尾元素。<Finish/></txt><txt ptr="0xa89412d8" next="0xa8941368" prev="0xa8941248" upper="0xa8920ec8" lower="(nil)">push_back(x) 向表尾插入元素x。<Finish/></txt><txt ptr="0xa8941368" next="0xa89413f8" prev="0xa89412d8" upper="0xa8920ec8" lower="(nil)">size() 返回表长。<Finish/></txt><txt ptr="0xa89413f8" next="0xa8941488" prev="0xa8941368" upper="0xa8920ec8" lower="(nil)">empty() 当表空时，返回真，否则返回假。<Finish/></txt><txt ptr="0xa8941488" next="0xa8941518" prev="0xa89413f8" upper="0xa8920ec8" lower="(nil)">pop_back() 删除表尾元素。<Finish/></txt><txt ptr="0xa8941518" next="0xa89415a8" prev="0xa8941488" upper="0xa8920ec8" lower="(nil)">begin() 返回指向首元素的随机存取迭代器。<Finish/></txt><txt ptr="0xa89415a8" next="0xa8941638" prev="0xa8941518" upper="0xa8920ec8" lower="(nil)">end() 返回指向尾元素的下一个位置的随机存取迭代器。<Finish/></txt><txt ptr="0xa8941638" next="0xa89416c8" prev="0xa89415a8" upper="0xa8920ec8" lower="(nil)">insert(it, x) 向迭代器it指向的元素前插入新元素val。<Finish/></txt><txt ptr="0xa89416c8" next="0xa8941758" prev="0xa8941638" upper="0xa8920ec8" lower="(nil)">s.clear() 删除容器中的所有的元素。<Finish/></txt><txt ptr="0xa8941758" next="0xa89417e8" prev="0xa89416c8" upper="0xa8920ec8" lower="(nil)">优先队列<Finish/></txt><txt ptr="0xa89417e8" next="0xa8941878" prev="0xa8941758" upper="0xa8920ec8" lower="(nil)">头文件：#include&lt;queue&gt;<Finish/></txt><txt ptr="0xa8941878" next="0xa8941908" prev="0xa89417e8" upper="0xa8920ec8" lower="(nil)">优先队列，也就是原来我们学过的堆，按照自己定义的优先级出队时。默认情况下底层是以Vector实现的heap。<Finish/></txt><txt ptr="0xa8941908" next="0xa8941998" prev="0xa8941878" upper="0xa8920ec8" lower="(nil)">既然是队列，也就只有入队、出队、判空、大小的操作，并不具备查找功能。<Finish/></txt><txt ptr="0xa8941998" next="0xa8941a28" prev="0xa8941908" upper="0xa8920ec8" lower="(nil)">函数列表：<Finish/></txt><txt ptr="0xa8941a28" next="0xa8941ab8" prev="0xa8941998" upper="0xa8920ec8" lower="(nil)">empty() 如果优先队列为空，则返回真 <Finish/></txt><txt ptr="0xa8941ab8" next="0xa8941b48" prev="0xa8941a28" upper="0xa8920ec8" lower="(nil)">pop() 删除第一个元素 <Finish/></txt><txt ptr="0xa8941b48" next="(nil)" prev="0xa8941ab8" upper="0xa8920ec8" lower="(nil)">push() 加入一个元素 <Finish/></txt></body></column></section></body><footer ptr="0xa8998c60" next="(nil)" prev="0xa998e3cc" upper="0xa8993f68" lower="0xa9993ad4"><txt ptr="0xa9993ad4" next="0xa9993c84" prev="(nil)" upper="0xa8998c60" lower="(nil)"><anchored><fly ptr="0xb708118" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa9993b64"><txt ptr="0xa9993b64" next="0xa9993bf4" prev="(nil)" upper="0xb708118" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa9993bf4" next="(nil)" prev="0xa9993b64" upper="0xb708118" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="3"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="6"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa9993c84" next="(nil)" prev="0xa9993ad4" upper="0xa8998c60" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996004" next="0xa9996078" prev="0xa8993f68" upper="0xb0726b0" lower="0xa8996cc0"><header ptr="0xa8996cc0" next="0xa998e54c" prev="(nil)" upper="0xa9996004" lower="0xa9997000"><txt ptr="0xa9997000" next="(nil)" prev="(nil)" upper="0xa8996cc0" lower="(nil)"><Finish/></txt></header><body ptr="0xa998e54c" next="0xa8998cc0" prev="0xa8996cc0" upper="0xa9996004" lower="0xa894bc0c"><section ptr="0xa894bc0c" next="(nil)" prev="(nil)" upper="0xa998e54c" lower="0xa8923b74" follow="0xa99bcd80" precede="0xa894bb0c"><column ptr="0xa8923b74" next="0xa8923bd8" prev="(nil)" upper="0xa894bc0c" lower="0xa8910120"><body ptr="0xa8910120" next="(nil)" prev="(nil)" upper="0xa8923b74" lower="0xa8941bd8"><txt ptr="0xa8941bd8" next="0xa8941c68" prev="(nil)" upper="0xa8910120" lower="(nil)">size() 返回优先队列中拥有的元素的个数 <Finish/></txt><txt ptr="0xa8941c68" next="0xa8941cf8" prev="0xa8941bd8" upper="0xa8910120" lower="(nil)">top() 返回优先队列中有最高优先级的元素<Finish/></txt><txt ptr="0xa8941cf8" next="0xa8941d88" prev="0xa8941c68" upper="0xa8910120" lower="(nil)"><Finish/></txt><txt ptr="0xa8941d88" next="0xa8941e18" prev="0xa8941cf8" upper="0xa8910120" lower="(nil)">一：最基本的功能<Finish/></txt><txt ptr="0xa8941e18" next="0xa8941ea8" prev="0xa8941d88" upper="0xa8910120" lower="(nil)">优先队列最基本的功能就是出队时不是按照先进先出的规则，而是按照队列中优先级顺序出队。<Finish/></txt><txt ptr="0xa8941ea8" next="0xa8941f38" prev="0xa8941e18" upper="0xa8910120" lower="(nil)">知识点：1、一般存放实型类型，可比较大小<Finish/></txt><txt ptr="0xa8941f38" next="0xa894200c" prev="0xa8941ea8" upper="0xa8910120" lower="(nil)">2、默认情况下底层以Vector实现<Finish/></txt><txt ptr="0xa894200c" next="0xa894209c" prev="0xa8941f38" upper="0xa8910120" lower="(nil)">3、默认情况下是大顶堆，也就是大者优先级高，后面可以自定义优先级比较规则<Finish/></txt><txt ptr="0xa894209c" next="0xa894212c" prev="0xa894200c" upper="0xa8910120" lower="(nil)"><Finish/></txt><txt ptr="0xa894212c" next="0xa89421bc" prev="0xa894209c" upper="0xa8910120" lower="(nil)">二：次基本的功能<Finish/></txt><txt ptr="0xa89421bc" next="0xa894224c" prev="0xa894212c" upper="0xa8910120" lower="(nil)">可以将一个存放实型类型的数据结构转化为优先队列，这里跟优先队列的构造函数相关。<Finish/></txt><txt ptr="0xa894224c" next="0xa89422dc" prev="0xa89421bc" upper="0xa8910120" lower="(nil)">上面那个默认构造一个空的优先队列，什么都使用默认的。<Finish/></txt><txt ptr="0xa89422dc" next="0xa894263c" prev="0xa894224c" upper="0xa8910120" lower="(nil)">而这里使用的是Priority_queue(InputIterator first,InputIterator last)<Finish/></txt><txt ptr="0xa894263c" next="0xa89426cc" prev="0xa89422dc" upper="0xa8910120" lower="(nil)">我理解的就是给出了一个容器的开口和结尾，然后把这个容器内容拷贝到底层实现(默认vector)中去构造出优先队列。<Finish/></txt><txt ptr="0xa89426cc" next="0xa894275c" prev="0xa894263c" upper="0xa8910120" lower="(nil)">这里也使用了一个默认的比较函数，也是默认大顶堆<Finish/></txt><txt ptr="0xa894275c" next="0xa89427ec" prev="0xa89426cc" upper="0xa8910120" lower="(nil)">例如： <Finish/></txt><txt ptr="0xa89427ec" next="0xa894287c" prev="0xa894275c" upper="0xa8910120" lower="(nil)">int a[5]={3,4,5,2,1};<Finish/></txt><txt ptr="0xa894287c" next="0xa894290c" prev="0xa89427ec" upper="0xa8910120" lower="(nil)">priority_queue&lt;int&gt; Q(a,a+5);<Finish/></txt><txt ptr="0xa894290c" next="0xa894299c" prev="0xa894287c" upper="0xa8910120" lower="(nil)"><Finish/></txt><txt ptr="0xa894299c" next="0xa8942a2c" prev="0xa894290c" upper="0xa8910120" lower="(nil)">三 应该掌握的功能:<Finish/></txt><txt ptr="0xa8942a2c" next="(nil)" prev="0xa894299c" upper="0xa8910120" lower="(nil)" follow="0xa8939b44">这个里面定义了一个制定存放元素(Node),底层实现以vector实现（第二个参数）,优先级为小顶堆(第三个参数)。<Finish/></txt></body></column><column ptr="0xa8923bd8" next="0xa8923c3c" prev="0xa8923b74" upper="0xa894bc0c" lower="0xa8910180"><body ptr="0xa8910180" next="(nil)" prev="(nil)" upper="0xa8923bd8" lower="0xa8939b44"><txt ptr="0xa8939b44" next="0xa8942abc" prev="(nil)" upper="0xa8910180" lower="(nil)" precede="0xa8942a2c">这个里面定义了一个制定存放元素(Node),底层实现以vector实现（第二个参数）,优先级为小顶堆(第三个参数)。<Finish/></txt><txt ptr="0xa8942abc" next="0xa8942b4c" prev="0xa8939b44" upper="0xa8910180" lower="(nil)">前两个参数没什么说的，很好理解，其中第三个参数，默认有三写法：<Finish/></txt><txt ptr="0xa8942b4c" next="0xa8942bdc" prev="0xa8942abc" upper="0xa8910180" lower="(nil)">小顶堆：greater&lt;TYPE&gt;<Finish/></txt><txt ptr="0xa8942bdc" next="0xa8942c6c" prev="0xa8942b4c" upper="0xa8910180" lower="(nil)">大顶堆：less&lt;TYPE&gt;<Finish/></txt><txt ptr="0xa8942c6c" next="0xa8942cfc" prev="0xa8942bdc" upper="0xa8910180" lower="(nil)">如果想自定义优先级而TYPE不是基本类型，而是复杂类型，例如结构体、类对象，则必须重载其中的operator()，见下面的例子。<Finish/></txt><txt ptr="0xa8942cfc" next="0xa8942d8c" prev="0xa8942c6c" upper="0xa8910180" lower="(nil)"><Finish/></txt><txt ptr="0xa8942d8c" next="0xa8942e1c" prev="0xa8942cfc" upper="0xa8910180" lower="(nil)">typedef struct {int a,b;}Node;  //自定义优先级类型<Finish/></txt><txt ptr="0xa8942e1c" next="0xa8942eac" prev="0xa8942d8c" upper="0xa8910180" lower="(nil)">struct cmp{<Finish/></txt><txt ptr="0xa8942eac" next="0xa8942f3c" prev="0xa8942e1c" upper="0xa8910180" lower="(nil)">    bool operator()(const Node &amp;t1,const Node &amp;t2){<Finish/></txt><txt ptr="0xa8942f3c" next="0xa8943010" prev="0xa8942eac" upper="0xa8910180" lower="(nil)">    *return t1.b&lt;t2.b;//相当于less,大顶堆    <Finish/></txt><txt ptr="0xa8943010" next="0xa89430a0" prev="0xa8942f3c" upper="0xa8910180" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89430a0" next="0xa8943130" prev="0xa8943010" upper="0xa8910180" lower="(nil)">};<Finish/></txt><txt ptr="0xa8943130" next="0xa89431c0" prev="0xa89430a0" upper="0xa8910180" lower="(nil)"><Finish/></txt><txt ptr="0xa89431c0" next="0xa8943250" prev="0xa8943130" upper="0xa8910180" lower="(nil)">priority_queue&lt;Node,vector&lt;Node&gt;,cmp&gt; Q;<Finish/></txt><txt ptr="0xa8943250" next="0xa89432e0" prev="0xa89431c0" upper="0xa8910180" lower="(nil)">排序<Finish/></txt><txt ptr="0xa89432e0" next="0xa8943370" prev="0xa8943250" upper="0xa8910180" lower="(nil)">sort对给定区间所有元素进行排序<Finish/></txt><txt ptr="0xa8943370" next="0xa8943400" prev="0xa89432e0" upper="0xa8910180" lower="(nil)">stable_sort对给定区间所有元素进行稳定排序<Finish/></txt><txt ptr="0xa8943400" next="0xa8943490" prev="0xa8943370" upper="0xa8910180" lower="(nil)">partial_sort对给定区间所有元素部分排序<Finish/></txt><txt ptr="0xa8943490" next="0xa8943520" prev="0xa8943400" upper="0xa8910180" lower="(nil)">partial_sort_copy对给定区间复制并排序<Finish/></txt><txt ptr="0xa8943520" next="0xa89435b0" prev="0xa8943490" upper="0xa8910180" lower="(nil)">nth_element找出给定区间的某个位置对应的元素<Finish/></txt><txt ptr="0xa89435b0" next="0xa8943640" prev="0xa8943520" upper="0xa8910180" lower="(nil)">is_sorted判断一个区间是否已经排好序<Finish/></txt><txt ptr="0xa8943640" next="0xa89436d0" prev="0xa89435b0" upper="0xa8910180" lower="(nil)">partition使得符合某个条件的元素放在前面<Finish/></txt><txt ptr="0xa89436d0" next="(nil)" prev="0xa8943640" upper="0xa8910180" lower="(nil)" follow="0xa8938360">stable_partition相对稳定的使得符合某个条件的元素放在前面<Finish/></txt></body></column><column ptr="0xa8923c3c" next="(nil)" prev="0xa8923bd8" upper="0xa894bc0c" lower="0xa89101e0"><body ptr="0xa89101e0" next="(nil)" prev="(nil)" upper="0xa8923c3c" lower="0xa8938360"><txt ptr="0xa8938360" next="0xa8943760" prev="(nil)" upper="0xa89101e0" lower="(nil)" precede="0xa89436d0">stable_partition相对稳定的使得符合某个条件的元素放在前面<Finish/></txt><txt ptr="0xa8943760" next="0xa89437f0" prev="0xa8938360" upper="0xa89101e0" lower="(nil)">sort<Finish/></txt><txt ptr="0xa89437f0" next="0xa8943880" prev="0xa8943760" upper="0xa89101e0" lower="(nil)">sort函数需包含#include &lt;algorithm&gt;<Finish/></txt><txt ptr="0xa8943880" next="0xa8943be0" prev="0xa89437f0" upper="0xa89101e0" lower="(nil)">sort(begin,end)，表示一个范围，默认升序，基本类型可以这样写<Finish/></txt><txt ptr="0xa8943be0" next="0xa8943c70" prev="0xa8943880" upper="0xa89101e0" lower="(nil)">sort(begin,end,compare) 可实现自定义的排序，主要用于自定义类型<Finish/></txt><txt ptr="0xa8943c70" next="0xa8943d00" prev="0xa8943be0" upper="0xa89101e0" lower="(nil)">bool compare(T a,T b){<Finish/></txt><txt ptr="0xa8943d00" next="0xa8943d90" prev="0xa8943c70" upper="0xa89101e0" lower="(nil)">*return a-b;<Finish/></txt><txt ptr="0xa8943d90" next="0xa8943e20" prev="0xa8943d00" upper="0xa89101e0" lower="(nil)">} <Finish/></txt><txt ptr="0xa8943e20" next="0xa8943eb0" prev="0xa8943d90" upper="0xa89101e0" lower="(nil)">bool operator &lt; (const T &amp;m)const {<Finish/></txt><txt ptr="0xa8943eb0" next="0xa8943f40" prev="0xa8943e20" upper="0xa89101e0" lower="(nil)">    return num &gt; m.num;<Finish/></txt><txt ptr="0xa8943f40" next="0xa8944014" prev="0xa8943eb0" upper="0xa89101e0" lower="(nil)">}<Finish/></txt><txt ptr="0xa8944014" next="0xa89440a4" prev="0xa8943f40" upper="0xa89101e0" lower="(nil)"><Finish/></txt><txt ptr="0xa89440a4" next="0xa8944134" prev="0xa8944014" upper="0xa89101e0" lower="(nil)">对于基本类型，可以不编写compare<Finish/></txt><txt ptr="0xa8944134" next="0xa89441c4" prev="0xa89440a4" upper="0xa89101e0" lower="(nil)"><Finish/></txt><txt ptr="0xa89441c4" next="0xa8944254" prev="0xa8944134" upper="0xa89101e0" lower="(nil)">升序：sort(begin,end,less&lt;data-type&gt;());<Finish/></txt><txt ptr="0xa8944254" next="0xa89442e4" prev="0xa89441c4" upper="0xa89101e0" lower="(nil)">降序：sort(begin,end,greater&lt;data-type&gt;()).<Finish/></txt><txt ptr="0xa89442e4" next="0xa8944374" prev="0xa8944254" upper="0xa89101e0" lower="(nil)">qsort()<Finish/></txt><txt ptr="0xa8944374" next="0xa8944404" prev="0xa89442e4" upper="0xa89101e0" lower="(nil)">原型:<Finish/></txt><txt ptr="0xa8944404" next="0xa8944494" prev="0xa8944374" upper="0xa89101e0" lower="(nil)">_CRTIMP void __cdecl qsort (void*, size_t, size_t,int (*)(const void*, const void*));<Finish/></txt><txt ptr="0xa8944494" next="0xa8944524" prev="0xa8944404" upper="0xa89101e0" lower="(nil)"><Finish/></txt><txt ptr="0xa8944524" next="0xa89445b4" prev="0xa8944494" upper="0xa89101e0" lower="(nil)">解释: qsort ( 起始地址,元素个数,元素大小，比较函数) <Finish/></txt><txt ptr="0xa89445b4" next="0xa8944644" prev="0xa8944524" upper="0xa89101e0" lower="(nil)">比较函数是一个自己写的函数 <Finish/></txt><txt ptr="0xa8944644" next="0xa89446d4" prev="0xa89445b4" upper="0xa89101e0" lower="(nil)">遵循 int com(const void *a,const void *b) 的格式。<Finish/></txt><txt ptr="0xa89446d4" next="(nil)" prev="0xa8944644" upper="0xa89101e0" lower="(nil)" follow="0xa8939994">当a b关系为 &gt;  &lt;  = 时，分别返回正值 负值 零 （或者相反）。<Finish/></txt></body></column></section></body><footer ptr="0xa8998cc0" next="(nil)" prev="0xa998e54c" upper="0xa9996004" lower="0xa9997090"><txt ptr="0xa9997090" next="0xa9997240" prev="(nil)" upper="0xa8998cc0" lower="(nil)"><anchored><fly ptr="0xb52d550" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa9997120"><txt ptr="0xa9997120" next="0xa99971b0" prev="(nil)" upper="0xb52d550" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99971b0" next="(nil)" prev="0xa9997120" upper="0xb52d550" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="3"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="7"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa9997240" next="(nil)" prev="0xa9997090" upper="0xa8998cc0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996078" next="0xa99960ec" prev="0xa9996004" upper="0xb0726b0" lower="0xa8996d20"><header ptr="0xa8996d20" next="0xa998e6cc" prev="(nil)" upper="0xa9996078" lower="0xa99985a4"><txt ptr="0xa99985a4" next="(nil)" prev="(nil)" upper="0xa8996d20" lower="(nil)"><Finish/></txt></header><body ptr="0xa998e6cc" next="0xa8998d20" prev="0xa8996d20" upper="0xa9996078" lower="0xa99bcd80"><section ptr="0xa99bcd80" next="(nil)" prev="(nil)" upper="0xa998e6cc" lower="0xa6c032f4" follow="0xa891d090" precede="0xa894bc0c"><column ptr="0xa6c032f4" next="0xa6c03358" prev="(nil)" upper="0xa99bcd80" lower="0xa6c041f0"><body ptr="0xa6c041f0" next="(nil)" prev="(nil)" upper="0xa6c032f4" lower="0xa8939994"><txt ptr="0xa8939994" next="0xa8944764" prev="(nil)" upper="0xa6c041f0" lower="(nil)" precede="0xa89446d4">当a b关系为 &gt;  &lt;  = 时，分别返回正值 负值 零 （或者相反）。<Finish/></txt><txt ptr="0xa8944764" next="0xa89447f4" prev="0xa8939994" upper="0xa6c041f0" lower="(nil)">使用a b 时要强制转换类型，从void * 转换回应有的类型后，进行操作。 <Finish/></txt><txt ptr="0xa89447f4" next="0xa8944884" prev="0xa8944764" upper="0xa6c041f0" lower="(nil)">数组下标从零开始,个数为N, 下标0-(n-1)。<Finish/></txt><txt ptr="0xa8944884" next="0xa8944914" prev="0xa89447f4" upper="0xa6c041f0" lower="(nil)"><Finish/></txt><txt ptr="0xa8944914" next="0xa89449a4" prev="0xa8944884" upper="0xa6c041f0" lower="(nil)">int compare(const void *a,const void *b)<Finish/></txt><txt ptr="0xa89449a4" next="0xa8944a34" prev="0xa8944914" upper="0xa6c041f0" lower="(nil)">{<Finish/></txt><txt ptr="0xa8944a34" next="0xa8944ac4" prev="0xa89449a4" upper="0xa6c041f0" lower="(nil)">     return *(int*)b-*(int*)a;   <Finish/></txt><txt ptr="0xa8944ac4" next="0xa8944b54" prev="0xa8944a34" upper="0xa6c041f0" lower="(nil)">}<Finish/></txt><txt ptr="0xa8944b54" next="0xa8944be4" prev="0xa8944ac4" upper="0xa6c041f0" lower="(nil)">map<Finish/></txt><txt ptr="0xa8944be4" next="0xa8944c74" prev="0xa8944b54" upper="0xa6c041f0" lower="(nil)">set<Finish/></txt><txt ptr="0xa8944c74" next="0xa8944d04" prev="0xa8944be4" upper="0xa6c041f0" lower="(nil)"><Finish/></txt><txt ptr="0xa8944d04" next="0xa8944d94" prev="0xa8944c74" upper="0xa6c041f0" lower="(nil)">双向队列deque<Finish/></txt><txt ptr="0xa8944d94" next="0xa8944e24" prev="0xa8944d04" upper="0xa6c041f0" lower="(nil)">size  Return size <Finish/></txt><txt ptr="0xa8944e24" next="0xa89451c8" prev="0xa8944d94" upper="0xa6c041f0" lower="(nil)">empty  Test whether container is empty <Finish/></txt><txt ptr="0xa89451c8" next="0xa8945258" prev="0xa8944e24" upper="0xa6c041f0" lower="(nil)">push_back  Add element at the end <Finish/></txt><txt ptr="0xa8945258" next="0xa89452e8" prev="0xa89451c8" upper="0xa6c041f0" lower="(nil)">push_front  Insert element at beginning <Finish/></txt><txt ptr="0xa89452e8" next="0xa8945378" prev="0xa8945258" upper="0xa6c041f0" lower="(nil)">pop_back  Delete last element <Finish/></txt><txt ptr="0xa8945378" next="0xa8945408" prev="0xa89452e8" upper="0xa6c041f0" lower="(nil)">pop_front  Delete first element <Finish/></txt><txt ptr="0xa8945408" next="0xa8945498" prev="0xa8945378" upper="0xa6c041f0" lower="(nil)">front  Access first element <Finish/></txt><txt ptr="0xa8945498" next="0xa8945528" prev="0xa8945408" upper="0xa6c041f0" lower="(nil)">back  Access last element <Finish/></txt><txt ptr="0xa8945528" next="0xa89455b8" prev="0xa8945498" upper="0xa6c041f0" lower="(nil)">队列queue<Finish/></txt><txt ptr="0xa89455b8" next="0xa8945648" prev="0xa8945528" upper="0xa6c041f0" lower="(nil)">empty  Test whether container is empty<Finish/></txt><txt ptr="0xa8945648" next="(nil)" prev="0xa89455b8" upper="0xa6c041f0" lower="(nil)">size  Return size<Finish/></txt></body></column><column ptr="0xa6c03358" next="0xa6c033bc" prev="0xa6c032f4" upper="0xa99bcd80" lower="0xa6c04250"><body ptr="0xa6c04250" next="(nil)" prev="(nil)" upper="0xa6c03358" lower="0xa89456d8"><txt ptr="0xa89456d8" next="0xa8945768" prev="(nil)" upper="0xa6c04250" lower="(nil)">front  Access next element<Finish/></txt><txt ptr="0xa8945768" next="0xa89457f8" prev="0xa89456d8" upper="0xa6c04250" lower="(nil)">back  Access last element<Finish/></txt><txt ptr="0xa89457f8" next="0xa8945888" prev="0xa8945768" upper="0xa6c04250" lower="(nil)">push  Insert element<Finish/></txt><txt ptr="0xa8945888" next="0xa8945918" prev="0xa89457f8" upper="0xa6c04250" lower="(nil)">pop   Delete next element<Finish/></txt><txt ptr="0xa8945918" next="0xa89459a8" prev="0xa8945888" upper="0xa6c04250" lower="(nil)">栈stack<Finish/></txt><txt ptr="0xa89459a8" next="0xa8945a38" prev="0xa8945918" upper="0xa6c04250" lower="(nil)">empty() Test whether container is empty <Finish/></txt><txt ptr="0xa8945a38" next="0xa8945ac8" prev="0xa89459a8" upper="0xa6c04250" lower="(nil)">size()  return size <Finish/></txt><txt ptr="0xa8945ac8" next="0xa8945b58" prev="0xa8945a38" upper="0xa6c04250" lower="(nil)">top()  access next element<Finish/></txt><txt ptr="0xa8945b58" next="0xa8945be8" prev="0xa8945ac8" upper="0xa6c04250" lower="(nil)">push()  add element<Finish/></txt><txt ptr="0xa8945be8" next="0xa8945c78" prev="0xa8945b58" upper="0xa6c04250" lower="(nil)">pop()  remove element<Finish/></txt><txt ptr="0xa8945c78" next="0xa8945d08" prev="0xa8945be8" upper="0xa6c04250" lower="(nil)">bitset<Finish/></txt><txt ptr="0xa8945d08" next="0xa8945d98" prev="0xa8945c78" upper="0xa6c04250" lower="(nil)">to_ulong Convert to unsigned long integer<Finish/></txt><txt ptr="0xa8945d98" next="0xa8945e28" prev="0xa8945d08" upper="0xa6c04250" lower="(nil)">to_string Convert to string<Finish/></txt><txt ptr="0xa8945e28" next="0xa8945eb8" prev="0xa8945d98" upper="0xa6c04250" lower="(nil)">count Count bits set<Finish/></txt><txt ptr="0xa8945eb8" next="0xa8945f48" prev="0xa8945e28" upper="0xa6c04250" lower="(nil)">size Return size<Finish/></txt><txt ptr="0xa8945f48" next="0xa894601c" prev="0xa8945eb8" upper="0xa6c04250" lower="(nil)">test Return bit value<Finish/></txt><txt ptr="0xa894601c" next="0xa89460ac" prev="0xa8945f48" upper="0xa6c04250" lower="(nil)">any Test if any bit is set<Finish/></txt><txt ptr="0xa89460ac" next="0xa894613c" prev="0xa894601c" upper="0xa6c04250" lower="(nil)">none Test if no bit is set<Finish/></txt><txt ptr="0xa894613c" next="0xa89461cc" prev="0xa89460ac" upper="0xa6c04250" lower="(nil)">set (int pos） Set bits<Finish/></txt><txt ptr="0xa89461cc" next="0xa894625c" prev="0xa894613c" upper="0xa6c04250" lower="(nil)">reset（int pos） Reset bits<Finish/></txt><txt ptr="0xa894625c" next="0xa89462ec" prev="0xa89461cc" upper="0xa6c04250" lower="(nil)">flip Flip bits<Finish/></txt><txt ptr="0xa89462ec" next="(nil)" prev="0xa894625c" upper="0xa6c04250" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa6c033bc" next="(nil)" prev="0xa6c03358" upper="0xa99bcd80" lower="0xa6c042b0"><body ptr="0xa6c042b0" next="(nil)" prev="(nil)" upper="0xa6c033bc" lower="0xa894637c"><txt ptr="0xa894637c" next="0xa894640c" prev="(nil)" upper="0xa6c042b0" lower="(nil)">博弈<Finish/></txt><txt ptr="0xa894640c" next="0xa894676c" prev="0xa894637c" upper="0xa6c042b0" lower="(nil)">Combinatorial Game<Finish/></txt><txt ptr="0xa894676c" next="0xa89467fc" prev="0xa894640c" upper="0xa6c042b0" lower="(nil)">定义<Finish/></txt><txt ptr="0xa89467fc" next="0xa894688c" prev="0xa894676c" upper="0xa6c042b0" lower="(nil)">1.有两个玩家；<Finish/></txt><txt ptr="0xa894688c" next="0xa894691c" prev="0xa89467fc" upper="0xa6c042b0" lower="(nil)">2.游戏的操作状态是一个有限的集合（比如：限定大小的棋盘）；<Finish/></txt><txt ptr="0xa894691c" next="0xa89469ac" prev="0xa894688c" upper="0xa6c042b0" lower="(nil)">3.游戏双方轮流操作；<Finish/></txt><txt ptr="0xa89469ac" next="0xa8946a3c" prev="0xa894691c" upper="0xa6c042b0" lower="(nil)">4.双方的每次操作必须符合游戏规定；<Finish/></txt><txt ptr="0xa8946a3c" next="0xa8946acc" prev="0xa89469ac" upper="0xa6c042b0" lower="(nil)">5.当一方不能将游戏继续进行的时候，游戏结束，同时，对方为获胜方；<Finish/></txt><txt ptr="0xa8946acc" next="0xa8946b5c" prev="0xa8946a3c" upper="0xa6c042b0" lower="(nil)">6.无论如何操作，游戏总能在有限次操作后结束<Finish/></txt><txt ptr="0xa8946b5c" next="0xa8946bec" prev="0xa8946acc" upper="0xa6c042b0" lower="(nil)"><Finish/></txt><txt ptr="0xa8946bec" next="0xa8946c7c" prev="0xa8946b5c" upper="0xa6c042b0" lower="(nil)">必败点和必胜点<Finish/></txt><txt ptr="0xa8946c7c" next="0xa8946d0c" prev="0xa8946bec" upper="0xa6c042b0" lower="(nil)">必败点(P点) :前一个选手(Previous player)将取胜的位置称为必败点。 <Finish/></txt><txt ptr="0xa8946d0c" next="0xa8946d9c" prev="0xa8946c7c" upper="0xa6c042b0" lower="(nil)">必胜点(N点) :下一个选手(Next player)将取胜的位置称为必胜点。 <Finish/></txt><txt ptr="0xa8946d9c" next="0xa8946e2c" prev="0xa8946d0c" upper="0xa6c042b0" lower="(nil)"><Finish/></txt><txt ptr="0xa8946e2c" next="0xa8946ebc" prev="0xa8946d9c" upper="0xa6c042b0" lower="(nil)">必败(必胜)点属性<Finish/></txt><txt ptr="0xa8946ebc" next="0xa8946f4c" prev="0xa8946e2c" upper="0xa6c042b0" lower="(nil)">(1) 所有终结点是必败点（P点）；<Finish/></txt><txt ptr="0xa8946f4c" next="0xa8947020" prev="0xa8946ebc" upper="0xa6c042b0" lower="(nil)">(2) 从任何必胜点（N点）操作，至少有一种方法可以进入必败点（P点）；<Finish/></txt><txt ptr="0xa8947020" next="0xa89470b0" prev="0xa8946f4c" upper="0xa6c042b0" lower="(nil)">(3)无论如何操作，从必败点（P点）都只能进入必胜点（N点）.<Finish/></txt><txt ptr="0xa89470b0" next="0xa8947140" prev="0xa8947020" upper="0xa6c042b0" lower="(nil)">这三点是组合游戏基本性质<Finish/></txt><txt ptr="0xa8947140" next="(nil)" prev="0xa89470b0" upper="0xa6c042b0" lower="(nil)">可用来判断一游戏是否是组合游戏<Finish/></txt></body></column></section></body><footer ptr="0xa8998d20" next="(nil)" prev="0xa998e6cc" upper="0xa9996078" lower="0xa9998634"><txt ptr="0xa9998634" next="0xa99987e4" prev="(nil)" upper="0xa8998d20" lower="(nil)"><anchored><fly ptr="0xad3e598" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa99986c4"><txt ptr="0xa99986c4" next="0xa9998754" prev="(nil)" upper="0xad3e598" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa9998754" next="(nil)" prev="0xa99986c4" upper="0xad3e598" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="3"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="8"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99987e4" next="(nil)" prev="0xa9998634" upper="0xa8998d20" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa99960ec" next="0xa9996160" prev="0xa9996078" upper="0xb0726b0" lower="0xa8996d80"><header ptr="0xa8996d80" next="0xa998e84c" prev="(nil)" upper="0xa99960ec" lower="0xa9999b48"><txt ptr="0xa9999b48" next="(nil)" prev="(nil)" upper="0xa8996d80" lower="(nil)"><Finish/></txt></header><body ptr="0xa998e84c" next="0xa8998d80" prev="0xa8996d80" upper="0xa99960ec" lower="0xa891d090"><section ptr="0xa891d090" next="(nil)" prev="(nil)" upper="0xa998e84c" lower="0xa8917538" follow="0xa99bcb00" precede="0xa99bcd80"><column ptr="0xa8917538" next="0xa891759c" prev="(nil)" upper="0xa891d090" lower="0xa8910d20"><body ptr="0xa8910d20" next="(nil)" prev="(nil)" upper="0xa8917538" lower="0xa89471d0"><txt ptr="0xa89471d0" next="0xa8947260" prev="(nil)" upper="0xa8910d20" lower="(nil)"><Finish/></txt><txt ptr="0xa8947260" next="0xa89472f0" prev="0xa89471d0" upper="0xa8910d20" lower="(nil)">解决组合游戏问题的一般方法*<Finish/></txt><txt ptr="0xa89472f0" next="0xa8947380" prev="0xa8947260" upper="0xa8910d20" lower="(nil)">步骤1:将所有终结位置标记为必败点（P点）；<Finish/></txt><txt ptr="0xa8947380" next="0xa8947410" prev="0xa89472f0" upper="0xa8910d20" lower="(nil)">步骤2: 将所有一步操作能进入必败点（P点）的位置标记为必胜点（N点）<Finish/></txt><txt ptr="0xa8947410" next="0xa89474a0" prev="0xa8947380" upper="0xa8910d20" lower="(nil)">步骤3:如果从某个点开始的所有一步操作都只能进入必胜点（N点），则将该点标记为必败点（P点）；<Finish/></txt><txt ptr="0xa89474a0" next="0xa8947530" prev="0xa8947410" upper="0xa8910d20" lower="(nil)">步骤4: 如果在步骤3未能找到新的必败（P点），则算法终止；否则，返回到步骤2。<Finish/></txt><txt ptr="0xa8947530" next="0xa89475c0" prev="0xa89474a0" upper="0xa8910d20" lower="(nil)"><Finish/></txt><txt ptr="0xa89475c0" next="0xa8947650" prev="0xa8947530" upper="0xa8910d20" lower="(nil)">第一类取石子（巴什博弈）<Finish/></txt><txt ptr="0xa8947650" next="0xa89476e0" prev="0xa89475c0" upper="0xa8910d20" lower="(nil)"><Finish/></txt><txt ptr="0xa89476e0" next="0xa8947770" prev="0xa8947650" upper="0xa8910d20" lower="(nil)">只有一堆 n 个石子.<Finish/></txt><txt ptr="0xa8947770" next="0xa8947800" prev="0xa89476e0" upper="0xa8910d20" lower="(nil)">两个人轮流从这堆石子中取石子.<Finish/></txt><txt ptr="0xa8947800" next="0xa8947890" prev="0xa8947770" upper="0xa8910d20" lower="(nil)">规定每次至少取一个，最多取m个<Finish/></txt><txt ptr="0xa8947890" next="0xa8947920" prev="0xa8947800" upper="0xa8910d20" lower="(nil)">最后取光者得胜。<Finish/></txt><txt ptr="0xa8947920" next="0xa89479b0" prev="0xa8947890" upper="0xa8910d20" lower="(nil)"><Finish/></txt><txt ptr="0xa89479b0" next="0xa8947d10" prev="0xa8947920" upper="0xa8910d20" lower="(nil)">得出规律：n%(m+1)=0时为P点，其他为N点<Finish/></txt><txt ptr="0xa8947d10" next="0xa8947da0" prev="0xa89479b0" upper="0xa8910d20" lower="(nil)"><Finish/></txt><txt ptr="0xa8947da0" next="0xa8947e30" prev="0xa8947d10" upper="0xa8910d20" lower="(nil)">变形：减法游戏<Finish/></txt><txt ptr="0xa8947e30" next="0xa8947ec0" prev="0xa8947da0" upper="0xa8910d20" lower="(nil)"><Finish/></txt><txt ptr="0xa8947ec0" next="0xa8947f50" prev="0xa8947e30" upper="0xa8910d20" lower="(nil)">只有一堆 n 个石子<Finish/></txt><txt ptr="0xa8947f50" next="0xa8948024" prev="0xa8947ec0" upper="0xa8910d20" lower="(nil)">两个人轮流从这堆石子中取物<Finish/></txt><txt ptr="0xa8948024" next="0xa89480b4" prev="0xa8947f50" upper="0xa8910d20" lower="(nil)">规定每次取的个数只能为一集合中的元素<Finish/></txt><txt ptr="0xa89480b4" next="0xa8948144" prev="0xa8948024" upper="0xa8910d20" lower="(nil)">最后取光者得胜。<Finish/></txt><txt ptr="0xa8948144" next="0xa89481d4" prev="0xa89480b4" upper="0xa8910d20" lower="(nil)"><Finish/></txt><txt ptr="0xa89481d4" next="(nil)" prev="0xa8948144" upper="0xa8910d20" lower="(nil)">未变形的实际上是一个1到n的集合。<Finish/></txt></body></column><column ptr="0xa891759c" next="0xa8917600" prev="0xa8917538" upper="0xa891d090" lower="0xa8910d80"><body ptr="0xa8910d80" next="(nil)" prev="(nil)" upper="0xa891759c" lower="0xa8948264"><txt ptr="0xa8948264" next="0xa89482f4" prev="(nil)" upper="0xa8910d80" lower="(nil)"><Finish/></txt><txt ptr="0xa89482f4" next="0xa8948384" prev="0xa8948264" upper="0xa8910d80" lower="(nil)">例如：集合是2的幂次（即：1，2，4，8，16…）<Finish/></txt><txt ptr="0xa8948384" next="0xa8948414" prev="0xa89482f4" upper="0xa8910d80" lower="(nil)">得出规律：n%3=0为P点<Finish/></txt><txt ptr="0xa8948414" next="0xa89484a4" prev="0xa8948384" upper="0xa8910d80" lower="(nil)"><Finish/></txt><txt ptr="0xa89484a4" next="0xa8948534" prev="0xa8948414" upper="0xa8910d80" lower="(nil)"><Finish/></txt><txt ptr="0xa8948534" next="0xa89485c4" prev="0xa89484a4" upper="0xa8910d80" lower="(nil)">第二类取石子（威佐夫博弈）<Finish/></txt><txt ptr="0xa89485c4" next="0xa8948654" prev="0xa8948534" upper="0xa8910d80" lower="(nil)"><Finish/></txt><txt ptr="0xa8948654" next="0xa89486e4" prev="0xa89485c4" upper="0xa8910d80" lower="(nil)">有两堆各若干个石子<Finish/></txt><txt ptr="0xa89486e4" next="0xa8948774" prev="0xa8948654" upper="0xa8910d80" lower="(nil)">两个人轮流从某一堆或同时从两堆中取同样多的石子<Finish/></txt><txt ptr="0xa8948774" next="0xa8948804" prev="0xa89486e4" upper="0xa8910d80" lower="(nil)">规定每次至少取一个，多者不限<Finish/></txt><txt ptr="0xa8948804" next="0xa8948894" prev="0xa8948774" upper="0xa8910d80" lower="(nil)">最后取光者得胜<Finish/></txt><txt ptr="0xa8948894" next="0xa8948924" prev="0xa8948804" upper="0xa8910d80" lower="(nil)"><Finish/></txt><txt ptr="0xa8948924" next="0xa89489b4" prev="0xa8948894" upper="0xa8910d80" lower="(nil)">策略：寻找奇异局势<Finish/></txt><txt ptr="0xa89489b4" next="0xa8948a44" prev="0xa8948924" upper="0xa8910d80" lower="(nil)">我们用（ak，bk）（ak≤ bk ,k=0，1，2，...,n)表示两堆石子的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇<Finish/></txt><txt ptr="0xa8948a44" next="0xa8948ad4" prev="0xa89489b4" upper="0xa8910d80" lower="(nil)"><Finish/></txt><txt ptr="0xa8948ad4" next="0xa8948b64" prev="0xa8948a44" upper="0xa8910d80" lower="(nil)">异局势。<Finish/></txt><txt ptr="0xa8948b64" next="0xa8948bf4" prev="0xa8948ad4" upper="0xa8910d80" lower="(nil)">前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。<Finish/></txt><txt ptr="0xa8948bf4" next="0xa8948c84" prev="0xa8948b64" upper="0xa8910d80" lower="(nil)">奇异局势性质<Finish/></txt><txt ptr="0xa8948c84" next="0xa8948d14" prev="0xa8948bf4" upper="0xa8910d80" lower="(nil)">1、任何自然数都包含在一个且仅有一个奇异局势中<Finish/></txt><txt ptr="0xa8948d14" next="0xa8948da4" prev="0xa8948c84" upper="0xa8910d80" lower="(nil)">由于ak是未在前面出现过的最小自然数，所以有ak&gt;ak-1 ，而 bk=ak+ k &gt;ak-1+ k-1 =bk-1 &gt;ak-1 。所以性质1。成立。<Finish/></txt><txt ptr="0xa8948da4" next="(nil)" prev="0xa8948d14" upper="0xa8910d80" lower="(nil)">2、任意操作都可将奇异局势变为非奇异局势<Finish/></txt></body></column><column ptr="0xa8917600" next="(nil)" prev="0xa891759c" upper="0xa891d090" lower="0xa8910de0"><body ptr="0xa8910de0" next="(nil)" prev="(nil)" upper="0xa8917600" lower="0xa8948e34"><txt ptr="0xa8948e34" next="0xa8948ec4" prev="(nil)" upper="0xa8910de0" lower="(nil)">事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。<Finish/></txt><txt ptr="0xa8948ec4" next="0xa8948f54" prev="0xa8948e34" upper="0xa8910de0" lower="(nil)">3、采用适当的方法，可以将非奇异局势变为奇异局势<Finish/></txt><txt ptr="0xa8948f54" next="0xa89492f8" prev="0xa8948ec4" upper="0xa8910de0" lower="(nil)">奇异局势公式<Finish/></txt><txt ptr="0xa89492f8" next="0xa8949388" prev="0xa8948f54" upper="0xa8910de0" lower="(nil)">那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？<Finish/></txt><txt ptr="0xa8949388" next="0xa8949418" prev="0xa89492f8" upper="0xa8910de0" lower="(nil)">我们有如下公式：ak=[k（1+√5）/2]，bk=ak+k （k=0，1，2，...,n）<Finish/></txt><txt ptr="0xa8949418" next="0xa89494a8" prev="0xa8949388" upper="0xa8910de0" lower="(nil)">注:（1+√5）/2 ≈1.618，k、ak、bk满足黄金分割比<Finish/></txt><txt ptr="0xa89494a8" next="0xa8949538" prev="0xa8949418" upper="0xa8910de0" lower="(nil)">所有奇异局势可组成若干Fibonacci数列<Finish/></txt><txt ptr="0xa8949538" next="0xa89495c8" prev="0xa89494a8" upper="0xa8910de0" lower="(nil)">既a= =(__int64)((1.0+sqrt(5.0))/2*(b-a)时败<Finish/></txt><txt ptr="0xa89495c8" next="0xa8949658" prev="0xa8949538" upper="0xa8910de0" lower="(nil)">其中(1.0+sqrt(5.0))/2=1.618033989<Finish/></txt><txt ptr="0xa8949658" next="0xa89496e8" prev="0xa89495c8" upper="0xa8910de0" lower="(nil)">若要输出赢的第一步策略，可以暴力搜索<Finish/></txt><txt ptr="0xa89496e8" next="0xa8949778" prev="0xa8949658" upper="0xa8910de0" lower="(nil)">（判断同时减一个数，a减一个数,b减一个数）。<Finish/></txt><txt ptr="0xa8949778" next="0xa8949808" prev="0xa89496e8" upper="0xa8910de0" lower="(nil)"><Finish/></txt><txt ptr="0xa8949808" next="0xa8949898" prev="0xa8949778" upper="0xa8910de0" lower="(nil)">例如：Euclid's Game<Finish/></txt><txt ptr="0xa8949898" next="0xa8949928" prev="0xa8949808" upper="0xa8910de0" lower="(nil)">1、给出两个自然数a,b<Finish/></txt><txt ptr="0xa8949928" next="0xa89499b8" prev="0xa8949898" upper="0xa8910de0" lower="(nil)">2、由两人轮流进行，可以将其中较大数减去较小数的任意倍，差必须是自然数<Finish/></txt><txt ptr="0xa89499b8" next="0xa8949a48" prev="0xa8949928" upper="0xa8910de0" lower="(nil)">3、最终将一数减为0者取胜<Finish/></txt><txt ptr="0xa8949a48" next="0xa8949ad8" prev="0xa89499b8" upper="0xa8910de0" lower="(nil)"><Finish/></txt><txt ptr="0xa8949ad8" next="0xa8949b68" prev="0xa8949a48" upper="0xa8910de0" lower="(nil)">1.可以打表找规律。<Finish/></txt><txt ptr="0xa8949b68" next="0xa8949bf8" prev="0xa8949ad8" upper="0xa8910de0" lower="(nil)">b/a&gt;=2 || b%a==0时胜。<Finish/></txt><txt ptr="0xa8949bf8" next="0xa8949c88" prev="0xa8949b68" upper="0xa8910de0" lower="(nil)">否则b%=a;然后循环，判断奇偶性。<Finish/></txt><txt ptr="0xa8949c88" next="(nil)" prev="0xa8949bf8" upper="0xa8910de0" lower="(nil)">2.打表找公式<Finish/></txt></body></column></section></body><footer ptr="0xa8998d80" next="(nil)" prev="0xa998e84c" upper="0xa99960ec" lower="0xa9999bd8"><txt ptr="0xa9999bd8" next="0xa9999d88" prev="(nil)" upper="0xa8998d80" lower="(nil)"><anchored><fly ptr="0xa4ff668" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa9999c68"><txt ptr="0xa9999c68" next="0xa9999cf8" prev="(nil)" upper="0xa4ff668" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa9999cf8" next="(nil)" prev="0xa9999c68" upper="0xa4ff668" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="3"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="9"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa9999d88" next="(nil)" prev="0xa9999bd8" upper="0xa8998d80" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996160" next="0xa99961d4" prev="0xa99960ec" upper="0xb0726b0" lower="0xa8996de0"><header ptr="0xa8996de0" next="0xa998e9cc" prev="(nil)" upper="0xa9996160" lower="0xa997b130"><txt ptr="0xa997b130" next="(nil)" prev="(nil)" upper="0xa8996de0" lower="(nil)"><Finish/></txt></header><body ptr="0xa998e9cc" next="0xa8998de0" prev="0xa8996de0" upper="0xa9996160" lower="0xa99bcb00"><section ptr="0xa99bcb00" next="(nil)" prev="(nil)" upper="0xa998e9cc" lower="0xa6c03678" follow="0xa891d390" precede="0xa891d090"><column ptr="0xa6c03678" next="0xa6c036dc" prev="(nil)" upper="0xa99bcb00" lower="0xa6c04550"><body ptr="0xa6c04550" next="(nil)" prev="(nil)" upper="0xa6c03678" lower="0xa8949d18"><txt ptr="0xa8949d18" next="0xa8949da8" prev="(nil)" upper="0xa6c04550" lower="(nil)">a!=b &amp;&amp; a!=1 &amp;&amp; a&gt;=(__int64)((1.0+sqrt(5.0))/2*(b-a))时胜<Finish/></txt><txt ptr="0xa8949da8" next="0xa8949e38" prev="0xa8949d18" upper="0xa6c04550" lower="(nil)"><Finish/></txt><txt ptr="0xa8949e38" next="0xa8949ec8" prev="0xa8949da8" upper="0xa6c04550" lower="(nil)">第三类取石子（尼姆博弈）<Finish/></txt><txt ptr="0xa8949ec8" next="0xa8949f58" prev="0xa8949e38" upper="0xa6c04550" lower="(nil)">取火柴问题<Finish/></txt><txt ptr="0xa8949f58" next="0xa894a000" prev="0xa8949ec8" upper="0xa6c04550" lower="(nil)"><Finish/></txt><txt ptr="0xa894a000" next="0xa894a090" prev="0xa8949f58" upper="0xa6c04550" lower="(nil)"><Finish/></txt><txt ptr="0xa894a090" next="0xa894a120" prev="0xa894a000" upper="0xa6c04550" lower="(nil)"><Finish/></txt><txt ptr="0xa894a120" next="0xa894a1b0" prev="0xa894a090" upper="0xa6c04550" lower="(nil)">有三堆各若干个石子<Finish/></txt><txt ptr="0xa894a1b0" next="0xa894a240" prev="0xa894a120" upper="0xa6c04550" lower="(nil)">两个人轮流从某一堆取任意多的石子<Finish/></txt><txt ptr="0xa894a240" next="0xa894a2d0" prev="0xa894a1b0" upper="0xa6c04550" lower="(nil)">规定每次至少取一个，多者不限<Finish/></txt><txt ptr="0xa894a2d0" next="0xa894a360" prev="0xa894a240" upper="0xa6c04550" lower="(nil)">最后取光者得胜<Finish/></txt><txt ptr="0xa894a360" next="0xa894a3f0" prev="0xa894a2d0" upper="0xa6c04550" lower="(nil)"><Finish/></txt><txt ptr="0xa894a3f0" next="0xa894a480" prev="0xa894a360" upper="0xa6c04550" lower="(nil)">策略<Finish/></txt><txt ptr="0xa894a480" next="0xa894a510" prev="0xa894a3f0" upper="0xa6c04550" lower="(nil)">我们用（a，b，c）表示某种局势。<Finish/></txt><txt ptr="0xa894a510" next="0xa894a870" prev="0xa894a480" upper="0xa6c04550" lower="(nil)">首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。<Finish/></txt><txt ptr="0xa894a870" next="0xa894a900" prev="0xa894a510" upper="0xa6c04550" lower="(nil)">第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。<Finish/></txt><txt ptr="0xa894a900" next="0xa894a990" prev="0xa894a870" upper="0xa6c04550" lower="(nil)">仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情形。<Finish/></txt><txt ptr="0xa894a990" next="0xa894aa20" prev="0xa894a900" upper="0xa6c04550" lower="(nil)"><Finish/></txt><txt ptr="0xa894aa20" next="0xa894aab0" prev="0xa894a990" upper="0xa6c04550" lower="(nil)">方法：异或“^”<Finish/></txt><txt ptr="0xa894aab0" next="0xa894ab40" prev="0xa894aa20" upper="0xa6c04550" lower="(nil)">任何奇异局势（a，b，c）都有a^b^c=0。<Finish/></txt><txt ptr="0xa894ab40" next="0xa894abd0" prev="0xa894aab0" upper="0xa6c04550" lower="(nil)">延伸：任何奇异局势(a1, a2,… an)都满足a1^a2^…^an=0<Finish/></txt><txt ptr="0xa894abd0" next="(nil)" prev="0xa894ab40" upper="0xa6c04550" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa6c036dc" next="0xa6c03740" prev="0xa6c03678" upper="0xa99bcb00" lower="0xa6c045b0"><body ptr="0xa6c045b0" next="(nil)" prev="(nil)" upper="0xa6c036dc" lower="0xa894ac60"><txt ptr="0xa894ac60" next="0xa894acf0" prev="(nil)" upper="0xa6c045b0" lower="(nil)">证明<Finish/></txt><txt ptr="0xa894acf0" next="0xa894ad80" prev="0xa894ac60" upper="0xa6c045b0" lower="(nil)">欲证明此算法，只需证明3个命题：<Finish/></txt><txt ptr="0xa894ad80" next="0xa894ae10" prev="0xa894acf0" upper="0xa6c045b0" lower="(nil)">1、这个判断将所有终结点为P点<Finish/></txt><txt ptr="0xa894ae10" next="0xa894aea0" prev="0xa894ad80" upper="0xa6c045b0" lower="(nil)">2、这个判断的N点一定可以变换为P点<Finish/></txt><txt ptr="0xa894aea0" next="0xa894af30" prev="0xa894ae10" upper="0xa6c045b0" lower="(nil)">3、这个判断的P点无法变换为另一P点<Finish/></txt><txt ptr="0xa894af30" next="0xa894c004" prev="0xa894aea0" upper="0xa6c045b0" lower="(nil)">通过二进制和异或的性质证<Finish/></txt><txt ptr="0xa894c004" next="0xa894c094" prev="0xa894af30" upper="0xa6c045b0" lower="(nil)"><Finish/></txt><txt ptr="0xa894c094" next="0xa894c124" prev="0xa894c004" upper="0xa6c045b0" lower="(nil)">(Bouton's Theorem)对于一个Nim游戏的局面(a1,a2,...,an)，它是P-position当且仅当a1^a2^...^an=0，其中^表示异或(xor)运算。<Finish/></txt><txt ptr="0xa894c124" next="0xa894c1b4" prev="0xa894c094" upper="0xa6c045b0" lower="(nil)">根据定义，证明一种判断position的性质的方法的正确性，只需证明三个命题： <Finish/></txt><txt ptr="0xa894c1b4" next="0xa894c244" prev="0xa894c124" upper="0xa6c045b0" lower="(nil)">这个判断将所有terminal position判为P-position；<Finish/></txt><txt ptr="0xa894c244" next="0xa894c2d4" prev="0xa894c1b4" upper="0xa6c045b0" lower="(nil)">根据这个判断被判为N-position的局面一定可以移动到某个P-position；<Finish/></txt><txt ptr="0xa894c2d4" next="0xa894c364" prev="0xa894c244" upper="0xa6c045b0" lower="(nil)">3、根据这个判断被判为P-position的局面无法移动到某个P-position。<Finish/></txt><txt ptr="0xa894c364" next="0xa894c3f4" prev="0xa894c2d4" upper="0xa6c045b0" lower="(nil)"><Finish/></txt><txt ptr="0xa894c3f4" next="0xa894c484" prev="0xa894c364" upper="0xa6c045b0" lower="(nil)">第一个命题显然，terminal position只有一个，就是全0，异或仍然是0。<Finish/></txt><txt ptr="0xa894c484" next="0xa894c514" prev="0xa894c3f4" upper="0xa6c045b0" lower="(nil)"><Finish/></txt><txt ptr="0xa894c514" next="(nil)" prev="0xa894c484" upper="0xa6c045b0" lower="(nil)" follow="0xa88eec64">第二个命题，对于某个局面(a1,a2,...,an)，若a1^a2^...^an!=0，一定存在某个合法的移动，将ai改变成ai'后满足 a1^a2^...^ai'^...^an=0。不妨设a1^a2^...^an=k，则一定存在某个ai，它的二进制表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai^k&lt;ai一定成立。则我们可以将ai改变成ai'=ai^k，此时 a1^a2^...^ai'^...^an=a1^a2^...^an^k=0。<Finish/></txt></body></column><column ptr="0xa6c03740" next="(nil)" prev="0xa6c036dc" upper="0xa99bcb00" lower="0xa6c04610"><body ptr="0xa6c04610" next="(nil)" prev="(nil)" upper="0xa6c03740" lower="0xa88eec64"><txt ptr="0xa88eec64" next="0xa894c5a4" prev="(nil)" upper="0xa6c04610" lower="(nil)" precede="0xa894c514">第二个命题，对于某个局面(a1,a2,...,an)，若a1^a2^...^an!=0，一定存在某个合法的移动，将ai改变成ai'后满足 a1^a2^...^ai'^...^an=0。不妨设a1^a2^...^an=k，则一定存在某个ai，它的二进制表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai^k&lt;ai一定成立。则我们可以将ai改变成ai'=ai^k，此时 a1^a2^...^ai'^...^an=a1^a2^...^an^k=0。<Finish/></txt><txt ptr="0xa894c5a4" next="0xa894c634" prev="0xa88eec64" upper="0xa6c04610" lower="(nil)"><Finish/></txt><txt ptr="0xa894c634" next="0xa894c6c4" prev="0xa894c5a4" upper="0xa6c04610" lower="(nil)">第三个命题，对于某个局面(a1,a2,...,an)，若a1^a2^...^an=0，一定不存在某个合法的移动，将ai改变成ai'后满足 a1^a2^...^ai'^...^an=0。因为异或运算满足消去率，由a1^a2^...^an=a1^a2^...^ai'^...^an可以得到ai=ai'。所以将ai改变成ai'不是一个合法的移动。证毕。<Finish/></txt><txt ptr="0xa894c6c4" next="0xa894c754" prev="0xa894c634" upper="0xa6c04610" lower="(nil)"><Finish/></txt><txt ptr="0xa894c754" next="0xa894c7e4" prev="0xa894c6c4" upper="0xa6c04610" lower="(nil)">Sprague-Grundy 函数<Finish/></txt><txt ptr="0xa894c7e4" next="0xa894c874" prev="0xa894c754" upper="0xa6c04610" lower="(nil)">将组合游戏抽象为有向图<Finish/></txt><txt ptr="0xa894c874" next="0xa894c904" prev="0xa894c7e4" upper="0xa6c04610" lower="(nil)">每个位置为有向图的一个节点<Finish/></txt><txt ptr="0xa894c904" next="0xa894c994" prev="0xa894c874" upper="0xa6c04610" lower="(nil)">每种可行操作为有向图的一条路径<Finish/></txt><txt ptr="0xa894c994" next="0xa894ca24" prev="0xa894c904" upper="0xa6c04610" lower="(nil)"><Finish/></txt><txt ptr="0xa894ca24" next="0xa894cab4" prev="0xa894c994" upper="0xa6c04610" lower="(nil)">我们就在有向图的顶点上定义SG函数<Finish/></txt><txt ptr="0xa894cab4" next="0xa894ce14" prev="0xa894ca24" upper="0xa6c04610" lower="(nil)">首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。<Finish/></txt><txt ptr="0xa894ce14" next="0xa894cea4" prev="0xa894cab4" upper="0xa6c04610" lower="(nil)">例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。<Finish/></txt><txt ptr="0xa894cea4" next="0xa894cf34" prev="0xa894ce14" upper="0xa6c04610" lower="(nil)">对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。<Finish/></txt><txt ptr="0xa894cf34" next="0xa892e008" prev="0xa894cea4" upper="0xa6c04610" lower="(nil)"><Finish/></txt><txt ptr="0xa892e008" next="0xa892e098" prev="0xa894cf34" upper="0xa6c04610" lower="(nil)">Sprague-Grundy函数性质<Finish/></txt><txt ptr="0xa892e098" next="0xa892e128" prev="0xa892e008" upper="0xa6c04610" lower="(nil)">所有的终结点SG值为0（因为它的后继集合是空集）<Finish/></txt><txt ptr="0xa892e128" next="(nil)" prev="0xa892e098" upper="0xa6c04610" lower="(nil)">SG为0的顶点，它的所有后继y都满足SG不为0<Finish/></txt></body></column></section></body><footer ptr="0xa8998de0" next="(nil)" prev="0xa998e9cc" upper="0xa9996160" lower="0xa997b1c0"><txt ptr="0xa997b1c0" next="0xa997b370" prev="(nil)" upper="0xa8998de0" lower="(nil)"><anchored><fly ptr="0xa50e2b0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa997b250"><txt ptr="0xa997b250" next="0xa997b2e0" prev="(nil)" upper="0xa50e2b0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa997b2e0" next="(nil)" prev="0xa997b250" upper="0xa50e2b0" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="4"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="0"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa997b370" next="(nil)" prev="0xa997b1c0" upper="0xa8998de0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa99961d4" next="0xa9996248" prev="0xa9996160" upper="0xb0726b0" lower="0xa8996e40"><header ptr="0xa8996e40" next="0xa998eb4c" prev="(nil)" upper="0xa99961d4" lower="0xa997c6d4"><txt ptr="0xa997c6d4" next="(nil)" prev="(nil)" upper="0xa8996e40" lower="(nil)"><Finish/></txt></header><body ptr="0xa998eb4c" next="0xa8998e40" prev="0xa8996e40" upper="0xa99961d4" lower="0xa891d390"><section ptr="0xa891d390" next="(nil)" prev="(nil)" upper="0xa998eb4c" lower="0xa8917c40" follow="0xa99bc780" precede="0xa99bcb00"><column ptr="0xa8917c40" next="0xa8917ca4" prev="(nil)" upper="0xa891d390" lower="0xa8902664"><body ptr="0xa8902664" next="(nil)" prev="(nil)" upper="0xa8917c40" lower="0xa892e1b8"><txt ptr="0xa892e1b8" next="0xa892e248" prev="(nil)" upper="0xa8902664" lower="(nil)">对于一个SG不为0的顶点，必定存在一个后继满足SG为0<Finish/></txt><txt ptr="0xa892e248" next="0xa892e2d8" prev="0xa892e1b8" upper="0xa8902664" lower="(nil)">满足组合游戏性质 所有SG为0定点对应P点，SG大于0顶点对应N点<Finish/></txt><txt ptr="0xa892e2d8" next="0xa892e368" prev="0xa892e248" upper="0xa8902664" lower="(nil)"><Finish/></txt><txt ptr="0xa892e368" next="0xa892e3f8" prev="0xa892e2d8" upper="0xa8902664" lower="(nil)">Sprague-Grundy函数意义<Finish/></txt><txt ptr="0xa892e3f8" next="0xa892e488" prev="0xa892e368" upper="0xa8902664" lower="(nil)">每个SG值对应Nim游戏每堆石子的初始数量<Finish/></txt><txt ptr="0xa892e488" next="0xa892e518" prev="0xa892e3f8" upper="0xa8902664" lower="(nil)">将所有SG值异或，类同于将Nim游戏的所有初态异或<Finish/></txt><txt ptr="0xa892e518" next="0xa892e5a8" prev="0xa892e488" upper="0xa8902664" lower="(nil)"><Finish/></txt><txt ptr="0xa892e5a8" next="0xa892e638" prev="0xa892e518" upper="0xa8902664" lower="(nil)">当g(x)=k时，表明对于任意一个0&lt;=i&lt;k，都存在x的一个后继y满足g(y)=i。也就是说，当某枚棋子的SG值是k时，我们可以把它变成0、变成1、……、变成k-1，但绝对不能保持k不变。不知道你能不能根据这个联想到Nim游戏，Nim 游戏的规则就是：每次选择一堆数量为k的石子，可以把它变成0、变成1、……、变成k-1，但绝对不能保持k不变。这表明，如果将n枚棋子所在的顶点的 SG值看作n堆相应数量的石子，那么这个Nim游戏的每个必胜策略都对应于原来这n枚棋子的必胜策略！<Finish/></txt><txt ptr="0xa892e638" next="0xa892e6c8" prev="0xa892e5a8" upper="0xa8902664" lower="(nil)"><Finish/></txt><txt ptr="0xa892e6c8" next="0xa892e758" prev="0xa892e638" upper="0xa8902664" lower="(nil)">SG定理<Finish/></txt><txt ptr="0xa892e758" next="(nil)" prev="0xa892e6c8" upper="0xa8902664" lower="(nil)" follow="0xa893425c">所以我们可以定义有向图游戏的和(Sum of Graph Games)：设G1、G2、……、Gn是n个有向图游戏，定义游戏G是G1、G2、……、Gn的和(Sum)，游戏G的移动规则是：任选一个子游戏Gi 并移动上面的棋子。Sprague-Grundy Theorem就是：g(G)=g(G1)^g(G2)^...^g(Gn)。也就是说，游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。<Finish/></txt></body></column><column ptr="0xa8917ca4" next="0xa8917d08" prev="0xa8917c40" upper="0xa891d390" lower="0xa89026c4"><body ptr="0xa89026c4" next="(nil)" prev="(nil)" upper="0xa8917ca4" lower="0xa893425c"><txt ptr="0xa893425c" next="0xa892e7e8" prev="(nil)" upper="0xa89026c4" lower="(nil)" precede="0xa892e758">所以我们可以定义有向图游戏的和(Sum of Graph Games)：设G1、G2、……、Gn是n个有向图游戏，定义游戏G是G1、G2、……、Gn的和(Sum)，游戏G的移动规则是：任选一个子游戏Gi 并移动上面的棋子。Sprague-Grundy Theorem就是：g(G)=g(G1)^g(G2)^...^g(Gn)。也就是说，游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。<Finish/></txt><txt ptr="0xa892e7e8" next="0xa892e878" prev="0xa893425c" upper="0xa89026c4" lower="(nil)"><Finish/></txt><txt ptr="0xa892e878" next="0xa892e908" prev="0xa892e7e8" upper="0xa89026c4" lower="(nil)">SG定理（Sprague-Grundy Theorem）：g(G)=g(G1)^g(G2)^…^g(Gn)。<Finish/></txt><txt ptr="0xa892e908" next="0xa892e998" prev="0xa892e878" upper="0xa89026c4" lower="(nil)">游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。<Finish/></txt><txt ptr="0xa892e998" next="0xa892ea28" prev="0xa892e908" upper="0xa89026c4" lower="(nil)"><Finish/></txt><txt ptr="0xa892ea28" next="0xa892eab8" prev="0xa892e998" upper="0xa89026c4" lower="(nil)"><Finish/></txt><txt ptr="0xa892eab8" next="0xa892eb48" prev="0xa892ea28" upper="0xa89026c4" lower="(nil)">例如：<Finish/></txt><txt ptr="0xa892eb48" next="0xa892ebd8" prev="0xa892eab8" upper="0xa89026c4" lower="(nil)">取(m堆)石子游戏<Finish/></txt><txt ptr="0xa892ebd8" next="0xa892ec68" prev="0xa892eb48" upper="0xa89026c4" lower="(nil)">1、m堆石子,两人轮流取<Finish/></txt><txt ptr="0xa892ec68" next="0xa892ecf8" prev="0xa892ebd8" upper="0xa89026c4" lower="(nil)">2、只能在1堆中取任意个.取完者胜.<Finish/></txt><txt ptr="0xa892ecf8" next="0xa892ed88" prev="0xa892ec68" upper="0xa89026c4" lower="(nil)">先取者负输出No.先取者胜输出Yes.然后输出先取者第1次取子的所有方法. <Finish/></txt><txt ptr="0xa892ed88" next="0xa892ee18" prev="0xa892ecf8" upper="0xa89026c4" lower="(nil)">分析：用异或进行判断，由异或基本性质（a^a=0）求出每个点的P点，依次比较即可<Finish/></txt><txt ptr="0xa892ee18" next="0xa892eea8" prev="0xa892ed88" upper="0xa89026c4" lower="(nil)"><Finish/></txt><txt ptr="0xa892eea8" next="0xa892ef38" prev="0xa892ee18" upper="0xa89026c4" lower="(nil)"><Finish/></txt><txt ptr="0xa892ef38" next="0xa892f00c" prev="0xa892eea8" upper="0xa89026c4" lower="(nil)">求SG值的问题求SG算法<Finish/></txt><txt ptr="0xa892f00c" next="0xa892f09c" prev="0xa892ef38" upper="0xa89026c4" lower="(nil)">1.直接DFS<Finish/></txt><txt ptr="0xa892f09c" next="0xa892f3fc" prev="0xa892f00c" upper="0xa89026c4" lower="(nil)"> 2.外加数组法（效率更高）<Finish/></txt><txt ptr="0xa892f3fc" next="0xa892f48c" prev="0xa892f09c" upper="0xa89026c4" lower="(nil)">直接DFS算法<Finish/></txt><txt ptr="0xa892f48c" next="0xa892f51c" prev="0xa892f3fc" upper="0xa89026c4" lower="(nil)">const int N=10001;<Finish/></txt><txt ptr="0xa892f51c" next="0xa892f5ac" prev="0xa892f48c" upper="0xa89026c4" lower="(nil)">int k,a[101];          //k为节点数,a数组为减数集合<Finish/></txt><txt ptr="0xa892f5ac" next="(nil)" prev="0xa892f51c" upper="0xa89026c4" lower="(nil)" follow="0xa88eecf4">int f[N]; //f数组用来存储所有节点的sg值,初值为-1*int mex(int p) {                //mex为求sg的函数* int i,t;*  bool g[101]={0};        //定义布尔数组，初值为0*    for(i=0;i&lt;k;i++) {*        t=p-a[i];             //t为p当前遍历的后继*        if(t&lt;0)  break;             //后继最小是0*        if(f[t]==-1)f[t]=mex(t); *        g[f[t]]=1;       //布尔数组中赋这个SG值为*    }*    for(i=0;;i++){*        if(!g[i]) return i;*     }*} <Finish/></txt></body></column><column ptr="0xa8917d08" next="(nil)" prev="0xa8917ca4" upper="0xa891d390" lower="0xa8902724"><body ptr="0xa8902724" next="(nil)" prev="(nil)" upper="0xa8917d08" lower="0xa88eecf4"><txt ptr="0xa88eecf4" next="0xa892f63c" prev="(nil)" upper="0xa8902724" lower="(nil)" precede="0xa892f5ac">int f[N]; //f数组用来存储所有节点的sg值,初值为-1*int mex(int p) {                //mex为求sg的函数* int i,t;*  bool g[101]={0};        //定义布尔数组，初值为0*    for(i=0;i&lt;k;i++) {*        t=p-a[i];             //t为p当前遍历的后继*        if(t&lt;0)  break;             //后继最小是0*        if(f[t]==-1)f[t]=mex(t); *        g[f[t]]=1;       //布尔数组中赋这个SG值为*    }*    for(i=0;;i++){*        if(!g[i]) return i;*     }*} <Finish/></txt><txt ptr="0xa892f63c" next="0xa892f6cc" prev="0xa88eecf4" upper="0xa8902724" lower="(nil)"><Finish/></txt><txt ptr="0xa892f6cc" next="0xa892f75c" prev="0xa892f63c" upper="0xa8902724" lower="(nil)"><Finish/></txt><txt ptr="0xa892f75c" next="0xa892f7ec" prev="0xa892f6cc" upper="0xa8902724" lower="(nil)">外接数组法<Finish/></txt><txt ptr="0xa892f7ec" next="0xa892f87c" prev="0xa892f75c" upper="0xa8902724" lower="(nil)">int k,a[101];          //k为节点数，a为减数集合<Finish/></txt><txt ptr="0xa892f87c" next="0xa892f90c" prev="0xa892f7ec" upper="0xa8902724" lower="(nil)">int f[N],num[N]; //f存储sg值,num标记sg值是否存在<Finish/></txt><txt ptr="0xa892f90c" next="0xa892f99c" prev="0xa892f87c" upper="0xa8902724" lower="(nil)"> sg[0]=0;             <Finish/></txt><txt ptr="0xa892f99c" next="0xa892fa2c" prev="0xa892f90c" upper="0xa8902724" lower="(nil)"> for(i=1;i&lt;k;i++) {  <Finish/></txt><txt ptr="0xa892fa2c" next="0xa892fabc" prev="0xa892f99c" upper="0xa8902724" lower="(nil)"> **for(j=0;a[j]&lt;=i;j++)num[sg[i-a[j]]]=i;    <Finish/></txt><txt ptr="0xa892fabc" next="0xa892fb4c" prev="0xa892fa2c" upper="0xa8902724" lower="(nil)">  **for(j=0;j&lt;=i;j++)  <Finish/></txt><txt ptr="0xa892fb4c" next="0xa892fbdc" prev="0xa892fabc" upper="0xa8902724" lower="(nil)"> **if(num[j]!=i){sg[i]=j;break;} <Finish/></txt><txt ptr="0xa892fbdc" next="0xa892fc6c" prev="0xa892fb4c" upper="0xa8902724" lower="(nil)">  }<Finish/></txt><txt ptr="0xa892fc6c" next="0xa892fcfc" prev="0xa892fbdc" upper="0xa8902724" lower="(nil)"><Finish/></txt><txt ptr="0xa892fcfc" next="0xa892fd8c" prev="0xa892fc6c" upper="0xa8902724" lower="(nil)">图论<Finish/></txt><txt ptr="0xa892fd8c" next="0xa892fe1c" prev="0xa892fcfc" upper="0xa8902724" lower="(nil)">图的一维数组邻接表表示法<Finish/></txt><txt ptr="0xa892fe1c" next="0xa892feac" prev="0xa892fd8c" upper="0xa8902724" lower="(nil)">const int N=10000;<Finish/></txt><txt ptr="0xa892feac" next="(nil)" prev="0xa892fe1c" upper="0xa8902724" lower="(nil)">const int M=100; <Finish/></txt></body></column></section></body><footer ptr="0xa8998e40" next="(nil)" prev="0xa998eb4c" upper="0xa99961d4" lower="0xa997c764"><txt ptr="0xa997c764" next="0xa997c914" prev="(nil)" upper="0xa8998e40" lower="(nil)"><anchored><fly ptr="0xb83e948" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa997c7f4"><txt ptr="0xa997c7f4" next="0xa997c884" prev="(nil)" upper="0xb83e948" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa997c884" next="(nil)" prev="0xa997c7f4" upper="0xb83e948" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="4"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="1"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa997c914" next="(nil)" prev="0xa997c764" upper="0xa8998e40" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996248" next="0xa99962bc" prev="0xa99961d4" upper="0xb0726b0" lower="0xa8996ea0"><header ptr="0xa8996ea0" next="0xa998eccc" prev="(nil)" upper="0xa9996248" lower="0xa997fc78"><txt ptr="0xa997fc78" next="(nil)" prev="(nil)" upper="0xa8996ea0" lower="(nil)"><Finish/></txt></header><body ptr="0xa998eccc" next="0xa8998ea0" prev="0xa8996ea0" upper="0xa9996248" lower="0xa99bc780"><section ptr="0xa99bc780" next="(nil)" prev="(nil)" upper="0xa998eccc" lower="0xa99af1f8" follow="0xa99bc700" precede="0xa891d390"><column ptr="0xa99af1f8" next="0xa99af194" prev="(nil)" upper="0xa99bc780" lower="0xa99c82a4"><body ptr="0xa99c82a4" next="(nil)" prev="(nil)" upper="0xa99af1f8" lower="0xa892ff3c"><txt ptr="0xa892ff3c" next="0xa8931010" prev="(nil)" upper="0xa99c82a4" lower="(nil)">int fir[N],toV[M],len[M],next[M],cnt; <Finish/></txt><txt ptr="0xa8931010" next="0xa89310a0" prev="0xa892ff3c" upper="0xa99c82a4" lower="(nil)">void addedge(int u, int v, int  w) {<Finish/></txt><txt ptr="0xa89310a0" next="0xa8931130" prev="0xa8931010" upper="0xa99c82a4" lower="(nil)">toV[cnt] = v;len[cnt] = w;<Finish/></txt><txt ptr="0xa8931130" next="0xa89311c0" prev="0xa89310a0" upper="0xa99c82a4" lower="(nil)">next[cnt] = fir[u];fir[u] = cnt++;<Finish/></txt><txt ptr="0xa89311c0" next="0xa8931250" prev="0xa8931130" upper="0xa99c82a4" lower="(nil)">}<Finish/></txt><txt ptr="0xa8931250" next="0xa89312e0" prev="0xa89311c0" upper="0xa99c82a4" lower="(nil)">void init(int nv, int ne) {<Finish/></txt><txt ptr="0xa89312e0" next="0xa8931370" prev="0xa8931250" upper="0xa99c82a4" lower="(nil)">*memset(fir, -1, sizeof(fir));<Finish/></txt><txt ptr="0xa8931370" next="0xa8931400" prev="0xa89312e0" upper="0xa99c82a4" lower="(nil)">*cnt=0; <Finish/></txt><txt ptr="0xa8931400" next="0xa8931490" prev="0xa8931370" upper="0xa99c82a4" lower="(nil)">*int u,v,w; <Finish/></txt><txt ptr="0xa8931490" next="0xa8931520" prev="0xa8931400" upper="0xa99c82a4" lower="(nil)">*for (int i = 0; i &lt; ne; ++i) {<Finish/></txt><txt ptr="0xa8931520" next="0xa89315b0" prev="0xa8931490" upper="0xa99c82a4" lower="(nil)">**scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); <Finish/></txt><txt ptr="0xa89315b0" next="0xa8931640" prev="0xa8931520" upper="0xa99c82a4" lower="(nil)">**addedge(u, v, w); // 不加下面的为有向图<Finish/></txt><txt ptr="0xa8931640" next="0xa89319a0" prev="0xa89315b0" upper="0xa99c82a4" lower="(nil)">**addedge(v u, w); // 加下面额为无向图<Finish/></txt><txt ptr="0xa89319a0" next="0xa8931a30" prev="0xa8931640" upper="0xa99c82a4" lower="(nil)">*}<Finish/></txt><txt ptr="0xa8931a30" next="0xa8931ac0" prev="0xa89319a0" upper="0xa99c82a4" lower="(nil)">}<Finish/></txt><txt ptr="0xa8931ac0" next="0xa8931b50" prev="0xa8931a30" upper="0xa99c82a4" lower="(nil)">最短路<Finish/></txt><txt ptr="0xa8931b50" next="0xa8931be0" prev="0xa8931ac0" upper="0xa99c82a4" lower="(nil)">Dijkstra<Finish/></txt><txt ptr="0xa8931be0" next="0xa8931c70" prev="0xa8931b50" upper="0xa99c82a4" lower="(nil)">适用条件<Finish/></txt><txt ptr="0xa8931c70" next="0xa8931d00" prev="0xa8931be0" upper="0xa99c82a4" lower="(nil)">单源最短路径(从源点s到其它所有顶点v); <Finish/></txt><txt ptr="0xa8931d00" next="0xa8931d90" prev="0xa8931c70" upper="0xa99c82a4" lower="(nil)">不存在负边权<Finish/></txt><txt ptr="0xa8931d90" next="0xa8931e20" prev="0xa8931d00" upper="0xa99c82a4" lower="(nil)">原始算法<Finish/></txt><txt ptr="0xa8931e20" next="0xa8931eb0" prev="0xa8931d90" upper="0xa99c82a4" lower="(nil)">对于全体点集，划分为两个集合，一个为达成最短路的集合，一个反之<Finish/></txt><txt ptr="0xa8931eb0" next="0xa8931f40" prev="0xa8931e20" upper="0xa99c82a4" lower="(nil)">每次松弛操作为<Finish/></txt><txt ptr="0xa8931f40" next="(nil)" prev="0xa8931eb0" upper="0xa99c82a4" lower="(nil)" follow="0xa893440c">1.将当前离源点最近的点加入达成最短路的集合<Finish/></txt></body></column><column ptr="0xa99af194" next="0xa99af130" prev="0xa99af1f8" upper="0xa99bc780" lower="0xa99c8664"><body ptr="0xa99c8664" next="(nil)" prev="(nil)" upper="0xa99af194" lower="0xa893440c"><txt ptr="0xa893440c" next="0xa8932014" prev="(nil)" upper="0xa99c8664" lower="(nil)" precede="0xa8931f40">1.将当前离源点最近的点加入达成最短路的集合<Finish/></txt><txt ptr="0xa8932014" next="0xa89320a4" prev="0xa893440c" upper="0xa99c8664" lower="(nil)">2.根据新加入的点，维护未加入的点的最短距离<Finish/></txt><txt ptr="0xa89320a4" next="0xa8932134" prev="0xa8932014" upper="0xa99c8664" lower="(nil)">直至找到目标点加入<Finish/></txt><txt ptr="0xa8932134" next="0xa89321c4" prev="0xa89320a4" upper="0xa99c8664" lower="(nil)">考虑和最小生成树Prime的相似之处<Finish/></txt><txt ptr="0xa89321c4" next="0xa8932254" prev="0xa8932134" upper="0xa99c8664" lower="(nil)">复杂度 O(n^2)，不可以处理负权图<Finish/></txt><txt ptr="0xa8932254" next="0xa89322e4" prev="0xa89321c4" upper="0xa99c8664" lower="(nil)">优化方式<Finish/></txt><txt ptr="0xa89322e4" next="0xa8932374" prev="0xa8932254" upper="0xa99c8664" lower="(nil)">可以考虑在选择最近点的时候，选择用堆来优化<Finish/></txt><txt ptr="0xa8932374" next="0xa8932404" prev="0xa89322e4" upper="0xa99c8664" lower="(nil)">复杂度约为O(n*logn)<Finish/></txt><txt ptr="0xa8932404" next="0xa8932494" prev="0xa8932374" upper="0xa99c8664" lower="(nil)">O(n^2)算法<Finish/></txt><txt ptr="0xa8932494" next="0xa8932524" prev="0xa8932404" upper="0xa99c8664" lower="(nil)">const int N = 100;<Finish/></txt><txt ptr="0xa8932524" next="0xa89325b4" prev="0xa8932494" upper="0xa99c8664" lower="(nil)">const int INF = 0x3ffff;<Finish/></txt><txt ptr="0xa89325b4" next="0xa8932644" prev="0xa8932524" upper="0xa99c8664" lower="(nil)">int cost[N][N];//两点之间的代价<Finish/></txt><txt ptr="0xa8932644" next="0xa89326d4" prev="0xa89325b4" upper="0xa99c8664" lower="(nil)">int path[N];//当前节点的父亲<Finish/></txt><txt ptr="0xa89326d4" next="0xa8932764" prev="0xa8932644" upper="0xa99c8664" lower="(nil)">int lowcost[N];//当前节点到根的代价<Finish/></txt><txt ptr="0xa8932764" next="0xa89327f4" prev="0xa89326d4" upper="0xa99c8664" lower="(nil)"><Finish/></txt><txt ptr="0xa89327f4" next="0xa8932884" prev="0xa8932764" upper="0xa99c8664" lower="(nil)">//n个节点，st为源点<Finish/></txt><txt ptr="0xa8932884" next="0xa8932914" prev="0xa89327f4" upper="0xa99c8664" lower="(nil)">void dijkstra(int n,int st) {<Finish/></txt><txt ptr="0xa8932914" next="0xa89329a4" prev="0xa8932884" upper="0xa99c8664" lower="(nil)">    int i, j, _min, pre;<Finish/></txt><txt ptr="0xa89329a4" next="0xa8932a34" prev="0xa8932914" upper="0xa99c8664" lower="(nil)">    bool vis[N];<Finish/></txt><txt ptr="0xa8932a34" next="0xa8932ac4" prev="0xa89329a4" upper="0xa99c8664" lower="(nil)">    memset(vis,0,sizeof(vis));<Finish/></txt><txt ptr="0xa8932ac4" next="0xa8932b54" prev="0xa8932a34" upper="0xa99c8664" lower="(nil)">    vis[st] = 1;<Finish/></txt><txt ptr="0xa8932b54" next="0xa8932be4" prev="0xa8932ac4" upper="0xa99c8664" lower="(nil)">    for(i=0; i&lt;n; i++) {<Finish/></txt><txt ptr="0xa8932be4" next="0xa8932f44" prev="0xa8932b54" upper="0xa99c8664" lower="(nil)">        lowcost[i] = cost[st][i];path[i] = st;<Finish/></txt><txt ptr="0xa8932f44" next="(nil)" prev="0xa8932be4" upper="0xa99c8664" lower="(nil)">    }<Finish/></txt></body></column><column ptr="0xa99af130" next="(nil)" prev="0xa99af194" upper="0xa99bc780" lower="0xa99c8604"><body ptr="0xa99c8604" next="(nil)" prev="(nil)" upper="0xa99af130" lower="0xa8933018"><txt ptr="0xa8933018" next="0xa89330a8" prev="(nil)" upper="0xa99c8604" lower="(nil)"><Finish/></txt><txt ptr="0xa89330a8" next="0xa8933138" prev="0xa8933018" upper="0xa99c8604" lower="(nil)">    lowcost[st] = 0; path[st] = -1; pre = st;<Finish/></txt><txt ptr="0xa8933138" next="0xa89331c8" prev="0xa89330a8" upper="0xa99c8604" lower="(nil)"><Finish/></txt><txt ptr="0xa89331c8" next="0xa8933258" prev="0xa8933138" upper="0xa99c8604" lower="(nil)">    for(i = 0; i &lt; n; i++) {<Finish/></txt><txt ptr="0xa8933258" next="0xa89332e8" prev="0xa89331c8" upper="0xa99c8604" lower="(nil)">        for(j=0; j&lt;n; j++) <Finish/></txt><txt ptr="0xa89332e8" next="0xa8933378" prev="0xa8933258" upper="0xa99c8604" lower="(nil)">  if(vis[j]==0&amp;&amp;lowcost[pre]+cost[pre][j]&lt;lowcost[j])<Finish/></txt><txt ptr="0xa8933378" next="0xa8933408" prev="0xa89332e8" upper="0xa99c8604" lower="(nil)">    lowcost[j]=lowcost[pre]+ lost[pre][j], path[j] = pre;<Finish/></txt><txt ptr="0xa8933408" next="0xa8933498" prev="0xa8933378" upper="0xa99c8604" lower="(nil)">            <Finish/></txt><txt ptr="0xa8933498" next="0xa8933528" prev="0xa8933408" upper="0xa99c8604" lower="(nil)">        _min = INF;<Finish/></txt><txt ptr="0xa8933528" next="0xa89335b8" prev="0xa8933498" upper="0xa99c8604" lower="(nil)">        for(j=0; j&lt;n; j++) <Finish/></txt><txt ptr="0xa89335b8" next="0xa8933648" prev="0xa8933528" upper="0xa99c8604" lower="(nil)">            if(vis[j] == 0 &amp;&amp; lowcost[j] &lt; _min)               <Finish/></txt><txt ptr="0xa8933648" next="0xa89336d8" prev="0xa89335b8" upper="0xa99c8604" lower="(nil)">                _min = lowcost[j] , pre = j;<Finish/></txt><txt ptr="0xa89336d8" next="0xa8933768" prev="0xa8933648" upper="0xa99c8604" lower="(nil)">    <Finish/></txt><txt ptr="0xa8933768" next="0xa89337f8" prev="0xa89336d8" upper="0xa99c8604" lower="(nil)">        vis[pre] = 1;<Finish/></txt><txt ptr="0xa89337f8" next="0xa8933888" prev="0xa8933768" upper="0xa99c8604" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8933888" next="0xa8933918" prev="0xa89337f8" upper="0xa99c8604" lower="(nil)">    return ;<Finish/></txt><txt ptr="0xa8933918" next="0xa89339a8" prev="0xa8933888" upper="0xa99c8604" lower="(nil)">}<Finish/></txt><txt ptr="0xa89339a8" next="0xa8933a38" prev="0xa8933918" upper="0xa99c8604" lower="(nil)">堆优化O(n*log(n))算法<Finish/></txt><txt ptr="0xa8933a38" next="0xa8933ac8" prev="0xa89339a8" upper="0xa99c8604" lower="(nil)">typedef int typec;<Finish/></txt><txt ptr="0xa8933ac8" next="0xa8933b58" prev="0xa8933a38" upper="0xa99c8604" lower="(nil)">const int V = 100;<Finish/></txt><txt ptr="0xa8933b58" next="0xa8933be8" prev="0xa8933ac8" upper="0xa99c8604" lower="(nil)">const int E = 10000;<Finish/></txt><txt ptr="0xa8933be8" next="0xa8933c78" prev="0xa8933b58" upper="0xa99c8604" lower="(nil)">const typec inf = 0x3f3f3f3f; // max of cost<Finish/></txt><txt ptr="0xa8933c78" next="0xa8933d08" prev="0xa8933be8" upper="0xa99c8604" lower="(nil)">typec cost[E], dist[V];<Finish/></txt><txt ptr="0xa8933d08" next="0xa8933d98" prev="0xa8933c78" upper="0xa99c8604" lower="(nil)">int e, pnt[E], nxt[E], head[V], prev[V], vis[V];<Finish/></txt><txt ptr="0xa8933d98" next="0xa8933e28" prev="0xa8933d08" upper="0xa99c8604" lower="(nil)"><Finish/></txt><txt ptr="0xa8933e28" next="0xa8933eb8" prev="0xa8933d98" upper="0xa99c8604" lower="(nil)">struct qnode {<Finish/></txt><txt ptr="0xa8933eb8" next="0xa8933f48" prev="0xa8933e28" upper="0xa99c8604" lower="(nil)">    int v;<Finish/></txt><txt ptr="0xa8933f48" next="(nil)" prev="0xa8933eb8" upper="0xa99c8604" lower="(nil)">    typec c;<Finish/></txt></body></column></section></body><footer ptr="0xa8998ea0" next="(nil)" prev="0xa998eccc" upper="0xa9996248" lower="0xa997fd08"><txt ptr="0xa997fd08" next="0xa997feb8" prev="(nil)" upper="0xa8998ea0" lower="(nil)"><anchored><fly ptr="0xb563610" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa997fd98"><txt ptr="0xa997fd98" next="0xa997fe28" prev="(nil)" upper="0xb563610" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa997fe28" next="(nil)" prev="0xa997fd98" upper="0xb563610" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="4"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="2"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa997feb8" next="(nil)" prev="0xa997fd08" upper="0xa8998ea0" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa99962bc" next="0xa9996330" prev="0xa9996248" upper="0xb0726b0" lower="0xa8996f00"><header ptr="0xa8996f00" next="0xa998ee4c" prev="(nil)" upper="0xa99962bc" lower="0xa9981260"><txt ptr="0xa9981260" next="(nil)" prev="(nil)" upper="0xa8996f00" lower="(nil)"><Finish/></txt></header><body ptr="0xa998ee4c" next="0xa8998f00" prev="0xa8996f00" upper="0xa99962bc" lower="0xa99bc700"><section ptr="0xa99bc700" next="(nil)" prev="(nil)" upper="0xa998ee4c" lower="0xa6c03c54" follow="0xa99bc500" precede="0xa99bc780"><column ptr="0xa6c03c54" next="0xa6c03cb8" prev="(nil)" upper="0xa99bc700" lower="0xa6c04af0"><body ptr="0xa6c04af0" next="(nil)" prev="(nil)" upper="0xa6c03c54" lower="0xa893401c"><txt ptr="0xa893401c" next="0xa89340ac" prev="(nil)" upper="0xa6c04af0" lower="(nil)">    qnode (int vv = 0, typec cc = 0) : v(vv), c(cc) {}<Finish/></txt><txt ptr="0xa89340ac" next="0xa893413c" prev="0xa893401c" upper="0xa6c04af0" lower="(nil)">    bool operator &lt; (const qnode&amp; r) const {<Finish/></txt><txt ptr="0xa893413c" next="0xa89341cc" prev="0xa89340ac" upper="0xa6c04af0" lower="(nil)">        return c&gt;r.c;<Finish/></txt><txt ptr="0xa89341cc" next="0xa893452c" prev="0xa893413c" upper="0xa6c04af0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa893452c" next="0xa89345bc" prev="0xa89341cc" upper="0xa6c04af0" lower="(nil)">};<Finish/></txt><txt ptr="0xa89345bc" next="0xa893464c" prev="0xa893452c" upper="0xa6c04af0" lower="(nil)"><Finish/></txt><txt ptr="0xa893464c" next="0xa89346dc" prev="0xa89345bc" upper="0xa6c04af0" lower="(nil)">void dijkstra(int n, const int src) {<Finish/></txt><txt ptr="0xa89346dc" next="0xa893476c" prev="0xa893464c" upper="0xa6c04af0" lower="(nil)">    qnode mv;<Finish/></txt><txt ptr="0xa893476c" next="0xa89347fc" prev="0xa89346dc" upper="0xa6c04af0" lower="(nil)">    int i, j, k, pre;<Finish/></txt><txt ptr="0xa89347fc" next="0xa893488c" prev="0xa893476c" upper="0xa6c04af0" lower="(nil)">    priority_queue&lt;qnode&gt; que;<Finish/></txt><txt ptr="0xa893488c" next="0xa893491c" prev="0xa89347fc" upper="0xa6c04af0" lower="(nil)">    vis[src] = 1;<Finish/></txt><txt ptr="0xa893491c" next="0xa89349ac" prev="0xa893488c" upper="0xa6c04af0" lower="(nil)">    dist[src] = 0;<Finish/></txt><txt ptr="0xa89349ac" next="0xa8934a3c" prev="0xa893491c" upper="0xa6c04af0" lower="(nil)">    que.push(qnode(src, 0));<Finish/></txt><txt ptr="0xa8934a3c" next="0xa8934acc" prev="0xa89349ac" upper="0xa6c04af0" lower="(nil)"><Finish/></txt><txt ptr="0xa8934acc" next="0xa8934b5c" prev="0xa8934a3c" upper="0xa6c04af0" lower="(nil)">    for (pre = src, i=1; i&lt;n; i++) {<Finish/></txt><txt ptr="0xa8934b5c" next="0xa8934bec" prev="0xa8934acc" upper="0xa6c04af0" lower="(nil)">        for (j = head[pre]; j != -1; j = nxt[j]) {<Finish/></txt><txt ptr="0xa8934bec" next="0xa8934c7c" prev="0xa8934b5c" upper="0xa6c04af0" lower="(nil)">            k = pnt[j];<Finish/></txt><txt ptr="0xa8934c7c" next="0xa8934d0c" prev="0xa8934bec" upper="0xa6c04af0" lower="(nil)">       if (vis[k] == 0 &amp;&amp; dist[pre] + cost[j] &lt; dist[k]) {<Finish/></txt><txt ptr="0xa8934d0c" next="0xa8934d9c" prev="0xa8934c7c" upper="0xa6c04af0" lower="(nil)">                dist[k] = dist[pre] + cost[j];<Finish/></txt><txt ptr="0xa8934d9c" next="0xa8934e2c" prev="0xa8934d0c" upper="0xa6c04af0" lower="(nil)">                que.push(qnode(pnt[j], dist[k]));<Finish/></txt><txt ptr="0xa8934e2c" next="0xa8934ebc" prev="0xa8934d9c" upper="0xa6c04af0" lower="(nil)">                prev[k] = pre;<Finish/></txt><txt ptr="0xa8934ebc" next="0xa8934f4c" prev="0xa8934e2c" upper="0xa6c04af0" lower="(nil)">            }<Finish/></txt><txt ptr="0xa8934f4c" next="0xa8935020" prev="0xa8934ebc" upper="0xa6c04af0" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8935020" next="0xa89350b0" prev="0xa8934f4c" upper="0xa6c04af0" lower="(nil)"><Finish/></txt><txt ptr="0xa89350b0" next="0xa8935140" prev="0xa8935020" upper="0xa6c04af0" lower="(nil)">       while (!que.empty() &amp;&amp; vis[que.top().v] == 1){<Finish/></txt><txt ptr="0xa8935140" next="0xa89351d0" prev="0xa89350b0" upper="0xa6c04af0" lower="(nil)">            que.pop();<Finish/></txt><txt ptr="0xa89351d0" next="0xa8935260" prev="0xa8935140" upper="0xa6c04af0" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8935260" next="(nil)" prev="0xa89351d0" upper="0xa6c04af0" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa6c03cb8" next="0xa6c03d1c" prev="0xa6c03c54" upper="0xa99bc700" lower="0xa6c04b50"><body ptr="0xa6c04b50" next="(nil)" prev="(nil)" upper="0xa6c03cb8" lower="0xa89352f0"><txt ptr="0xa89352f0" next="0xa8935380" prev="(nil)" upper="0xa6c04b50" lower="(nil)">        if (que.empty()) break;<Finish/></txt><txt ptr="0xa8935380" next="0xa8935410" prev="0xa89352f0" upper="0xa6c04b50" lower="(nil)">        mv = que.top();<Finish/></txt><txt ptr="0xa8935410" next="0xa89354a0" prev="0xa8935380" upper="0xa6c04b50" lower="(nil)">        que.pop();<Finish/></txt><txt ptr="0xa89354a0" next="0xa8935530" prev="0xa8935410" upper="0xa6c04b50" lower="(nil)">        vis[pre = mv.v] = 1;<Finish/></txt><txt ptr="0xa8935530" next="0xa89355c0" prev="0xa89354a0" upper="0xa6c04b50" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89355c0" next="0xa8935650" prev="0xa8935530" upper="0xa6c04b50" lower="(nil)">}<Finish/></txt><txt ptr="0xa8935650" next="0xa89356e0" prev="0xa89355c0" upper="0xa6c04b50" lower="(nil)"><Finish/></txt><txt ptr="0xa89356e0" next="0xa8935770" prev="0xa8935650" upper="0xa6c04b50" lower="(nil)">inline void addedge(int u, int v, typec c) {<Finish/></txt><txt ptr="0xa8935770" next="0xa8935ad0" prev="0xa89356e0" upper="0xa6c04b50" lower="(nil)">    pnt[e] = v;<Finish/></txt><txt ptr="0xa8935ad0" next="0xa8935b60" prev="0xa8935770" upper="0xa6c04b50" lower="(nil)">    cost[e] = c;<Finish/></txt><txt ptr="0xa8935b60" next="0xa8935bf0" prev="0xa8935ad0" upper="0xa6c04b50" lower="(nil)">    nxt[e] = head[u];<Finish/></txt><txt ptr="0xa8935bf0" next="0xa8935c80" prev="0xa8935b60" upper="0xa6c04b50" lower="(nil)">    head[u] = e++;<Finish/></txt><txt ptr="0xa8935c80" next="0xa8935d10" prev="0xa8935bf0" upper="0xa6c04b50" lower="(nil)">}<Finish/></txt><txt ptr="0xa8935d10" next="0xa8935da0" prev="0xa8935c80" upper="0xa6c04b50" lower="(nil)"><Finish/></txt><txt ptr="0xa8935da0" next="0xa8935e30" prev="0xa8935d10" upper="0xa6c04b50" lower="(nil)">void init(int nv, int ne) {<Finish/></txt><txt ptr="0xa8935e30" next="0xa8935ec0" prev="0xa8935da0" upper="0xa6c04b50" lower="(nil)">    int i, u, v;<Finish/></txt><txt ptr="0xa8935ec0" next="0xa8935f50" prev="0xa8935e30" upper="0xa6c04b50" lower="(nil)">    typec c;<Finish/></txt><txt ptr="0xa8935f50" next="0xa8936024" prev="0xa8935ec0" upper="0xa6c04b50" lower="(nil)">    e = 0;<Finish/></txt><txt ptr="0xa8936024" next="0xa89360b4" prev="0xa8935f50" upper="0xa6c04b50" lower="(nil)">    memset(head, -1, sizeof(head));<Finish/></txt><txt ptr="0xa89360b4" next="0xa8936144" prev="0xa8936024" upper="0xa6c04b50" lower="(nil)">    memset(vis, 0, sizeof(vis));<Finish/></txt><txt ptr="0xa8936144" next="0xa89361d4" prev="0xa89360b4" upper="0xa6c04b50" lower="(nil)">    memset(prev, -1, sizeof(prev));<Finish/></txt><txt ptr="0xa89361d4" next="0xa8936264" prev="0xa8936144" upper="0xa6c04b50" lower="(nil)">    for (i = 0; i &lt; nv; i++) dist[i] = inf;<Finish/></txt><txt ptr="0xa8936264" next="0xa89362f4" prev="0xa89361d4" upper="0xa6c04b50" lower="(nil)">    for (i = 0; i &lt; ne; ++i) {<Finish/></txt><txt ptr="0xa89362f4" next="0xa8936384" prev="0xa8936264" upper="0xa6c04b50" lower="(nil)">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c);<Finish/></txt><txt ptr="0xa8936384" next="0xa8936414" prev="0xa89362f4" upper="0xa6c04b50" lower="(nil)">        addedge(u, v, c);<Finish/></txt><txt ptr="0xa8936414" next="0xa89364a4" prev="0xa8936384" upper="0xa6c04b50" lower="(nil)">        addedge(v, u, c);<Finish/></txt><txt ptr="0xa89364a4" next="0xa8936534" prev="0xa8936414" upper="0xa6c04b50" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8936534" next="(nil)" prev="0xa89364a4" upper="0xa6c04b50" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa6c03d1c" next="(nil)" prev="0xa6c03cb8" upper="0xa99bc700" lower="0xa6c04bb0"><body ptr="0xa6c04bb0" next="(nil)" prev="(nil)" upper="0xa6c03d1c" lower="0xa89365c4"><txt ptr="0xa89365c4" next="0xa8936654" prev="(nil)" upper="0xa6c04bb0" lower="(nil)"><Finish/></txt><txt ptr="0xa8936654" next="0xa89366e4" prev="0xa89365c4" upper="0xa6c04bb0" lower="(nil)">Bellman-Ford<Finish/></txt><txt ptr="0xa89366e4" next="0xa8936774" prev="0xa8936654" upper="0xa6c04bb0" lower="(nil)">适用条件<Finish/></txt><txt ptr="0xa8936774" next="0xa8936804" prev="0xa89366e4" upper="0xa6c04bb0" lower="(nil)">单源最短路径(从源点s到其它所有顶点v); <Finish/></txt><txt ptr="0xa8936804" next="0xa8936894" prev="0xa8936774" upper="0xa6c04bb0" lower="(nil)">可以存在负边权<Finish/></txt><txt ptr="0xa8936894" next="0xa8936924" prev="0xa8936804" upper="0xa6c04bb0" lower="(nil)">原始算法<Finish/></txt><txt ptr="0xa8936924" next="0xa89369b4" prev="0xa8936894" upper="0xa6c04bb0" lower="(nil)">（1）初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0;<Finish/></txt><txt ptr="0xa89369b4" next="0xa8936a44" prev="0xa8936924" upper="0xa6c04bb0" lower="(nil)">（2）迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；（运行|v|-1次）<Finish/></txt><txt ptr="0xa8936a44" next="0xa8936ad4" prev="0xa89369b4" upper="0xa6c04bb0" lower="(nil)">（3）检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在 d[v]中。<Finish/></txt><txt ptr="0xa8936ad4" next="0xa8936b64" prev="0xa8936a44" upper="0xa6c04bb0" lower="(nil)"><Finish/></txt><txt ptr="0xa8936b64" next="0xa8936bf4" prev="0xa8936ad4" upper="0xa6c04bb0" lower="(nil)">SPFA<Finish/></txt><txt ptr="0xa8936bf4" next="0xa8936c84" prev="0xa8936b64" upper="0xa6c04bb0" lower="(nil)">将源点入队<Finish/></txt><txt ptr="0xa8936c84" next="0xa8936d14" prev="0xa8936bf4" upper="0xa6c04bb0" lower="(nil)">队列不空时循环：<Finish/></txt><txt ptr="0xa8936d14" next="0xa89370b8" prev="0xa8936c84" upper="0xa6c04bb0" lower="(nil)">从队列中取出一个点<Finish/></txt><txt ptr="0xa89370b8" next="0xa8937148" prev="0xa8936d14" upper="0xa6c04bb0" lower="(nil)">对于该点所有邻接定点，如果通过取出点中转后距离更短<Finish/></txt><txt ptr="0xa8937148" next="0xa89371d8" prev="0xa89370b8" upper="0xa6c04bb0" lower="(nil)">更新最短距离<Finish/></txt><txt ptr="0xa89371d8" next="0xa8937268" prev="0xa8937148" upper="0xa6c04bb0" lower="(nil)">如果该点不再队列中，入队<Finish/></txt><txt ptr="0xa8937268" next="(nil)" prev="0xa89371d8" upper="0xa6c04bb0" lower="(nil)">结束<Finish/></txt></body></column></section></body><footer ptr="0xa8998f00" next="(nil)" prev="0xa998ee4c" upper="0xa99962bc" lower="0xa99812f0"><txt ptr="0xa99812f0" next="0xa99814a0" prev="(nil)" upper="0xa8998f00" lower="(nil)"><anchored><fly ptr="0xa5128f8" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa9981380"><txt ptr="0xa9981380" next="0xa9981410" prev="(nil)" upper="0xa5128f8" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa9981410" next="(nil)" prev="0xa9981380" upper="0xa5128f8" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="4"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="3"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99814a0" next="(nil)" prev="0xa99812f0" upper="0xa8998f00" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996330" next="0xa99963a4" prev="0xa99962bc" upper="0xb0726b0" lower="0xa8996f60"><header ptr="0xa8996f60" next="0xa9983010" prev="(nil)" upper="0xa9996330" lower="0xa9982804"><txt ptr="0xa9982804" next="(nil)" prev="(nil)" upper="0xa8996f60" lower="(nil)"><Finish/></txt></header><body ptr="0xa9983010" next="0xa8998f60" prev="0xa8996f60" upper="0xa9996330" lower="0xa99bc500"><section ptr="0xa99bc500" next="(nil)" prev="(nil)" upper="0xa9983010" lower="0xa6c03eac" follow="0xa891d210" precede="0xa99bc700"><column ptr="0xa6c03eac" next="0xa6c03f10" prev="(nil)" upper="0xa99bc500" lower="0xa6c04d30"><body ptr="0xa6c04d30" next="(nil)" prev="(nil)" upper="0xa6c03eac" lower="0xa89372f8"><txt ptr="0xa89372f8" next="0xa8937388" prev="(nil)" upper="0xa6c04d30" lower="(nil)"><Finish/></txt><txt ptr="0xa8937388" next="0xa8937418" prev="0xa89372f8" upper="0xa6c04d30" lower="(nil)">SPFA是Bellman-Ford的其中一种实现，一般都不用前者，而用SPFA。O(kE)，除了个别最坏的情况外，是个很好的算法。<Finish/></txt><txt ptr="0xa8937418" next="0xa89374a8" prev="0xa8937388" upper="0xa6c04d30" lower="(nil)">Bellman-Ford算法的一种队列实现，减少了不必要的冗余计算。 它可以在O(kE)的时间复杂度内求出源点到其他所有点的最短路径，可以处理负边。<Finish/></txt><txt ptr="0xa89374a8" next="0xa8937538" prev="0xa8937418" upper="0xa6c04d30" lower="(nil)">原理：只有那些在前一遍松弛中改变了距离估计值的点，才可能引起他们的邻接点的距离估计值的改变。判断负权回路：记录每个结点进队次数，超过|V|次表示有负权。<Finish/></txt><txt ptr="0xa8937538" next="0xa89375c8" prev="0xa89374a8" upper="0xa6c04d30" lower="(nil)">栈实现<Finish/></txt><txt ptr="0xa89375c8" next="0xa8937658" prev="0xa8937538" upper="0xa6c04d30" lower="(nil)">const int INF = 0x3F3F3F3F;<Finish/></txt><txt ptr="0xa8937658" next="0xa89376e8" prev="0xa89375c8" upper="0xa6c04d30" lower="(nil)">const int V = 30001;<Finish/></txt><txt ptr="0xa89376e8" next="0xa8937778" prev="0xa8937658" upper="0xa6c04d30" lower="(nil)">const int E = 150001;<Finish/></txt><txt ptr="0xa8937778" next="0xa8937808" prev="0xa89376e8" upper="0xa6c04d30" lower="(nil)">int pnt[E], cost[E], nxt[E];<Finish/></txt><txt ptr="0xa8937808" next="0xa8937898" prev="0xa8937778" upper="0xa6c04d30" lower="(nil)">stack&lt;int&gt;sta;<Finish/></txt><txt ptr="0xa8937898" next="0xa8937928" prev="0xa8937808" upper="0xa6c04d30" lower="(nil)">int e, head[V]; int dist[V]; bool vis[V];<Finish/></txt><txt ptr="0xa8937928" next="0xa89379b8" prev="0xa8937898" upper="0xa6c04d30" lower="(nil)">void init(){<Finish/></txt><txt ptr="0xa89379b8" next="0xa8937a48" prev="0xa8937928" upper="0xa6c04d30" lower="(nil)">*e = 0;memset(head, -1, sizeof(head));*<Finish/></txt><txt ptr="0xa8937a48" next="0xa8937ad8" prev="0xa89379b8" upper="0xa6c04d30" lower="(nil)">}<Finish/></txt><txt ptr="0xa8937ad8" next="0xa8937b68" prev="0xa8937a48" upper="0xa6c04d30" lower="(nil)">void addedge(int u, int v, int c){<Finish/></txt><txt ptr="0xa8937b68" next="0xa8937bf8" prev="0xa8937ad8" upper="0xa6c04d30" lower="(nil)">*pnt[e] = v; cost[e] = c; nxt[e] = head[u]; head[u] = e++;<Finish/></txt><txt ptr="0xa8937bf8" next="0xa8937c88" prev="0xa8937b68" upper="0xa6c04d30" lower="(nil)">}<Finish/></txt><txt ptr="0xa8937c88" next="(nil)" prev="0xa8937bf8" upper="0xa6c04d30" lower="(nil)">int SPFA(int src, int n){<Finish/></txt></body></column><column ptr="0xa6c03f10" next="0xa6c03f74" prev="0xa6c03eac" upper="0xa99bc500" lower="0xa6c04d90"><body ptr="0xa6c04d90" next="(nil)" prev="(nil)" upper="0xa6c03f10" lower="0xa8937d18"><txt ptr="0xa8937d18" next="0xa8937da8" prev="(nil)" upper="0xa6c04d90" lower="(nil)">*int i,u,v;<Finish/></txt><txt ptr="0xa8937da8" next="0xa8937e38" prev="0xa8937d18" upper="0xa6c04d90" lower="(nil)">*for( i=1; i &lt;= n; ++i ){ <Finish/></txt><txt ptr="0xa8937e38" next="0xa8937ec8" prev="0xa8937da8" upper="0xa6c04d90" lower="(nil)">**vis[i] = 1; dist[i] = INF;<Finish/></txt><txt ptr="0xa8937ec8" next="0xa8937f58" prev="0xa8937e38" upper="0xa6c04d90" lower="(nil)">*}<Finish/></txt><txt ptr="0xa8937f58" next="0xa8938000" prev="0xa8937ec8" upper="0xa6c04d90" lower="(nil)">*while(!sta.empty())sta.pop();<Finish/></txt><txt ptr="0xa8938000" next="0xa8938090" prev="0xa8937f58" upper="0xa6c04d90" lower="(nil)"><Finish/></txt><txt ptr="0xa8938090" next="0xa8938120" prev="0xa8938000" upper="0xa6c04d90" lower="(nil)">*dist[src] = 0;<Finish/></txt><txt ptr="0xa8938120" next="0xa89381b0" prev="0xa8938090" upper="0xa6c04d90" lower="(nil)">*sta.push(src);vis[src] = 0;<Finish/></txt><txt ptr="0xa89381b0" next="0xa8938240" prev="0xa8938120" upper="0xa6c04d90" lower="(nil)">*<Finish/></txt><txt ptr="0xa8938240" next="0xa89382d0" prev="0xa89381b0" upper="0xa6c04d90" lower="(nil)">*while(!sta.empty()){<Finish/></txt><txt ptr="0xa89382d0" next="0xa8938630" prev="0xa8938240" upper="0xa6c04d90" lower="(nil)">**u=sta.top();sta.pop();vis[u] = 1;<Finish/></txt><txt ptr="0xa8938630" next="0xa89386c0" prev="0xa89382d0" upper="0xa6c04d90" lower="(nil)">**for( i=head[u]; i != -1; i=nxt[i] ){<Finish/></txt><txt ptr="0xa89386c0" next="0xa8938750" prev="0xa8938630" upper="0xa6c04d90" lower="(nil)">***v = pnt[i];<Finish/></txt><txt ptr="0xa8938750" next="0xa89387e0" prev="0xa89386c0" upper="0xa6c04d90" lower="(nil)">***if(dist[v] &gt; dist[u] + cost[i]){<Finish/></txt><txt ptr="0xa89387e0" next="0xa8938870" prev="0xa8938750" upper="0xa6c04d90" lower="(nil)">****dist[v] = dist[u] + cost[i];<Finish/></txt><txt ptr="0xa8938870" next="0xa8938900" prev="0xa89387e0" upper="0xa6c04d90" lower="(nil)">****if(vis[v]){<Finish/></txt><txt ptr="0xa8938900" next="0xa8938990" prev="0xa8938870" upper="0xa6c04d90" lower="(nil)">*****sta.push(v);vis[v] = 0;<Finish/></txt><txt ptr="0xa8938990" next="0xa8938a20" prev="0xa8938900" upper="0xa6c04d90" lower="(nil)">****}<Finish/></txt><txt ptr="0xa8938a20" next="0xa8938ab0" prev="0xa8938990" upper="0xa6c04d90" lower="(nil)">***}<Finish/></txt><txt ptr="0xa8938ab0" next="0xa8938b40" prev="0xa8938a20" upper="0xa6c04d90" lower="(nil)">**}<Finish/></txt><txt ptr="0xa8938b40" next="0xa8938bd0" prev="0xa8938ab0" upper="0xa6c04d90" lower="(nil)">*}<Finish/></txt><txt ptr="0xa8938bd0" next="0xa8938c60" prev="0xa8938b40" upper="0xa6c04d90" lower="(nil)">*return dist[n];<Finish/></txt><txt ptr="0xa8938c60" next="0xa8938cf0" prev="0xa8938bd0" upper="0xa6c04d90" lower="(nil)">}<Finish/></txt><txt ptr="0xa8938cf0" next="0xa8938d80" prev="0xa8938c60" upper="0xa6c04d90" lower="(nil)">队列实现<Finish/></txt><txt ptr="0xa8938d80" next="0xa8938e10" prev="0xa8938cf0" upper="0xa6c04d90" lower="(nil)">而且有负权回路判断<Finish/></txt><txt ptr="0xa8938e10" next="0xa8938ea0" prev="0xa8938d80" upper="0xa6c04d90" lower="(nil)"><Finish/></txt><txt ptr="0xa8938ea0" next="0xa8938f30" prev="0xa8938e10" upper="0xa6c04d90" lower="(nil)">const int INF = 0x3F3F3F3F;<Finish/></txt><txt ptr="0xa8938f30" next="(nil)" prev="0xa8938ea0" upper="0xa6c04d90" lower="(nil)">const int V = 1001;<Finish/></txt></body></column><column ptr="0xa6c03f74" next="(nil)" prev="0xa6c03f10" upper="0xa99bc500" lower="0xa6c04df0"><body ptr="0xa6c04df0" next="(nil)" prev="(nil)" upper="0xa6c03f74" lower="0xa8939004"><txt ptr="0xa8939004" next="0xa8939094" prev="(nil)" upper="0xa6c04df0" lower="(nil)">const int E = 20001;<Finish/></txt><txt ptr="0xa8939094" next="0xa8939124" prev="0xa8939004" upper="0xa6c04df0" lower="(nil)">int pnt[E], cost[E], nxt[E];<Finish/></txt><txt ptr="0xa8939124" next="0xa89391b4" prev="0xa8939094" upper="0xa6c04df0" lower="(nil)">int e, head[V], dist[V];<Finish/></txt><txt ptr="0xa89391b4" next="0xa8939244" prev="0xa8939124" upper="0xa6c04df0" lower="(nil)">bool vis[V];<Finish/></txt><txt ptr="0xa8939244" next="0xa89392d4" prev="0xa89391b4" upper="0xa6c04df0" lower="(nil)">int cnt[V]; // 入队列次数<Finish/></txt><txt ptr="0xa89392d4" next="0xa8939364" prev="0xa8939244" upper="0xa6c04df0" lower="(nil)">queue&lt;int&gt; que;<Finish/></txt><txt ptr="0xa8939364" next="0xa89393f4" prev="0xa89392d4" upper="0xa6c04df0" lower="(nil)"><Finish/></txt><txt ptr="0xa89393f4" next="0xa8939484" prev="0xa8939364" upper="0xa6c04df0" lower="(nil)">void init(){e = 0;memset(head, -1, sizeof(head));}<Finish/></txt><txt ptr="0xa8939484" next="0xa8939514" prev="0xa89393f4" upper="0xa6c04df0" lower="(nil)"><Finish/></txt><txt ptr="0xa8939514" next="0xa89395a4" prev="0xa8939484" upper="0xa6c04df0" lower="(nil)">inline void addedge(int u, int v, int c){<Finish/></txt><txt ptr="0xa89395a4" next="0xa8939634" prev="0xa8939514" upper="0xa6c04df0" lower="(nil)">pnt[e] = v; cost[e] = c; nxt[e] = head[u]; head[u] = e++;<Finish/></txt><txt ptr="0xa8939634" next="0xa89396c4" prev="0xa89395a4" upper="0xa6c04df0" lower="(nil)">}<Finish/></txt><txt ptr="0xa89396c4" next="0xa8939754" prev="0xa8939634" upper="0xa6c04df0" lower="(nil)"><Finish/></txt><txt ptr="0xa8939754" next="0xa89397e4" prev="0xa89396c4" upper="0xa6c04df0" lower="(nil)">int SPFA(int src, int n){<Finish/></txt><txt ptr="0xa89397e4" next="0xa8939874" prev="0xa8939754" upper="0xa6c04df0" lower="(nil)">*int i,u,v;<Finish/></txt><txt ptr="0xa8939874" next="0xa8939bd4" prev="0xa89397e4" upper="0xa6c04df0" lower="(nil)">for( i=1; i &lt;= n; ++i ) {dist[i] = INF;cnt[i]=0;vis[i]=1;}<Finish/></txt><txt ptr="0xa8939bd4" next="0xa8939c64" prev="0xa8939874" upper="0xa6c04df0" lower="(nil)"><Finish/></txt><txt ptr="0xa8939c64" next="0xa8939cf4" prev="0xa8939bd4" upper="0xa6c04df0" lower="(nil)">*while(!que.empty())que.pop();<Finish/></txt><txt ptr="0xa8939cf4" next="0xa8939d84" prev="0xa8939c64" upper="0xa6c04df0" lower="(nil)">*que.push(src);vis[src] =0; dist[src] = 0;++cnt[src];<Finish/></txt><txt ptr="0xa8939d84" next="0xa8939e14" prev="0xa8939cf4" upper="0xa6c04df0" lower="(nil)">*while( !que.empty() ){<Finish/></txt><txt ptr="0xa8939e14" next="0xa8939ea4" prev="0xa8939d84" upper="0xa6c04df0" lower="(nil)">**u = que.front();que.pop(); vis[u] =1;<Finish/></txt><txt ptr="0xa8939ea4" next="0xa8939f34" prev="0xa8939e14" upper="0xa6c04df0" lower="(nil)">**for( i=head[u]; i != -1; i=nxt[i] ){<Finish/></txt><txt ptr="0xa8939f34" next="0xa893a008" prev="0xa8939ea4" upper="0xa6c04df0" lower="(nil)">***v = pnt[i];<Finish/></txt><txt ptr="0xa893a008" next="0xa893a098" prev="0xa8939f34" upper="0xa6c04df0" lower="(nil)">***if(dist[v] &gt; dist[u] + cost[i] ){<Finish/></txt><txt ptr="0xa893a098" next="0xa893a128" prev="0xa893a008" upper="0xa6c04df0" lower="(nil)">****dist[v] = dist[u] + cost[i]; <Finish/></txt><txt ptr="0xa893a128" next="0xa893a1b8" prev="0xa893a098" upper="0xa6c04df0" lower="(nil)">**if(vis[v]){<Finish/></txt><txt ptr="0xa893a1b8" next="0xa893a248" prev="0xa893a128" upper="0xa6c04df0" lower="(nil)">***que.push(v);vis[v]=0;<Finish/></txt><txt ptr="0xa893a248" next="(nil)" prev="0xa893a1b8" upper="0xa6c04df0" lower="(nil)">***if((++cnt[v])&gt;n)return -1;//出现负权回路 <Finish/></txt></body></column></section></body><footer ptr="0xa8998f60" next="(nil)" prev="0xa9983010" upper="0xa9996330" lower="0xa9982894"><txt ptr="0xa9982894" next="0xa9982a44" prev="(nil)" upper="0xa8998f60" lower="(nil)"><anchored><fly ptr="0xb5639b0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa9982924"><txt ptr="0xa9982924" next="0xa99829b4" prev="(nil)" upper="0xb5639b0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa99829b4" next="(nil)" prev="0xa9982924" upper="0xb5639b0" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="4"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="4"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa9982a44" next="(nil)" prev="0xa9982894" upper="0xa8998f60" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa99963a4" next="0xa9996418" prev="0xa9996330" upper="0xb0726b0" lower="0xa9985004"><header ptr="0xa9985004" next="0xa9983190" prev="(nil)" upper="0xa99963a4" lower="0xa9984da8"><txt ptr="0xa9984da8" next="(nil)" prev="(nil)" upper="0xa9985004" lower="(nil)"><Finish/></txt></header><body ptr="0xa9983190" next="0xa9986004" prev="0xa9985004" upper="0xa99963a4" lower="0xa891d210"><section ptr="0xa891d210" next="(nil)" prev="(nil)" upper="0xa9983190" lower="0xa8999834" follow="0xa891d110" precede="0xa99bc500"><column ptr="0xa8999834" next="0xa89997d0" prev="(nil)" upper="0xa891d210" lower="0xa8995540"><body ptr="0xa8995540" next="(nil)" prev="(nil)" upper="0xa8999834" lower="0xa893a2d8"><txt ptr="0xa893a2d8" next="0xa893a368" prev="(nil)" upper="0xa8995540" lower="(nil)">**}<Finish/></txt><txt ptr="0xa893a368" next="0xa893a3f8" prev="0xa893a2d8" upper="0xa8995540" lower="(nil)">***}<Finish/></txt><txt ptr="0xa893a3f8" next="0xa893a488" prev="0xa893a368" upper="0xa8995540" lower="(nil)">**}<Finish/></txt><txt ptr="0xa893a488" next="0xa893a518" prev="0xa893a3f8" upper="0xa8995540" lower="(nil)">*}<Finish/></txt><txt ptr="0xa893a518" next="0xa893a5a8" prev="0xa893a488" upper="0xa8995540" lower="(nil)">*if( dist[n] == INF ) return -2; // src与n不可达<Finish/></txt><txt ptr="0xa893a5a8" next="0xa893a638" prev="0xa893a518" upper="0xa8995540" lower="(nil)">*return dist[n]; // 返回src到n的最短距离<Finish/></txt><txt ptr="0xa893a638" next="0xa893a6c8" prev="0xa893a5a8" upper="0xa8995540" lower="(nil)">}<Finish/></txt><txt ptr="0xa893a6c8" next="0xa893a758" prev="0xa893a638" upper="0xa8995540" lower="(nil)">Vector储存<Finish/></txt><txt ptr="0xa893a758" next="0xa893a7e8" prev="0xa893a6c8" upper="0xa8995540" lower="(nil)">typedef struct{<Finish/></txt><txt ptr="0xa893a7e8" next="0xa893a878" prev="0xa893a758" upper="0xa8995540" lower="(nil)">*int from,to,dis;<Finish/></txt><txt ptr="0xa893a878" next="0xa893a908" prev="0xa893a7e8" upper="0xa8995540" lower="(nil)">}E;<Finish/></txt><txt ptr="0xa893a908" next="0xa893a998" prev="0xa893a878" upper="0xa8995540" lower="(nil)">int N,M,X;<Finish/></txt><txt ptr="0xa893a998" next="0xa893aa28" prev="0xa893a908" upper="0xa8995540" lower="(nil)">vector&lt; vector&lt;E&gt; &gt; map;<Finish/></txt><txt ptr="0xa893aa28" next="0xa893aab8" prev="0xa893a998" upper="0xa8995540" lower="(nil)">queue&lt;int&gt; que;<Finish/></txt><txt ptr="0xa893aab8" next="0xa893ab48" prev="0xa893aa28" upper="0xa8995540" lower="(nil)">vector&lt;bool&gt; inQue;<Finish/></txt><txt ptr="0xa893ab48" next="0xa893abd8" prev="0xa893aab8" upper="0xa8995540" lower="(nil)">vector&lt;int&gt; dis;<Finish/></txt><txt ptr="0xa893abd8" next="0xa893ac68" prev="0xa893ab48" upper="0xa8995540" lower="(nil)">/*X为源点*/<Finish/></txt><txt ptr="0xa893ac68" next="0xa893acf8" prev="0xa893abd8" upper="0xa8995540" lower="(nil)">map.clear();<Finish/></txt><txt ptr="0xa893acf8" next="0xa893ad88" prev="0xa893ac68" upper="0xa8995540" lower="(nil)">while(!que.empty())que.pop();<Finish/></txt><txt ptr="0xa893ad88" next="0xa893ae18" prev="0xa893acf8" upper="0xa8995540" lower="(nil)">inQue.clear();<Finish/></txt><txt ptr="0xa893ae18" next="0xa893b1bc" prev="0xa893ad88" upper="0xa8995540" lower="(nil)">dis.clear();<Finish/></txt><txt ptr="0xa893b1bc" next="0xa893b24c" prev="0xa893ae18" upper="0xa8995540" lower="(nil)">map.resize(N+1);<Finish/></txt><txt ptr="0xa893b24c" next="0xa893b2dc" prev="0xa893b1bc" upper="0xa8995540" lower="(nil)">inQue.resize(N+1,false);<Finish/></txt><txt ptr="0xa893b2dc" next="0xa893b36c" prev="0xa893b24c" upper="0xa8995540" lower="(nil)">dis.resize(N+1,INF);<Finish/></txt><txt ptr="0xa893b36c" next="0xa893b3fc" prev="0xa893b2dc" upper="0xa8995540" lower="(nil)">map2.resize(N+1);//初始化map2<Finish/></txt><txt ptr="0xa893b3fc" next="0xa893b48c" prev="0xa893b36c" upper="0xa8995540" lower="(nil)">for(i=0;i&lt;M;i++){<Finish/></txt><txt ptr="0xa893b48c" next="0xa893b51c" prev="0xa893b3fc" upper="0xa8995540" lower="(nil)">*scanf(&quot;%d%d%d&quot;,&amp;e.from,&amp;e.to,&amp;e.dis);<Finish/></txt><txt ptr="0xa893b51c" next="(nil)" prev="0xa893b48c" upper="0xa8995540" lower="(nil)">*map[e.from].push_back(e);<Finish/></txt></body></column><column ptr="0xa89997d0" next="0xa899976c" prev="0xa8999834" upper="0xa891d210" lower="0xa89955a0"><body ptr="0xa89955a0" next="(nil)" prev="(nil)" upper="0xa89997d0" lower="0xa893b5ac"><txt ptr="0xa893b5ac" next="0xa893b63c" prev="(nil)" upper="0xa89955a0" lower="(nil)">}<Finish/></txt><txt ptr="0xa893b63c" next="0xa893b6cc" prev="0xa893b5ac" upper="0xa89955a0" lower="(nil)">que.push(X);<Finish/></txt><txt ptr="0xa893b6cc" next="0xa893b75c" prev="0xa893b63c" upper="0xa89955a0" lower="(nil)">inQue[X]=true;<Finish/></txt><txt ptr="0xa893b75c" next="0xa893b7ec" prev="0xa893b6cc" upper="0xa89955a0" lower="(nil)">dis[X]=0;<Finish/></txt><txt ptr="0xa893b7ec" next="0xa893b87c" prev="0xa893b75c" upper="0xa89955a0" lower="(nil)">while(!que.empty()){<Finish/></txt><txt ptr="0xa893b87c" next="0xa893b90c" prev="0xa893b7ec" upper="0xa89955a0" lower="(nil)">*w=que.front();<Finish/></txt><txt ptr="0xa893b90c" next="0xa893b99c" prev="0xa893b87c" upper="0xa89955a0" lower="(nil)">*que.pop();<Finish/></txt><txt ptr="0xa893b99c" next="0xa893ba2c" prev="0xa893b90c" upper="0xa89955a0" lower="(nil)">*inQue[w]=false;<Finish/></txt><txt ptr="0xa893ba2c" next="0xa893babc" prev="0xa893b99c" upper="0xa89955a0" lower="(nil)">*for(i=0;i&lt;map[w].size();i++){<Finish/></txt><txt ptr="0xa893babc" next="0xa893bb4c" prev="0xa893ba2c" upper="0xa89955a0" lower="(nil)">**if(dis[map[w][i].to]&gt;dis[w]+map[w][i].dis){<Finish/></txt><txt ptr="0xa893bb4c" next="0xa893bbdc" prev="0xa893babc" upper="0xa89955a0" lower="(nil)">***dis[map[w][i].to]=dis[w]+map[w][i].dis;<Finish/></txt><txt ptr="0xa893bbdc" next="0xa893bc6c" prev="0xa893bb4c" upper="0xa89955a0" lower="(nil)">***if(!inQue[map[w][i].to]){<Finish/></txt><txt ptr="0xa893bc6c" next="0xa893bcfc" prev="0xa893bbdc" upper="0xa89955a0" lower="(nil)">****que.push(map[w][i].to);<Finish/></txt><txt ptr="0xa893bcfc" next="0xa893bd8c" prev="0xa893bc6c" upper="0xa89955a0" lower="(nil)">****inQue[map[w][i].to]=true;<Finish/></txt><txt ptr="0xa893bd8c" next="0xa893be1c" prev="0xa893bcfc" upper="0xa89955a0" lower="(nil)">***}<Finish/></txt><txt ptr="0xa893be1c" next="0xa893beac" prev="0xa893bd8c" upper="0xa89955a0" lower="(nil)">**}<Finish/></txt><txt ptr="0xa893beac" next="0xa893bf3c" prev="0xa893be1c" upper="0xa89955a0" lower="(nil)">*}<Finish/></txt><txt ptr="0xa893bf3c" next="0xa893c010" prev="0xa893beac" upper="0xa89955a0" lower="(nil)">}<Finish/></txt><txt ptr="0xa893c010" next="0xa893c0a0" prev="0xa893bf3c" upper="0xa89955a0" lower="(nil)"><Finish/></txt><txt ptr="0xa893c0a0" next="0xa893c130" prev="0xa893c010" upper="0xa89955a0" lower="(nil)">最小生成树<Finish/></txt><txt ptr="0xa893c130" next="0xa893c1c0" prev="0xa893c0a0" upper="0xa89955a0" lower="(nil)">Kruskal算法<Finish/></txt><txt ptr="0xa893c1c0" next="0xa893c250" prev="0xa893c130" upper="0xa89955a0" lower="(nil)">const int N=1000;<Finish/></txt><txt ptr="0xa893c250" next="0xa893c2e0" prev="0xa893c1c0" upper="0xa89955a0" lower="(nil)">const int E = N*N/2;<Finish/></txt><txt ptr="0xa893c2e0" next="0xa893c370" prev="0xa893c250" upper="0xa89955a0" lower="(nil)"><Finish/></txt><txt ptr="0xa893c370" next="0xa893c400" prev="0xa893c2e0" upper="0xa89955a0" lower="(nil)">struct Edge{<Finish/></txt><txt ptr="0xa893c400" next="0xa893c760" prev="0xa893c370" upper="0xa89955a0" lower="(nil)">    int from,to,val;<Finish/></txt><txt ptr="0xa893c760" next="(nil)" prev="0xa893c400" upper="0xa89955a0" lower="(nil)">    bool operator&lt;=(const Edge&amp; e)const{<Finish/></txt></body></column><column ptr="0xa899976c" next="(nil)" prev="0xa89997d0" upper="0xa891d210" lower="0xa8995720"><body ptr="0xa8995720" next="(nil)" prev="(nil)" upper="0xa899976c" lower="0xa893c7f0"><txt ptr="0xa893c7f0" next="0xa893c880" prev="(nil)" upper="0xa8995720" lower="(nil)">        return val &lt;= e.val;<Finish/></txt><txt ptr="0xa893c880" next="0xa893c910" prev="0xa893c7f0" upper="0xa8995720" lower="(nil)">    }<Finish/></txt><txt ptr="0xa893c910" next="0xa893c9a0" prev="0xa893c880" upper="0xa8995720" lower="(nil)">    bool operator&lt;(const Edge&amp; e)const {<Finish/></txt><txt ptr="0xa893c9a0" next="0xa893ca30" prev="0xa893c910" upper="0xa8995720" lower="(nil)">        return val &lt; e.val;<Finish/></txt><txt ptr="0xa893ca30" next="0xa893cac0" prev="0xa893c9a0" upper="0xa8995720" lower="(nil)">    }<Finish/></txt><txt ptr="0xa893cac0" next="0xa893cb50" prev="0xa893ca30" upper="0xa8995720" lower="(nil)"><Finish/></txt><txt ptr="0xa893cb50" next="0xa893cbe0" prev="0xa893cac0" upper="0xa8995720" lower="(nil)">}edge[E];<Finish/></txt><txt ptr="0xa893cbe0" next="0xa893cc70" prev="0xa893cb50" upper="0xa8995720" lower="(nil)">int pre[N],rank[N];<Finish/></txt><txt ptr="0xa893cc70" next="0xa893cd00" prev="0xa893cbe0" upper="0xa8995720" lower="(nil)"><Finish/></txt><txt ptr="0xa893cd00" next="0xa893cd90" prev="0xa893cc70" upper="0xa8995720" lower="(nil)">void init(int n){<Finish/></txt><txt ptr="0xa893cd90" next="0xa893ce20" prev="0xa893cd00" upper="0xa8995720" lower="(nil)">    for(int i=0;i&lt;n;i++){<Finish/></txt><txt ptr="0xa893ce20" next="0xa893ceb0" prev="0xa893cd90" upper="0xa8995720" lower="(nil)">        pre[i] = i, rank[i] = 0;<Finish/></txt><txt ptr="0xa893ceb0" next="0xa893cf40" prev="0xa893ce20" upper="0xa8995720" lower="(nil)">    }<Finish/></txt><txt ptr="0xa893cf40" next="0xa893d014" prev="0xa893ceb0" upper="0xa8995720" lower="(nil)">}<Finish/></txt><txt ptr="0xa893d014" next="0xa893d0a4" prev="0xa893cf40" upper="0xa8995720" lower="(nil)"><Finish/></txt><txt ptr="0xa893d0a4" next="0xa893d134" prev="0xa893d014" upper="0xa8995720" lower="(nil)">int find_pre(int node){<Finish/></txt><txt ptr="0xa893d134" next="0xa893d1c4" prev="0xa893d0a4" upper="0xa8995720" lower="(nil)">    if(pre[node] != node){<Finish/></txt><txt ptr="0xa893d1c4" next="0xa893d254" prev="0xa893d134" upper="0xa8995720" lower="(nil)">        pre[node] = find_pre(pre[node]);<Finish/></txt><txt ptr="0xa893d254" next="0xa893d2e4" prev="0xa893d1c4" upper="0xa8995720" lower="(nil)">    }<Finish/></txt><txt ptr="0xa893d2e4" next="0xa893d374" prev="0xa893d254" upper="0xa8995720" lower="(nil)">    return pre[node];<Finish/></txt><txt ptr="0xa893d374" next="0xa893d404" prev="0xa893d2e4" upper="0xa8995720" lower="(nil)">}<Finish/></txt><txt ptr="0xa893d404" next="0xa893d494" prev="0xa893d374" upper="0xa8995720" lower="(nil)"><Finish/></txt><txt ptr="0xa893d494" next="0xa893d524" prev="0xa893d404" upper="0xa8995720" lower="(nil)">void merge_pre(int from, int to){<Finish/></txt><txt ptr="0xa893d524" next="0xa893d5b4" prev="0xa893d494" upper="0xa8995720" lower="(nil)">    from = find_pre(from);<Finish/></txt><txt ptr="0xa893d5b4" next="0xa893d644" prev="0xa893d524" upper="0xa8995720" lower="(nil)">    to = find_pre(to);<Finish/></txt><txt ptr="0xa893d644" next="0xa893d6d4" prev="0xa893d5b4" upper="0xa8995720" lower="(nil)"><Finish/></txt><txt ptr="0xa893d6d4" next="0xa893d764" prev="0xa893d644" upper="0xa8995720" lower="(nil)">    if(from != to){<Finish/></txt><txt ptr="0xa893d764" next="(nil)" prev="0xa893d6d4" upper="0xa8995720" lower="(nil)">        if(rank[from] &gt; rank[to]){<Finish/></txt></body></column></section></body><footer ptr="0xa9986004" next="(nil)" prev="0xa9983190" upper="0xa99963a4" lower="0xa9984e38"><txt ptr="0xa9984e38" next="0xa9987000" prev="(nil)" upper="0xa9986004" lower="(nil)"><anchored><fly ptr="0xb6ce0a0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa9984ec8"><txt ptr="0xa9984ec8" next="0xa9984f58" prev="(nil)" upper="0xb6ce0a0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa9984f58" next="(nil)" prev="0xa9984ec8" upper="0xb6ce0a0" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="4"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="5"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa9987000" next="(nil)" prev="0xa9984e38" upper="0xa9986004" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996418" next="0xa999648c" prev="0xa99963a4" upper="0xb0726b0" lower="0xa9985064"><header ptr="0xa9985064" next="0xa9983310" prev="(nil)" upper="0xa9996418" lower="0xa9988364"><txt ptr="0xa9988364" next="(nil)" prev="(nil)" upper="0xa9985064" lower="(nil)"><Finish/></txt></header><body ptr="0xa9983310" next="0xa9986064" prev="0xa9985064" upper="0xa9996418" lower="0xa891d110"><section ptr="0xa891d110" next="(nil)" prev="(nil)" upper="0xa9983310" lower="0xa89995dc" follow="0xa891d610" precede="0xa891d210"><column ptr="0xa89995dc" next="0xa8999578" prev="(nil)" upper="0xa891d110" lower="0xa8995360"><body ptr="0xa8995360" next="(nil)" prev="(nil)" upper="0xa89995dc" lower="0xa893d7f4"><txt ptr="0xa893d7f4" next="0xa893d884" prev="(nil)" upper="0xa8995360" lower="(nil)">            pre[to] = from;<Finish/></txt><txt ptr="0xa893d884" next="0xa893d914" prev="0xa893d7f4" upper="0xa8995360" lower="(nil)">        }else{<Finish/></txt><txt ptr="0xa893d914" next="0xa893d9a4" prev="0xa893d884" upper="0xa8995360" lower="(nil)">            pre[from] = to;<Finish/></txt><txt ptr="0xa893d9a4" next="0xa893dd04" prev="0xa893d914" upper="0xa8995360" lower="(nil)">            if(rank[from] == rank[to]){<Finish/></txt><txt ptr="0xa893dd04" next="0xa893dd94" prev="0xa893d9a4" upper="0xa8995360" lower="(nil)">                ++rank[to];<Finish/></txt><txt ptr="0xa893dd94" next="0xa893de24" prev="0xa893dd04" upper="0xa8995360" lower="(nil)">            }<Finish/></txt><txt ptr="0xa893de24" next="0xa893deb4" prev="0xa893dd94" upper="0xa8995360" lower="(nil)">        }<Finish/></txt><txt ptr="0xa893deb4" next="0xa893df44" prev="0xa893de24" upper="0xa8995360" lower="(nil)">    }<Finish/></txt><txt ptr="0xa893df44" next="0xa891e018" prev="0xa893deb4" upper="0xa8995360" lower="(nil)"><Finish/></txt><txt ptr="0xa891e018" next="0xa891e0a8" prev="0xa893df44" upper="0xa8995360" lower="(nil)">}<Finish/></txt><txt ptr="0xa891e0a8" next="0xa891e138" prev="0xa891e018" upper="0xa8995360" lower="(nil)"><Finish/></txt><txt ptr="0xa891e138" next="0xa891e1c8" prev="0xa891e0a8" upper="0xa8995360" lower="(nil)">int kruskal(int n,int m){<Finish/></txt><txt ptr="0xa891e1c8" next="0xa891e258" prev="0xa891e138" upper="0xa8995360" lower="(nil)">    sort(edge, edge + m);<Finish/></txt><txt ptr="0xa891e258" next="0xa891e2e8" prev="0xa891e1c8" upper="0xa8995360" lower="(nil)">    init(n);<Finish/></txt><txt ptr="0xa891e2e8" next="0xa891e378" prev="0xa891e258" upper="0xa8995360" lower="(nil)">    int find_edge = 0, i, pre_from, pre_to;<Finish/></txt><txt ptr="0xa891e378" next="0xa891e408" prev="0xa891e2e8" upper="0xa8995360" lower="(nil)">    int w = 0;<Finish/></txt><txt ptr="0xa891e408" next="0xa891e498" prev="0xa891e378" upper="0xa8995360" lower="(nil)"><Finish/></txt><txt ptr="0xa891e498" next="0xa891e528" prev="0xa891e408" upper="0xa8995360" lower="(nil)">    for(i = 0; i &lt; m; i++){<Finish/></txt><txt ptr="0xa891e528" next="0xa891e5b8" prev="0xa891e498" upper="0xa8995360" lower="(nil)">        pre_from = find_pre(edge[i].from);<Finish/></txt><txt ptr="0xa891e5b8" next="0xa891e648" prev="0xa891e528" upper="0xa8995360" lower="(nil)">        pre_to = find_pre(edge[i].to);<Finish/></txt><txt ptr="0xa891e648" next="0xa891e6d8" prev="0xa891e5b8" upper="0xa8995360" lower="(nil)">        if(pre_from == pre_to){<Finish/></txt><txt ptr="0xa891e6d8" next="0xa891e768" prev="0xa891e648" upper="0xa8995360" lower="(nil)">            continue;<Finish/></txt><txt ptr="0xa891e768" next="0xa891e7f8" prev="0xa891e6d8" upper="0xa8995360" lower="(nil)">        }<Finish/></txt><txt ptr="0xa891e7f8" next="0xa891e888" prev="0xa891e768" upper="0xa8995360" lower="(nil)">        merge_pre(pre_from, pre_to);<Finish/></txt><txt ptr="0xa891e888" next="0xa891e918" prev="0xa891e7f8" upper="0xa8995360" lower="(nil)"><Finish/></txt><txt ptr="0xa891e918" next="0xa891e9a8" prev="0xa891e888" upper="0xa8995360" lower="(nil)">        w += edge[i].val;<Finish/></txt><txt ptr="0xa891e9a8" next="0xa891ea38" prev="0xa891e918" upper="0xa8995360" lower="(nil)">        find_edge++;<Finish/></txt><txt ptr="0xa891ea38" next="(nil)" prev="0xa891e9a8" upper="0xa8995360" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa8999578" next="0xa8999514" prev="0xa89995dc" upper="0xa891d110" lower="0xa89953c0"><body ptr="0xa89953c0" next="(nil)" prev="(nil)" upper="0xa8999578" lower="0xa891eac8"><txt ptr="0xa891eac8" next="0xa891eb58" prev="(nil)" upper="0xa89953c0" lower="(nil)">        if(find_edge+1 == n)break;<Finish/></txt><txt ptr="0xa891eb58" next="0xa891ebe8" prev="0xa891eac8" upper="0xa89953c0" lower="(nil)"><Finish/></txt><txt ptr="0xa891ebe8" next="0xa891ec78" prev="0xa891eb58" upper="0xa89953c0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa891ec78" next="0xa891ed08" prev="0xa891ebe8" upper="0xa89953c0" lower="(nil)">    return w;<Finish/></txt><txt ptr="0xa891ed08" next="0xa891ed98" prev="0xa891ec78" upper="0xa89953c0" lower="(nil)">}<Finish/></txt><txt ptr="0xa891ed98" next="0xa891ee28" prev="0xa891ed08" upper="0xa89953c0" lower="(nil)"><Finish/></txt><txt ptr="0xa891ee28" next="0xa891eeb8" prev="0xa891ed98" upper="0xa89953c0" lower="(nil)">Prim算法<Finish/></txt><txt ptr="0xa891eeb8" next="0xa891ef48" prev="0xa891ee28" upper="0xa89953c0" lower="(nil)">const int N=1000;<Finish/></txt><txt ptr="0xa891ef48" next="0xa89212ec" prev="0xa891eeb8" upper="0xa89953c0" lower="(nil)">const int inf = 0x3fffffff;<Finish/></txt><txt ptr="0xa89212ec" next="0xa892137c" prev="0xa891ef48" upper="0xa89953c0" lower="(nil)">int vis[N], lowc[N];<Finish/></txt><txt ptr="0xa892137c" next="0xa892140c" prev="0xa89212ec" upper="0xa89953c0" lower="(nil)"><Finish/></txt><txt ptr="0xa892140c" next="0xa892149c" prev="0xa892137c" upper="0xa89953c0" lower="(nil)">int prim(int cost[][N], int n,int st){<Finish/></txt><txt ptr="0xa892149c" next="0xa892152c" prev="0xa892140c" upper="0xa89953c0" lower="(nil)">    int minc, res = 0, i, j, pos;<Finish/></txt><txt ptr="0xa892152c" next="0xa89215bc" prev="0xa892149c" upper="0xa89953c0" lower="(nil)">    memset(vis,0,sizeof(vis));<Finish/></txt><txt ptr="0xa89215bc" next="0xa892164c" prev="0xa892152c" upper="0xa89953c0" lower="(nil)">    vis[st] = 1;<Finish/></txt><txt ptr="0xa892164c" next="0xa89216dc" prev="0xa89215bc" upper="0xa89953c0" lower="(nil)">    for(i=0;i&lt;n;i++){<Finish/></txt><txt ptr="0xa89216dc" next="0xa892176c" prev="0xa892164c" upper="0xa89953c0" lower="(nil)">        lowc[i] = cost[st][i];<Finish/></txt><txt ptr="0xa892176c" next="0xa89217fc" prev="0xa89216dc" upper="0xa89953c0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89217fc" next="0xa892188c" prev="0xa892176c" upper="0xa89953c0" lower="(nil)">    lowc[st] = inf;<Finish/></txt><txt ptr="0xa892188c" next="0xa892191c" prev="0xa89217fc" upper="0xa89953c0" lower="(nil)"><Finish/></txt><txt ptr="0xa892191c" next="0xa89219ac" prev="0xa892188c" upper="0xa89953c0" lower="(nil)">    for(i = 0; i &lt; n; i++){<Finish/></txt><txt ptr="0xa89219ac" next="0xa8921a3c" prev="0xa892191c" upper="0xa89953c0" lower="(nil)">        minc = inf;<Finish/></txt><txt ptr="0xa8921a3c" next="0xa8921acc" prev="0xa89219ac" upper="0xa89953c0" lower="(nil)">        for(j = 0; j &lt; n; j++){<Finish/></txt><txt ptr="0xa8921acc" next="0xa8921b5c" prev="0xa8921a3c" upper="0xa89953c0" lower="(nil)">            if(vis[j] == 0 &amp;&amp; minc &gt; lowc[j]){<Finish/></txt><txt ptr="0xa8921b5c" next="0xa8921bec" prev="0xa8921acc" upper="0xa89953c0" lower="(nil)">                minc = lowc[j];<Finish/></txt><txt ptr="0xa8921bec" next="0xa8921c7c" prev="0xa8921b5c" upper="0xa89953c0" lower="(nil)">                pos = j;<Finish/></txt><txt ptr="0xa8921c7c" next="0xa8921d0c" prev="0xa8921bec" upper="0xa89953c0" lower="(nil)">            }<Finish/></txt><txt ptr="0xa8921d0c" next="(nil)" prev="0xa8921c7c" upper="0xa89953c0" lower="(nil)">        }<Finish/></txt></body></column><column ptr="0xa8999514" next="(nil)" prev="0xa8999578" upper="0xa891d110" lower="0xa8995420"><body ptr="0xa8995420" next="(nil)" prev="(nil)" upper="0xa8999514" lower="0xa8921d9c"><txt ptr="0xa8921d9c" next="0xa8921e2c" prev="(nil)" upper="0xa8995420" lower="(nil)">        if(inf == minc)return -1;<Finish/></txt><txt ptr="0xa8921e2c" next="0xa8921ebc" prev="0xa8921d9c" upper="0xa8995420" lower="(nil)">        res += minc;<Finish/></txt><txt ptr="0xa8921ebc" next="0xa8921f4c" prev="0xa8921e2c" upper="0xa8995420" lower="(nil)">        vis[pos] = 1;<Finish/></txt><txt ptr="0xa8921f4c" next="0xa8922020" prev="0xa8921ebc" upper="0xa8995420" lower="(nil)">        for(j = 0; j &lt; n; j++){<Finish/></txt><txt ptr="0xa8922020" next="0xa89220b0" prev="0xa8921f4c" upper="0xa8995420" lower="(nil)">            if(vis[j] == 0 &amp;&amp; lowc[j] &gt; cost[pos][j]){<Finish/></txt><txt ptr="0xa89220b0" next="0xa8922140" prev="0xa8922020" upper="0xa8995420" lower="(nil)">                lowc[j] = cost[pos][j];<Finish/></txt><txt ptr="0xa8922140" next="0xa89221d0" prev="0xa89220b0" upper="0xa8995420" lower="(nil)">            }<Finish/></txt><txt ptr="0xa89221d0" next="0xa8922260" prev="0xa8922140" upper="0xa8995420" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8922260" next="0xa89222f0" prev="0xa89221d0" upper="0xa8995420" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89222f0" next="0xa8922380" prev="0xa8922260" upper="0xa8995420" lower="(nil)">    return res;<Finish/></txt><txt ptr="0xa8922380" next="0xa8922410" prev="0xa89222f0" upper="0xa8995420" lower="(nil)">}<Finish/></txt><txt ptr="0xa8922410" next="0xa89224a0" prev="0xa8922380" upper="0xa8995420" lower="(nil)">欧拉图<Finish/></txt><txt ptr="0xa89224a0" next="0xa8922530" prev="0xa8922410" upper="0xa8995420" lower="(nil)"><Finish/></txt><txt ptr="0xa8922530" next="0xa8922890" prev="0xa89224a0" upper="0xa8995420" lower="(nil)">欧拉通路 (欧拉迹):通过图中每条边且只通过一次，并且经过每一顶点的通路。<Finish/></txt><txt ptr="0xa8922890" next="0xa8922920" prev="0xa8922530" upper="0xa8995420" lower="(nil)"><Finish/></txt><txt ptr="0xa8922920" next="0xa89229b0" prev="0xa8922890" upper="0xa8995420" lower="(nil)">欧拉回路 (欧拉闭迹):通过图中每条边且只通过一次，并且经过每一顶点的回路。<Finish/></txt><txt ptr="0xa89229b0" next="0xa8922a40" prev="0xa8922920" upper="0xa8995420" lower="(nil)"><Finish/></txt><txt ptr="0xa8922a40" next="0xa8922ad0" prev="0xa89229b0" upper="0xa8995420" lower="(nil)">欧拉图:存在欧拉回路的图。<Finish/></txt><txt ptr="0xa8922ad0" next="0xa8922b60" prev="0xa8922a40" upper="0xa8995420" lower="(nil)"><Finish/></txt><txt ptr="0xa8922b60" next="0xa8922bf0" prev="0xa8922ad0" upper="0xa8995420" lower="(nil)">简单说欧拉通路就是首尾不相接，而欧拉回路要求首尾相接。<Finish/></txt><txt ptr="0xa8922bf0" next="0xa8922c80" prev="0xa8922b60" upper="0xa8995420" lower="(nil)"><Finish/></txt><txt ptr="0xa8922c80" next="0xa8922d10" prev="0xa8922bf0" upper="0xa8995420" lower="(nil)">无向图的判定<Finish/></txt><txt ptr="0xa8922d10" next="0xa8922da0" prev="0xa8922c80" upper="0xa8995420" lower="(nil)"><Finish/></txt><txt ptr="0xa8922da0" next="(nil)" prev="0xa8922d10" upper="0xa8995420" lower="(nil)" follow="0xa8931910">欧拉通路:图连通；图中只有2个度为奇数的节点(就是欧拉通路的2个端点)<Finish/></txt></body></column></section></body><footer ptr="0xa9986064" next="(nil)" prev="0xa9983310" upper="0xa9996418" lower="0xa99883f4"><txt ptr="0xa99883f4" next="0xa99885a4" prev="(nil)" upper="0xa9986064" lower="(nil)"><anchored><fly ptr="0xa517010" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa9988484"><txt ptr="0xa9988484" next="0xa9988514" prev="(nil)" upper="0xa517010" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa9988514" next="(nil)" prev="0xa9988484" upper="0xa517010" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="4"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="6"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa99885a4" next="(nil)" prev="0xa99883f4" upper="0xa9986064" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa999648c" next="0xa9996500" prev="0xa9996418" upper="0xb0726b0" lower="0xa99850c4"><header ptr="0xa99850c4" next="0xa9983490" prev="(nil)" upper="0xa999648c" lower="0xa9989908"><txt ptr="0xa9989908" next="(nil)" prev="(nil)" upper="0xa99850c4" lower="(nil)"><Finish/></txt></header><body ptr="0xa9983490" next="0xa99860c4" prev="0xa99850c4" upper="0xa999648c" lower="0xa891d610"><section ptr="0xa891d610" next="(nil)" prev="(nil)" upper="0xa9983490" lower="0xa6c054ec" follow="0xa891d010" precede="0xa891d110"><column ptr="0xa6c054ec" next="0xa6c05550" prev="(nil)" upper="0xa891d610" lower="0xa6c06314"><body ptr="0xa6c06314" next="(nil)" prev="(nil)" upper="0xa6c054ec" lower="0xa8931910"><txt ptr="0xa8931910" next="0xa8922e30" prev="(nil)" upper="0xa6c06314" lower="(nil)" precede="0xa8922da0">欧拉通路:图连通；图中只有2个度为奇数的节点(就是欧拉通路的2个端点)<Finish/></txt><txt ptr="0xa8922e30" next="0xa8922ec0" prev="0xa8931910" upper="0xa6c06314" lower="(nil)"><Finish/></txt><txt ptr="0xa8922ec0" next="0xa8922f50" prev="0xa8922e30" upper="0xa6c06314" lower="(nil)">欧拉回路:图连通；图中所有节点度均为偶数<Finish/></txt><txt ptr="0xa8922f50" next="0xa8924024" prev="0xa8922ec0" upper="0xa6c06314" lower="(nil)"><Finish/></txt><txt ptr="0xa8924024" next="0xa89240b4" prev="0xa8922f50" upper="0xa6c06314" lower="(nil)">有向图的判定<Finish/></txt><txt ptr="0xa89240b4" next="0xa8924144" prev="0xa8924024" upper="0xa6c06314" lower="(nil)"><Finish/></txt><txt ptr="0xa8924144" next="0xa89241d4" prev="0xa89240b4" upper="0xa6c06314" lower="(nil)">欧拉通路:图连通；除2个端点外其余节点入度=出度；1个端点入度比出度大1；一个端点入度比出度小1<Finish/></txt><txt ptr="0xa89241d4" next="0xa8924264" prev="0xa8924144" upper="0xa6c06314" lower="(nil)"><Finish/></txt><txt ptr="0xa8924264" next="0xa89242f4" prev="0xa89241d4" upper="0xa6c06314" lower="(nil)">欧拉回路:图连通；所有节点入度=出度<Finish/></txt><txt ptr="0xa89242f4" next="0xa8924384" prev="0xa8924264" upper="0xa6c06314" lower="(nil)">网络流<Finish/></txt><txt ptr="0xa8924384" next="0xa8924414" prev="0xa89242f4" upper="0xa6c06314" lower="(nil)">const int N = 100;<Finish/></txt><txt ptr="0xa8924414" next="0xa89244a4" prev="0xa8924384" upper="0xa6c06314" lower="(nil)">const int E = 1000;<Finish/></txt><txt ptr="0xa89244a4" next="0xa8924534" prev="0xa8924414" upper="0xa6c06314" lower="(nil)">#define typec int // type of cost<Finish/></txt><txt ptr="0xa8924534" next="0xa89245c4" prev="0xa89244a4" upper="0xa6c06314" lower="(nil)">const typec inf = 0x3f3f3f3f; // max of cost<Finish/></txt><txt ptr="0xa89245c4" next="0xa8924654" prev="0xa8924534" upper="0xa6c06314" lower="(nil)">struct edge {<Finish/></txt><txt ptr="0xa8924654" next="0xa89246e4" prev="0xa89245c4" upper="0xa6c06314" lower="(nil)">    int x, y, nxt;<Finish/></txt><txt ptr="0xa89246e4" next="0xa8924774" prev="0xa8924654" upper="0xa6c06314" lower="(nil)">    typec c;<Finish/></txt><txt ptr="0xa8924774" next="0xa8924804" prev="0xa89246e4" upper="0xa6c06314" lower="(nil)">} bf[E];<Finish/></txt><txt ptr="0xa8924804" next="0xa8924894" prev="0xa8924774" upper="0xa6c06314" lower="(nil)">int ne, head[N], cur[N], ps[N], dep[N];<Finish/></txt><txt ptr="0xa8924894" next="0xa8924924" prev="0xa8924804" upper="0xa6c06314" lower="(nil)">void init(){<Finish/></txt><txt ptr="0xa8924924" next="0xa89249b4" prev="0xa8924894" upper="0xa6c06314" lower="(nil)">    ne = 2;<Finish/></txt><txt ptr="0xa89249b4" next="0xa8924a44" prev="0xa8924924" upper="0xa6c06314" lower="(nil)">    memset(head,0,sizeof(head));<Finish/></txt><txt ptr="0xa8924a44" next="0xa8924ad4" prev="0xa89249b4" upper="0xa6c06314" lower="(nil)">}<Finish/></txt><txt ptr="0xa8924ad4" next="0xa8924e34" prev="0xa8924a44" upper="0xa6c06314" lower="(nil)">void addedge(int x, int y, typec c) {<Finish/></txt><txt ptr="0xa8924e34" next="0xa8924ec4" prev="0xa8924ad4" upper="0xa6c06314" lower="(nil)">//无向图需调用两次addedge<Finish/></txt><txt ptr="0xa8924ec4" next="(nil)" prev="0xa8924e34" upper="0xa6c06314" lower="(nil)">    // add an arc(x -&gt; y, c); vertex: 0 ~ n-1;<Finish/></txt></body></column><column ptr="0xa6c05550" next="0xa6c055b4" prev="0xa6c054ec" upper="0xa891d610" lower="0xa6c06374"><body ptr="0xa6c06374" next="(nil)" prev="(nil)" upper="0xa6c05550" lower="0xa8924f54"><txt ptr="0xa8924f54" next="0xa8925028" prev="(nil)" upper="0xa6c06374" lower="(nil)">    bf[ne].x = x;<Finish/></txt><txt ptr="0xa8925028" next="0xa89250b8" prev="0xa8924f54" upper="0xa6c06374" lower="(nil)">    bf[ne].y = y;<Finish/></txt><txt ptr="0xa89250b8" next="0xa8925148" prev="0xa8925028" upper="0xa6c06374" lower="(nil)">    bf[ne].c = c;<Finish/></txt><txt ptr="0xa8925148" next="0xa89251d8" prev="0xa89250b8" upper="0xa6c06374" lower="(nil)">    bf[ne].nxt = head[x];<Finish/></txt><txt ptr="0xa89251d8" next="0xa8925268" prev="0xa8925148" upper="0xa6c06374" lower="(nil)">    head[x] = ne++;<Finish/></txt><txt ptr="0xa8925268" next="0xa89252f8" prev="0xa89251d8" upper="0xa6c06374" lower="(nil)">    bf[ne].x = y;<Finish/></txt><txt ptr="0xa89252f8" next="0xa8925388" prev="0xa8925268" upper="0xa6c06374" lower="(nil)">    bf[ne].y = x;<Finish/></txt><txt ptr="0xa8925388" next="0xa8925418" prev="0xa89252f8" upper="0xa6c06374" lower="(nil)">    bf[ne].c = 0;<Finish/></txt><txt ptr="0xa8925418" next="0xa89254a8" prev="0xa8925388" upper="0xa6c06374" lower="(nil)">    bf[ne].nxt = head[y];<Finish/></txt><txt ptr="0xa89254a8" next="0xa8925538" prev="0xa8925418" upper="0xa6c06374" lower="(nil)">    head[y] = ne++;<Finish/></txt><txt ptr="0xa8925538" next="0xa89255c8" prev="0xa89254a8" upper="0xa6c06374" lower="(nil)">}<Finish/></txt><txt ptr="0xa89255c8" next="0xa8925658" prev="0xa8925538" upper="0xa6c06374" lower="(nil)">typec flow(int n, int s, int t) {<Finish/></txt><txt ptr="0xa8925658" next="0xa89256e8" prev="0xa89255c8" upper="0xa6c06374" lower="(nil)">    typec tr, res = 0;<Finish/></txt><txt ptr="0xa89256e8" next="0xa8925778" prev="0xa8925658" upper="0xa6c06374" lower="(nil)">    int i, j, k, f, r, top;<Finish/></txt><txt ptr="0xa8925778" next="0xa8925808" prev="0xa89256e8" upper="0xa6c06374" lower="(nil)">    while (1) {<Finish/></txt><txt ptr="0xa8925808" next="0xa8925898" prev="0xa8925778" upper="0xa6c06374" lower="(nil)">        memset(dep, -1, n * sizeof(int));<Finish/></txt><txt ptr="0xa8925898" next="0xa8925928" prev="0xa8925808" upper="0xa6c06374" lower="(nil)">        for (f = dep[ps[0] = s] = 0, r = 1; f != r; )<Finish/></txt><txt ptr="0xa8925928" next="0xa89259b8" prev="0xa8925898" upper="0xa6c06374" lower="(nil)">          for (i = ps[f++], j = head[i]; j; j = bf[j].nxt) {<Finish/></txt><txt ptr="0xa89259b8" next="0xa8925a48" prev="0xa8925928" upper="0xa6c06374" lower="(nil)">               if (bf[j].c &amp;&amp; -1 == dep[k = bf[j].y]) {<Finish/></txt><txt ptr="0xa8925a48" next="0xa8925ad8" prev="0xa89259b8" upper="0xa6c06374" lower="(nil)">                    dep[k] = dep[i] + 1;<Finish/></txt><txt ptr="0xa8925ad8" next="0xa8925b68" prev="0xa8925a48" upper="0xa6c06374" lower="(nil)">                    ps[r++] = k;<Finish/></txt><txt ptr="0xa8925b68" next="0xa8925bf8" prev="0xa8925ad8" upper="0xa6c06374" lower="(nil)">                    if (k == t) {<Finish/></txt><txt ptr="0xa8925bf8" next="0xa8925c88" prev="0xa8925b68" upper="0xa6c06374" lower="(nil)">                        f = r;<Finish/></txt><txt ptr="0xa8925c88" next="0xa8925d18" prev="0xa8925bf8" upper="0xa6c06374" lower="(nil)">                        break;<Finish/></txt><txt ptr="0xa8925d18" next="0xa8925da8" prev="0xa8925c88" upper="0xa6c06374" lower="(nil)">                    }<Finish/></txt><txt ptr="0xa8925da8" next="0xa8925e38" prev="0xa8925d18" upper="0xa6c06374" lower="(nil)">                }<Finish/></txt><txt ptr="0xa8925e38" next="0xa8925ec8" prev="0xa8925da8" upper="0xa6c06374" lower="(nil)">            }<Finish/></txt><txt ptr="0xa8925ec8" next="(nil)" prev="0xa8925e38" upper="0xa6c06374" lower="(nil)">        if (-1 == dep[t]) break;<Finish/></txt></body></column><column ptr="0xa6c055b4" next="(nil)" prev="0xa6c05550" upper="0xa891d610" lower="0xa6c063d4"><body ptr="0xa6c063d4" next="(nil)" prev="(nil)" upper="0xa6c055b4" lower="0xa8925f58"><txt ptr="0xa8925f58" next="0xa8926000" prev="(nil)" upper="0xa6c063d4" lower="(nil)">        memcpy(cur, head, n * sizeof(int));<Finish/></txt><txt ptr="0xa8926000" next="0xa8926090" prev="0xa8925f58" upper="0xa6c063d4" lower="(nil)">        for (i = s, top = 0; ; ) {<Finish/></txt><txt ptr="0xa8926090" next="0xa89263f0" prev="0xa8926000" upper="0xa6c063d4" lower="(nil)">            if (i == t) {<Finish/></txt><txt ptr="0xa89263f0" next="0xa8926480" prev="0xa8926090" upper="0xa6c063d4" lower="(nil)">                for (k = 0, tr = inf; k &lt; top; ++k)<Finish/></txt><txt ptr="0xa8926480" next="0xa8926510" prev="0xa89263f0" upper="0xa6c063d4" lower="(nil)">                    if (bf[ps[k]].c &lt; tr)<Finish/></txt><txt ptr="0xa8926510" next="0xa89265a0" prev="0xa8926480" upper="0xa6c063d4" lower="(nil)">                        tr = bf[ps[f = k]].c;<Finish/></txt><txt ptr="0xa89265a0" next="0xa8926630" prev="0xa8926510" upper="0xa6c063d4" lower="(nil)">                for (k = 0; k &lt; top; ++k)<Finish/></txt><txt ptr="0xa8926630" next="0xa89266c0" prev="0xa89265a0" upper="0xa6c063d4" lower="(nil)">                 bf[ps[k]].c -= tr, bf[ps[k]^1].c += tr;<Finish/></txt><txt ptr="0xa89266c0" next="0xa8926750" prev="0xa8926630" upper="0xa6c063d4" lower="(nil)">                res += tr;<Finish/></txt><txt ptr="0xa8926750" next="0xa89267e0" prev="0xa89266c0" upper="0xa6c063d4" lower="(nil)">                i = bf[ps[top = f]].x;<Finish/></txt><txt ptr="0xa89267e0" next="0xa8926870" prev="0xa8926750" upper="0xa6c063d4" lower="(nil)">            }<Finish/></txt><txt ptr="0xa8926870" next="0xa8926900" prev="0xa89267e0" upper="0xa6c063d4" lower="(nil)">        for (j=cur[i]; cur[i]; j = cur[i] = bf[cur[i]].nxt)<Finish/></txt><txt ptr="0xa8926900" next="0xa8926990" prev="0xa8926870" upper="0xa6c063d4" lower="(nil)">         if (bf[j].c &amp;&amp; dep[i]+1 == dep[bf[j].y]) break;<Finish/></txt><txt ptr="0xa8926990" next="0xa8926a20" prev="0xa8926900" upper="0xa6c063d4" lower="(nil)">            if (cur[i]) {<Finish/></txt><txt ptr="0xa8926a20" next="0xa8926ab0" prev="0xa8926990" upper="0xa6c063d4" lower="(nil)">                ps[top++] = cur[i];<Finish/></txt><txt ptr="0xa8926ab0" next="0xa8926b40" prev="0xa8926a20" upper="0xa6c063d4" lower="(nil)">                i = bf[cur[i]].y;<Finish/></txt><txt ptr="0xa8926b40" next="0xa8926bd0" prev="0xa8926ab0" upper="0xa6c063d4" lower="(nil)">            } else {<Finish/></txt><txt ptr="0xa8926bd0" next="0xa8926c60" prev="0xa8926b40" upper="0xa6c063d4" lower="(nil)">                if (0 == top) break;<Finish/></txt><txt ptr="0xa8926c60" next="0xa8926cf0" prev="0xa8926bd0" upper="0xa6c063d4" lower="(nil)">                dep[i] = -1;<Finish/></txt><txt ptr="0xa8926cf0" next="0xa8926d80" prev="0xa8926c60" upper="0xa6c063d4" lower="(nil)">                i = bf[ps[--top]].x;<Finish/></txt><txt ptr="0xa8926d80" next="0xa8926e10" prev="0xa8926cf0" upper="0xa6c063d4" lower="(nil)">            }<Finish/></txt><txt ptr="0xa8926e10" next="0xa8926ea0" prev="0xa8926d80" upper="0xa6c063d4" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8926ea0" next="0xa8926f30" prev="0xa8926e10" upper="0xa6c063d4" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8926f30" next="0xa8927004" prev="0xa8926ea0" upper="0xa6c063d4" lower="(nil)">    return res;<Finish/></txt><txt ptr="0xa8927004" next="(nil)" prev="0xa8926f30" upper="0xa6c063d4" lower="(nil)">}<Finish/></txt></body></column></section></body><footer ptr="0xa99860c4" next="(nil)" prev="0xa9983490" upper="0xa999648c" lower="0xa9989998"><txt ptr="0xa9989998" next="0xa9989b48" prev="(nil)" upper="0xa99860c4" lower="(nil)"><anchored><fly ptr="0xb74dcb0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa9989a28"><txt ptr="0xa9989a28" next="0xa9989ab8" prev="(nil)" upper="0xb74dcb0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa9989ab8" next="(nil)" prev="0xa9989a28" upper="0xb74dcb0" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="4"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="7"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa9989b48" next="(nil)" prev="0xa9989998" upper="0xa99860c4" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996500" next="0xa9996574" prev="0xa999648c" upper="0xb0726b0" lower="0xa9985124"><header ptr="0xa9985124" next="0xa89899d4" prev="(nil)" upper="0xa9996500" lower="0xa892f2dc"><txt ptr="0xa892f2dc" next="(nil)" prev="(nil)" upper="0xa9985124" lower="(nil)"><Finish/></txt></header><body ptr="0xa89899d4" next="0xa9986124" prev="0xa9985124" upper="0xa9996500" lower="0xa891d010"><section ptr="0xa891d010" next="(nil)" prev="(nil)" upper="0xa89899d4" lower="0xa89994b0" follow="0xa891d590" precede="0xa891d610"><column ptr="0xa89994b0" next="0xa899944c" prev="(nil)" upper="0xa891d010" lower="0xa8989b54"><body ptr="0xa8989b54" next="(nil)" prev="(nil)" upper="0xa89994b0" lower="0xa8927094"><txt ptr="0xa8927094" next="0xa8927124" prev="(nil)" upper="0xa8989b54" lower="(nil)">对于一个给定的度序列，看能不能形成一个简单无向图<Finish/></txt><txt ptr="0xa8927124" next="0xa89271b4" prev="0xa8927094" upper="0xa8989b54" lower="(nil)">    Havel算法的思想简单的说如下：<Finish/></txt><txt ptr="0xa89271b4" next="0xa8927244" prev="0xa8927124" upper="0xa8989b54" lower="(nil)">    （1）对序列从大到小进行排序。<Finish/></txt><txt ptr="0xa8927244" next="0xa89272d4" prev="0xa89271b4" upper="0xa8989b54" lower="(nil)">    （2）设最大的度数为 t ，把最大的度数置0，然后把最大度数后（不包括自己）的 t 个度数分别减1（意思就是把度数最大的点与后几个点进行连接）<Finish/></txt><txt ptr="0xa89272d4" next="0xa8927364" prev="0xa8927244" upper="0xa8989b54" lower="(nil)">    （3）如果序列中出现了负数，证明无法构成。如果序列全部变为0，证明能构成，跳出循环。前两点不出现，就跳回第一步！<Finish/></txt><txt ptr="0xa8927364" next="0xa89273f4" prev="0xa89272d4" upper="0xa8989b54" lower="(nil)"><Finish/></txt><txt ptr="0xa89273f4" next="0xa8927484" prev="0xa8927364" upper="0xa8989b54" lower="(nil)">最大团<Finish/></txt><txt ptr="0xa8927484" next="0xa8927514" prev="0xa89273f4" upper="0xa8989b54" lower="(nil)">const int V = 1000;<Finish/></txt><txt ptr="0xa8927514" next="0xa89275a4" prev="0xa8927484" upper="0xa8989b54" lower="(nil)">int g[V][V], dp[V], stk[V][V], mx;<Finish/></txt><txt ptr="0xa89275a4" next="0xa8927634" prev="0xa8927514" upper="0xa8989b54" lower="(nil)">int dfs(int n, int ns, int dep) {<Finish/></txt><txt ptr="0xa8927634" next="0xa8927994" prev="0xa89275a4" upper="0xa8989b54" lower="(nil)">    if (0 == ns) {<Finish/></txt><txt ptr="0xa8927994" next="0xa8927a24" prev="0xa8927634" upper="0xa8989b54" lower="(nil)">        if (dep &gt; mx) mx = dep;<Finish/></txt><txt ptr="0xa8927a24" next="0xa8927ab4" prev="0xa8927994" upper="0xa8989b54" lower="(nil)">        return 1;<Finish/></txt><txt ptr="0xa8927ab4" next="0xa8927b44" prev="0xa8927a24" upper="0xa8989b54" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8927b44" next="0xa8927bd4" prev="0xa8927ab4" upper="0xa8989b54" lower="(nil)">    int i, j, k, p, cnt;<Finish/></txt><txt ptr="0xa8927bd4" next="0xa8927c64" prev="0xa8927b44" upper="0xa8989b54" lower="(nil)">    for (i = 0; i &lt; ns; i++) {<Finish/></txt><txt ptr="0xa8927c64" next="0xa8927cf4" prev="0xa8927bd4" upper="0xa8989b54" lower="(nil)">        k = stk[dep][i];<Finish/></txt><txt ptr="0xa8927cf4" next="0xa8927d84" prev="0xa8927c64" upper="0xa8989b54" lower="(nil)">        cnt = 0;<Finish/></txt><txt ptr="0xa8927d84" next="0xa8927e14" prev="0xa8927cf4" upper="0xa8989b54" lower="(nil)">        if (dep + n - k &lt;= mx) return 0;<Finish/></txt><txt ptr="0xa8927e14" next="(nil)" prev="0xa8927d84" upper="0xa8989b54" lower="(nil)">        if (dep + dp[k] &lt;= mx) return 0;<Finish/></txt></body></column><column ptr="0xa899944c" next="0xa89993e8" prev="0xa89994b0" upper="0xa891d010" lower="0xa8989cd4"><body ptr="0xa8989cd4" next="(nil)" prev="(nil)" upper="0xa899944c" lower="0xa8927ea4"><txt ptr="0xa8927ea4" next="0xa8927f34" prev="(nil)" upper="0xa8989cd4" lower="(nil)">        for (j = i + 1; j &lt; ns; j++) {<Finish/></txt><txt ptr="0xa8927f34" next="0xa8928008" prev="0xa8927ea4" upper="0xa8989cd4" lower="(nil)">            p = stk[dep][j];<Finish/></txt><txt ptr="0xa8928008" next="0xa8928098" prev="0xa8927f34" upper="0xa8989cd4" lower="(nil)">            if (g[k][p]) stk[dep + 1][cnt++] = p;<Finish/></txt><txt ptr="0xa8928098" next="0xa8928128" prev="0xa8928008" upper="0xa8989cd4" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8928128" next="0xa89281b8" prev="0xa8928098" upper="0xa8989cd4" lower="(nil)">        dfs(n, cnt, dep + 1);<Finish/></txt><txt ptr="0xa89281b8" next="0xa8928248" prev="0xa8928128" upper="0xa8989cd4" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8928248" next="0xa89282d8" prev="0xa89281b8" upper="0xa8989cd4" lower="(nil)">    return 1;<Finish/></txt><txt ptr="0xa89282d8" next="0xa8928368" prev="0xa8928248" upper="0xa8989cd4" lower="(nil)">}<Finish/></txt><txt ptr="0xa8928368" next="0xa89283f8" prev="0xa89282d8" upper="0xa8989cd4" lower="(nil)">int clique(int n) {<Finish/></txt><txt ptr="0xa89283f8" next="0xa8928488" prev="0xa8928368" upper="0xa8989cd4" lower="(nil)">    int i, j, ns;<Finish/></txt><txt ptr="0xa8928488" next="0xa8928518" prev="0xa89283f8" upper="0xa8989cd4" lower="(nil)">    for (mx = 0, i = n - 1; i &gt;= 0; i--) {<Finish/></txt><txt ptr="0xa8928518" next="0xa89285a8" prev="0xa8928488" upper="0xa8989cd4" lower="(nil)">        for (ns = 0, j = i + 1; j &lt; n; j++)<Finish/></txt><txt ptr="0xa89285a8" next="0xa8928638" prev="0xa8928518" upper="0xa8989cd4" lower="(nil)">            if (g[i][j]) stk[1][ ns++ ] = j;<Finish/></txt><txt ptr="0xa8928638" next="0xa89286c8" prev="0xa89285a8" upper="0xa8989cd4" lower="(nil)">        dfs(n, ns, 1);<Finish/></txt><txt ptr="0xa89286c8" next="0xa8928758" prev="0xa8928638" upper="0xa8989cd4" lower="(nil)">        dp[i] = mx;<Finish/></txt><txt ptr="0xa8928758" next="0xa89287e8" prev="0xa89286c8" upper="0xa8989cd4" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89287e8" next="0xa8928878" prev="0xa8928758" upper="0xa8989cd4" lower="(nil)">    return mx;<Finish/></txt><txt ptr="0xa8928878" next="0xa8928908" prev="0xa89287e8" upper="0xa8989cd4" lower="(nil)">}<Finish/></txt><txt ptr="0xa8928908" next="0xa8928998" prev="0xa8928878" upper="0xa8989cd4" lower="(nil)">次小生成树<Finish/></txt><txt ptr="0xa8928998" next="0xa8928a28" prev="0xa8928908" upper="0xa8989cd4" lower="(nil)">#include &lt;iostream&gt;<Finish/></txt><txt ptr="0xa8928a28" next="0xa8928ab8" prev="0xa8928998" upper="0xa8989cd4" lower="(nil)">#include &lt;cstdio&gt;<Finish/></txt><txt ptr="0xa8928ab8" next="0xa8928b48" prev="0xa8928a28" upper="0xa8989cd4" lower="(nil)">#include &lt;cstdlib&gt;<Finish/></txt><txt ptr="0xa8928b48" next="0xa8928bd8" prev="0xa8928ab8" upper="0xa8989cd4" lower="(nil)">#include &lt;cmath&gt;<Finish/></txt><txt ptr="0xa8928bd8" next="0xa8928f38" prev="0xa8928b48" upper="0xa8989cd4" lower="(nil)">#include &lt;cstring&gt;<Finish/></txt><txt ptr="0xa8928f38" next="(nil)" prev="0xa8928bd8" upper="0xa8989cd4" lower="(nil)">const int MAXN=501,MAXM=MAXN*MAXN*4,INF=0x7FFFFFFF;<Finish/></txt></body></column><column ptr="0xa89993e8" next="(nil)" prev="0xa899944c" upper="0xa891d010" lower="0xa6c062b4"><body ptr="0xa6c062b4" next="(nil)" prev="(nil)" upper="0xa89993e8" lower="0xa892900c"><txt ptr="0xa892900c" next="0xa892909c" prev="(nil)" upper="0xa6c062b4" lower="(nil)">using namespace std;<Finish/></txt><txt ptr="0xa892909c" next="0xa892912c" prev="0xa892900c" upper="0xa6c062b4" lower="(nil)">struct edge {<Finish/></txt><txt ptr="0xa892912c" next="0xa89291bc" prev="0xa892909c" upper="0xa6c062b4" lower="(nil)">    edge *next,*op;<Finish/></txt><txt ptr="0xa89291bc" next="0xa892924c" prev="0xa892912c" upper="0xa6c062b4" lower="(nil)">    int t,c;<Finish/></txt><txt ptr="0xa892924c" next="0xa89292dc" prev="0xa89291bc" upper="0xa6c062b4" lower="(nil)">    bool mst;<Finish/></txt><txt ptr="0xa89292dc" next="0xa892936c" prev="0xa892924c" upper="0xa6c062b4" lower="(nil)">} ES[MAXM],*V[MAXN],*MST[MAXN],*CLS[MAXN];<Finish/></txt><txt ptr="0xa892936c" next="0xa89293fc" prev="0xa89292dc" upper="0xa6c062b4" lower="(nil)">int N,M,EC=-1,MinST,Ans,NMST;<Finish/></txt><txt ptr="0xa89293fc" next="0xa892948c" prev="0xa892936c" upper="0xa6c062b4" lower="(nil)">int DM[MAXN],F[MAXN];<Finish/></txt><txt ptr="0xa892948c" next="0xa892951c" prev="0xa89293fc" upper="0xa6c062b4" lower="(nil)">inline void addedge(edge **V,int a,int b,int c) {<Finish/></txt><txt ptr="0xa892951c" next="0xa89295ac" prev="0xa892948c" upper="0xa6c062b4" lower="(nil)">    ES[++EC].next=V[a];<Finish/></txt><txt ptr="0xa89295ac" next="0xa892963c" prev="0xa892951c" upper="0xa6c062b4" lower="(nil)">    V[a]=ES+EC;<Finish/></txt><txt ptr="0xa892963c" next="0xa89296cc" prev="0xa89295ac" upper="0xa6c062b4" lower="(nil)">    V[a]-&gt;t=b;<Finish/></txt><txt ptr="0xa89296cc" next="0xa892975c" prev="0xa892963c" upper="0xa6c062b4" lower="(nil)">    V[a]-&gt;c=c;<Finish/></txt><txt ptr="0xa892975c" next="0xa89297ec" prev="0xa89296cc" upper="0xa6c062b4" lower="(nil)">    ES[++EC].next=V[b];<Finish/></txt><txt ptr="0xa89297ec" next="0xa892987c" prev="0xa892975c" upper="0xa6c062b4" lower="(nil)">    V[b]=ES+EC;<Finish/></txt><txt ptr="0xa892987c" next="0xa892990c" prev="0xa89297ec" upper="0xa6c062b4" lower="(nil)">    V[b]-&gt;t=a;<Finish/></txt><txt ptr="0xa892990c" next="0xa892999c" prev="0xa892987c" upper="0xa6c062b4" lower="(nil)">    V[b]-&gt;c=c;<Finish/></txt><txt ptr="0xa892999c" next="0xa8929a2c" prev="0xa892990c" upper="0xa6c062b4" lower="(nil)">    V[a]-&gt;op=V[b];<Finish/></txt><txt ptr="0xa8929a2c" next="0xa8929abc" prev="0xa892999c" upper="0xa6c062b4" lower="(nil)">    V[b]-&gt;op=V[a];<Finish/></txt><txt ptr="0xa8929abc" next="0xa8929b4c" prev="0xa8929a2c" upper="0xa6c062b4" lower="(nil)">    V[a]-&gt;mst=V[b]-&gt;mst=false;<Finish/></txt><txt ptr="0xa8929b4c" next="0xa8929bdc" prev="0xa8929abc" upper="0xa6c062b4" lower="(nil)">}<Finish/></txt><txt ptr="0xa8929bdc" next="0xa8929c6c" prev="0xa8929b4c" upper="0xa6c062b4" lower="(nil)">void init() {<Finish/></txt><txt ptr="0xa8929c6c" next="0xa8929cfc" prev="0xa8929bdc" upper="0xa6c062b4" lower="(nil)">    int i,a,b,c;<Finish/></txt><txt ptr="0xa8929cfc" next="0xa8929d8c" prev="0xa8929c6c" upper="0xa6c062b4" lower="(nil)">    freopen(&quot;conf.in&quot;,&quot;r&quot;,stdin);<Finish/></txt><txt ptr="0xa8929d8c" next="0xa8929e1c" prev="0xa8929cfc" upper="0xa6c062b4" lower="(nil)">    freopen(&quot;conf.out&quot;,&quot;w&quot;,stdout);<Finish/></txt><txt ptr="0xa8929e1c" next="(nil)" prev="0xa8929d8c" upper="0xa6c062b4" lower="(nil)">    scanf(&quot;%d%d&quot;,&amp;N,&amp;M);<Finish/></txt></body></column></section></body><footer ptr="0xa9986124" next="(nil)" prev="0xa89899d4" upper="0xa9996500" lower="0xa892f24c"><txt ptr="0xa892f24c" next="0xa8931880" prev="(nil)" upper="0xa9986124" lower="(nil)"><anchored><fly ptr="0xb6f5008" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa892f12c"><txt ptr="0xa892f12c" next="0xa8931760" prev="(nil)" upper="0xb6f5008" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa8931760" next="(nil)" prev="0xa892f12c" upper="0xb6f5008" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="4"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="8"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa8931880" next="(nil)" prev="0xa892f24c" upper="0xa9986124" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996574" next="0xa99965e8" prev="0xa9996500" upper="0xb0726b0" lower="0xa9985184"><header ptr="0xa9985184" next="0xa6c06254" prev="(nil)" upper="0xa9996574" lower="0xa892f1bc"><txt ptr="0xa892f1bc" next="(nil)" prev="(nil)" upper="0xa9985184" lower="(nil)"><Finish/></txt></header><body ptr="0xa6c06254" next="0xa9986184" prev="0xa9985184" upper="0xa9996574" lower="0xa891d590"><section ptr="0xa891d590" next="(nil)" prev="(nil)" upper="0xa6c06254" lower="0xa6c05488" follow="0xa99bc180" precede="0xa891d010"><column ptr="0xa6c05488" next="0xa6c05424" prev="(nil)" upper="0xa891d590" lower="0xa6c061f4"><body ptr="0xa6c061f4" next="(nil)" prev="(nil)" upper="0xa6c05488" lower="0xa8929eac"><txt ptr="0xa8929eac" next="0xa8929f3c" prev="(nil)" upper="0xa6c061f4" lower="(nil)">    for (i=1; i&lt;=M; i++) {<Finish/></txt><txt ptr="0xa8929f3c" next="0xa892a010" prev="0xa8929eac" upper="0xa6c061f4" lower="(nil)">        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);<Finish/></txt><txt ptr="0xa892a010" next="0xa892a0a0" prev="0xa8929f3c" upper="0xa6c061f4" lower="(nil)">        addedge(V,a,b,c);<Finish/></txt><txt ptr="0xa892a0a0" next="0xa892a130" prev="0xa892a010" upper="0xa6c061f4" lower="(nil)">    }<Finish/></txt><txt ptr="0xa892a130" next="0xa892a1c0" prev="0xa892a0a0" upper="0xa6c061f4" lower="(nil)">    Ans=INF;<Finish/></txt><txt ptr="0xa892a1c0" next="0xa892a520" prev="0xa892a130" upper="0xa6c061f4" lower="(nil)">}<Finish/></txt><txt ptr="0xa892a520" next="0xa892a5b0" prev="0xa892a1c0" upper="0xa6c061f4" lower="(nil)">void prim() {<Finish/></txt><txt ptr="0xa892a5b0" next="0xa892a640" prev="0xa892a520" upper="0xa6c061f4" lower="(nil)">    int i,j,Mini;<Finish/></txt><txt ptr="0xa892a640" next="0xa892a6d0" prev="0xa892a5b0" upper="0xa6c061f4" lower="(nil)">    for (i=1; i&lt;=N; i++)<Finish/></txt><txt ptr="0xa892a6d0" next="0xa892a760" prev="0xa892a640" upper="0xa6c061f4" lower="(nil)">        DM[i]=INF;<Finish/></txt><txt ptr="0xa892a760" next="0xa892a7f0" prev="0xa892a6d0" upper="0xa6c061f4" lower="(nil)">    for (i=1; i;) {<Finish/></txt><txt ptr="0xa892a7f0" next="0xa892a880" prev="0xa892a760" upper="0xa6c061f4" lower="(nil)">        DM[i]=-INF;<Finish/></txt><txt ptr="0xa892a880" next="0xa892a910" prev="0xa892a7f0" upper="0xa6c061f4" lower="(nil)">        for (edge *e=V[i]; e; e=e-&gt;next) {<Finish/></txt><txt ptr="0xa892a910" next="0xa892a9a0" prev="0xa892a880" upper="0xa6c061f4" lower="(nil)">            if (e-&gt;c &lt; DM[j=e-&gt;t]) {<Finish/></txt><txt ptr="0xa892a9a0" next="0xa892aa30" prev="0xa892a910" upper="0xa6c061f4" lower="(nil)">                DM[j]=e-&gt;c;<Finish/></txt><txt ptr="0xa892aa30" next="0xa892aac0" prev="0xa892a9a0" upper="0xa6c061f4" lower="(nil)">                CLS[j]=e-&gt;op;<Finish/></txt><txt ptr="0xa892aac0" next="0xa892ab50" prev="0xa892aa30" upper="0xa6c061f4" lower="(nil)">            }<Finish/></txt><txt ptr="0xa892ab50" next="0xa892abe0" prev="0xa892aac0" upper="0xa6c061f4" lower="(nil)">        }<Finish/></txt><txt ptr="0xa892abe0" next="0xa892ac70" prev="0xa892ab50" upper="0xa6c061f4" lower="(nil)">        Mini=INF;<Finish/></txt><txt ptr="0xa892ac70" next="0xa892ad00" prev="0xa892abe0" upper="0xa6c061f4" lower="(nil)">        i=0;<Finish/></txt><txt ptr="0xa892ad00" next="0xa892ad90" prev="0xa892ac70" upper="0xa6c061f4" lower="(nil)">        for (j=1; j&lt;=N; j++)<Finish/></txt><txt ptr="0xa892ad90" next="0xa892ae20" prev="0xa892ad00" upper="0xa6c061f4" lower="(nil)">            if (DM[j]!=-INF &amp;&amp; DM[j]&lt;Mini) {<Finish/></txt><txt ptr="0xa892ae20" next="0xa892aeb0" prev="0xa892ad90" upper="0xa6c061f4" lower="(nil)">                Mini=DM[j];<Finish/></txt><txt ptr="0xa892aeb0" next="0xa892af40" prev="0xa892ae20" upper="0xa6c061f4" lower="(nil)">                i=j;<Finish/></txt><txt ptr="0xa892af40" next="0xa892b014" prev="0xa892aeb0" upper="0xa6c061f4" lower="(nil)">            }<Finish/></txt><txt ptr="0xa892b014" next="0xa892b0a4" prev="0xa892af40" upper="0xa6c061f4" lower="(nil)">    }<Finish/></txt><txt ptr="0xa892b0a4" next="0xa892b134" prev="0xa892b014" upper="0xa6c061f4" lower="(nil)">    for (i=2; i&lt;=N; i++) {<Finish/></txt><txt ptr="0xa892b134" next="(nil)" prev="0xa892b0a4" upper="0xa6c061f4" lower="(nil)">        MinST+=CLS[i]-&gt;c;<Finish/></txt></body></column><column ptr="0xa6c05424" next="0xa6c053c0" prev="0xa6c05488" upper="0xa891d590" lower="0xa6c06194"><body ptr="0xa6c06194" next="(nil)" prev="(nil)" upper="0xa6c05424" lower="0xa892b1c4"><txt ptr="0xa892b1c4" next="0xa892b254" prev="(nil)" upper="0xa6c06194" lower="(nil)">        CLS[i]-&gt;mst=CLS[i]-&gt;op-&gt;mst=true;<Finish/></txt><txt ptr="0xa892b254" next="0xa892b2e4" prev="0xa892b1c4" upper="0xa6c06194" lower="(nil)">        addedge(MST,CLS[i]-&gt;t,CLS[i]-&gt;op-&gt;t,CLS[i]-&gt;c);<Finish/></txt><txt ptr="0xa892b2e4" next="0xa892b374" prev="0xa892b254" upper="0xa6c06194" lower="(nil)">    }<Finish/></txt><txt ptr="0xa892b374" next="0xa892b404" prev="0xa892b2e4" upper="0xa6c06194" lower="(nil)">}<Finish/></txt><txt ptr="0xa892b404" next="0xa892b494" prev="0xa892b374" upper="0xa6c06194" lower="(nil)">void dfs(int i) {<Finish/></txt><txt ptr="0xa892b494" next="0xa892b524" prev="0xa892b404" upper="0xa6c06194" lower="(nil)">    for (edge *e=MST[i]; e; e=e-&gt;next) {<Finish/></txt><txt ptr="0xa892b524" next="0xa892b5b4" prev="0xa892b494" upper="0xa6c06194" lower="(nil)">        int j=e-&gt;t;<Finish/></txt><txt ptr="0xa892b5b4" next="0xa892b644" prev="0xa892b524" upper="0xa6c06194" lower="(nil)">        if (F[j]==-INF) {<Finish/></txt><txt ptr="0xa892b644" next="0xa892b6d4" prev="0xa892b5b4" upper="0xa6c06194" lower="(nil)">            F[j]=F[i];<Finish/></txt><txt ptr="0xa892b6d4" next="0xa892b764" prev="0xa892b644" upper="0xa6c06194" lower="(nil)">            if (e-&gt;c &gt; F[j])<Finish/></txt><txt ptr="0xa892b764" next="0xa892bac4" prev="0xa892b6d4" upper="0xa6c06194" lower="(nil)">                F[j]=e-&gt;c;<Finish/></txt><txt ptr="0xa892bac4" next="0xa892bb54" prev="0xa892b764" upper="0xa6c06194" lower="(nil)">            dfs(j);<Finish/></txt><txt ptr="0xa892bb54" next="0xa892bbe4" prev="0xa892bac4" upper="0xa6c06194" lower="(nil)">        }<Finish/></txt><txt ptr="0xa892bbe4" next="0xa892bc74" prev="0xa892bb54" upper="0xa6c06194" lower="(nil)">    }<Finish/></txt><txt ptr="0xa892bc74" next="0xa892bd04" prev="0xa892bbe4" upper="0xa6c06194" lower="(nil)">}<Finish/></txt><txt ptr="0xa892bd04" next="0xa892bd94" prev="0xa892bc74" upper="0xa6c06194" lower="(nil)">void smst() {<Finish/></txt><txt ptr="0xa892bd94" next="0xa892be24" prev="0xa892bd04" upper="0xa6c06194" lower="(nil)">    int i,j;<Finish/></txt><txt ptr="0xa892be24" next="0xa892beb4" prev="0xa892bd94" upper="0xa6c06194" lower="(nil)">    for (i=1; i&lt;=N; i++) {<Finish/></txt><txt ptr="0xa892beb4" next="0xa892bf44" prev="0xa892be24" upper="0xa6c06194" lower="(nil)">        for (j=1; j&lt;=N; j++)<Finish/></txt><txt ptr="0xa892bf44" next="0xa892c018" prev="0xa892beb4" upper="0xa6c06194" lower="(nil)">            F[j]=-INF;<Finish/></txt><txt ptr="0xa892c018" next="0xa892c0a8" prev="0xa892bf44" upper="0xa6c06194" lower="(nil)">        F[i]++;<Finish/></txt><txt ptr="0xa892c0a8" next="0xa892c138" prev="0xa892c018" upper="0xa6c06194" lower="(nil)">        dfs(i);<Finish/></txt><txt ptr="0xa892c138" next="0xa892c1c8" prev="0xa892c0a8" upper="0xa6c06194" lower="(nil)">        for (edge *e=V[i]; e; e=e-&gt;next) {<Finish/></txt><txt ptr="0xa892c1c8" next="0xa892c258" prev="0xa892c138" upper="0xa6c06194" lower="(nil)">            if (!e-&gt;mst) {<Finish/></txt><txt ptr="0xa892c258" next="0xa892c2e8" prev="0xa892c1c8" upper="0xa6c06194" lower="(nil)">                NMST=MinST + e-&gt;c -F[e-&gt;t];<Finish/></txt><txt ptr="0xa892c2e8" next="0xa892c378" prev="0xa892c258" upper="0xa6c06194" lower="(nil)">                if (NMST &lt; Ans)<Finish/></txt><txt ptr="0xa892c378" next="0xa892c408" prev="0xa892c2e8" upper="0xa6c06194" lower="(nil)">                    Ans=NMST;<Finish/></txt><txt ptr="0xa892c408" next="(nil)" prev="0xa892c378" upper="0xa6c06194" lower="(nil)">            }<Finish/></txt></body></column><column ptr="0xa6c053c0" next="(nil)" prev="0xa6c05424" upper="0xa891d590" lower="0xa6c06134"><body ptr="0xa6c06134" next="(nil)" prev="(nil)" upper="0xa6c053c0" lower="0xa892c498"><txt ptr="0xa892c498" next="0xa892c528" prev="(nil)" upper="0xa6c06134" lower="(nil)">        }<Finish/></txt><txt ptr="0xa892c528" next="0xa892c5b8" prev="0xa892c498" upper="0xa6c06134" lower="(nil)">    }<Finish/></txt><txt ptr="0xa892c5b8" next="0xa892c648" prev="0xa892c528" upper="0xa6c06134" lower="(nil)">}<Finish/></txt><txt ptr="0xa892c648" next="0xa892c6d8" prev="0xa892c5b8" upper="0xa6c06134" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa892c6d8" next="0xa892c768" prev="0xa892c648" upper="0xa6c06134" lower="(nil)">    init();<Finish/></txt><txt ptr="0xa892c768" next="0xa892c7f8" prev="0xa892c6d8" upper="0xa6c06134" lower="(nil)">    prim();<Finish/></txt><txt ptr="0xa892c7f8" next="0xa892c888" prev="0xa892c768" upper="0xa6c06134" lower="(nil)">    smst();<Finish/></txt><txt ptr="0xa892c888" next="0xa892c918" prev="0xa892c7f8" upper="0xa6c06134" lower="(nil)">    if (Ans==INF)<Finish/></txt><txt ptr="0xa892c918" next="0xa892c9a8" prev="0xa892c888" upper="0xa6c06134" lower="(nil)">        Ans=-1;<Finish/></txt><txt ptr="0xa892c9a8" next="0xa892ca38" prev="0xa892c918" upper="0xa6c06134" lower="(nil)">    printf(&quot;Cost: %d\nCost: %d\n&quot;,MinST,Ans);<Finish/></txt><txt ptr="0xa892ca38" next="0xa892cac8" prev="0xa892c9a8" upper="0xa6c06134" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa892cac8" next="0xa892cb58" prev="0xa892ca38" upper="0xa6c06134" lower="(nil)">}<Finish/></txt><txt ptr="0xa892cb58" next="0xa892cbe8" prev="0xa892cac8" upper="0xa6c06134" lower="(nil)">第K短路<Finish/></txt><txt ptr="0xa892cbe8" next="0xa892cc78" prev="0xa892cb58" upper="0xa6c06134" lower="(nil)">使用A*+djikstra求第k短路。<Finish/></txt><txt ptr="0xa892cc78" next="0xa892cd08" prev="0xa892cbe8" upper="0xa6c06134" lower="(nil)">#include&lt;iostream&gt;<Finish/></txt><txt ptr="0xa892cd08" next="0xa892d0ac" prev="0xa892cc78" upper="0xa6c06134" lower="(nil)">#include&lt;cstdio&gt;<Finish/></txt><txt ptr="0xa892d0ac" next="0xa892d13c" prev="0xa892cd08" upper="0xa6c06134" lower="(nil)">#include&lt;cstring&gt;<Finish/></txt><txt ptr="0xa892d13c" next="0xa892d1cc" prev="0xa892d0ac" upper="0xa6c06134" lower="(nil)">#include&lt;queue&gt;<Finish/></txt><txt ptr="0xa892d1cc" next="0xa892d25c" prev="0xa892d13c" upper="0xa6c06134" lower="(nil)">#define MAXN 1001<Finish/></txt><txt ptr="0xa892d25c" next="0xa892d2ec" prev="0xa892d1cc" upper="0xa6c06134" lower="(nil)">using namespace std;<Finish/></txt><txt ptr="0xa892d2ec" next="0xa892d37c" prev="0xa892d25c" upper="0xa6c06134" lower="(nil)">struct node {<Finish/></txt><txt ptr="0xa892d37c" next="0xa892d40c" prev="0xa892d2ec" upper="0xa6c06134" lower="(nil)">    int p,g,h;<Finish/></txt><txt ptr="0xa892d40c" next="0xa892d49c" prev="0xa892d37c" upper="0xa6c06134" lower="(nil)">    bool operator &lt; (node a) const {<Finish/></txt><txt ptr="0xa892d49c" next="0xa892d52c" prev="0xa892d40c" upper="0xa6c06134" lower="(nil)">        return a.g+a.h&lt;g+h;<Finish/></txt><txt ptr="0xa892d52c" next="0xa892d5bc" prev="0xa892d49c" upper="0xa6c06134" lower="(nil)">    }<Finish/></txt><txt ptr="0xa892d5bc" next="0xa892d64c" prev="0xa892d52c" upper="0xa6c06134" lower="(nil)">};<Finish/></txt><txt ptr="0xa892d64c" next="(nil)" prev="0xa892d5bc" upper="0xa6c06134" lower="(nil)">struct node1 {<Finish/></txt></body></column></section></body><footer ptr="0xa9986184" next="(nil)" prev="0xa6c06254" upper="0xa9996574" lower="0xa89317f0"><txt ptr="0xa89317f0" next="0xa8932d04" prev="(nil)" upper="0xa9986184" lower="(nil)"><anchored><fly ptr="0xa503bd0" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa89316d0"><txt ptr="0xa89316d0" next="0xa8932eb4" prev="(nil)" upper="0xa503bd0" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa8932eb4" next="(nil)" prev="0xa89316d0" upper="0xa503bd0" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="4"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="9"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa8932d04" next="(nil)" prev="0xa89317f0" upper="0xa9986184" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa99965e8" next="0xa999665c" prev="0xa9996574" upper="0xb0726b0" lower="0xa99851e4"><header ptr="0xa99851e4" next="0xa6c060d4" prev="(nil)" upper="0xa99965e8" lower="0xa88eed84"><txt ptr="0xa88eed84" next="(nil)" prev="(nil)" upper="0xa99851e4" lower="(nil)"><Finish/></txt></header><body ptr="0xa6c060d4" next="0xa99861e4" prev="0xa99851e4" upper="0xa99965e8" lower="0xa99bc180"><section ptr="0xa99bc180" next="(nil)" prev="(nil)" upper="0xa6c060d4" lower="0xa6c0535c" follow="0xa99bc300" precede="0xa891d590"><column ptr="0xa6c0535c" next="0xa6c052f8" prev="(nil)" upper="0xa99bc180" lower="0xa6c06074"><body ptr="0xa6c06074" next="(nil)" prev="(nil)" upper="0xa6c0535c" lower="0xa892d6dc"><txt ptr="0xa892d6dc" next="0xa892d76c" prev="(nil)" upper="0xa6c06074" lower="(nil)">    int x,y,w,next;<Finish/></txt><txt ptr="0xa892d76c" next="0xa892d7fc" prev="0xa892d6dc" upper="0xa6c06074" lower="(nil)">} line[MAXN*100],line1[MAXN*100];<Finish/></txt><txt ptr="0xa892d7fc" next="0xa892d88c" prev="0xa892d76c" upper="0xa6c06074" lower="(nil)"><Finish/></txt><txt ptr="0xa892d88c" next="0xa892d91c" prev="0xa892d7fc" upper="0xa6c06074" lower="(nil)"><Finish/></txt><txt ptr="0xa892d91c" next="0xa892d9ac" prev="0xa892d88c" upper="0xa6c06074" lower="(nil)"><Finish/></txt><txt ptr="0xa892d9ac" next="0xa892da3c" prev="0xa892d91c" upper="0xa6c06074" lower="(nil)">int n,m,i,link[MAXN],link1[MAXN],g[MAXN],s,e,k;<Finish/></txt><txt ptr="0xa892da3c" next="0xa892dacc" prev="0xa892d9ac" upper="0xa6c06074" lower="(nil)">bool used[MAXN];<Finish/></txt><txt ptr="0xa892dacc" next="0xa892db5c" prev="0xa892da3c" upper="0xa6c06074" lower="(nil)">priority_queue&lt;node&gt; myqueue;<Finish/></txt><txt ptr="0xa892db5c" next="0xa892dbec" prev="0xa892dacc" upper="0xa6c06074" lower="(nil)">void djikstra() {<Finish/></txt><txt ptr="0xa892dbec" next="0xa892dc7c" prev="0xa892db5c" upper="0xa6c06074" lower="(nil)">    int i,k,p;<Finish/></txt><txt ptr="0xa892dc7c" next="0xa892dd0c" prev="0xa892dbec" upper="0xa6c06074" lower="(nil)">    memset(used,0,sizeof(used));<Finish/></txt><txt ptr="0xa892dd0c" next="0xa892dd9c" prev="0xa892dc7c" upper="0xa6c06074" lower="(nil)">    memset(g,0x7F,sizeof(g));<Finish/></txt><txt ptr="0xa892dd9c" next="0xa892de2c" prev="0xa892dd0c" upper="0xa6c06074" lower="(nil)">    g[e]=0;<Finish/></txt><txt ptr="0xa892de2c" next="0xa892debc" prev="0xa892dd9c" upper="0xa6c06074" lower="(nil)">    for (p=1; p&lt;=n; p++) {<Finish/></txt><txt ptr="0xa892debc" next="0xa892df4c" prev="0xa892de2c" upper="0xa6c06074" lower="(nil)">        k=0;<Finish/></txt><txt ptr="0xa892df4c" next="0xa890e020" prev="0xa892debc" upper="0xa6c06074" lower="(nil)">        for (i=1; i&lt;=n; i++)<Finish/></txt><txt ptr="0xa890e020" next="0xa890e0b0" prev="0xa892df4c" upper="0xa6c06074" lower="(nil)">            if (!used[i] &amp;&amp; (!k || g[i]&lt;g[k]))<Finish/></txt><txt ptr="0xa890e0b0" next="0xa890e140" prev="0xa890e020" upper="0xa6c06074" lower="(nil)">                k=i;<Finish/></txt><txt ptr="0xa890e140" next="0xa890e1d0" prev="0xa890e0b0" upper="0xa6c06074" lower="(nil)">        used[k]=true;<Finish/></txt><txt ptr="0xa890e1d0" next="0xa890e260" prev="0xa890e140" upper="0xa6c06074" lower="(nil)">        k=link1[k];<Finish/></txt><txt ptr="0xa890e260" next="0xa890e2f0" prev="0xa890e1d0" upper="0xa6c06074" lower="(nil)">        while (k) {<Finish/></txt><txt ptr="0xa890e2f0" next="0xa890e650" prev="0xa890e260" upper="0xa6c06074" lower="(nil)">            if (g[line1[k].y]&gt;g[line1[k].x]+line1[k].w)<Finish/></txt><txt ptr="0xa890e650" next="0xa890e6e0" prev="0xa890e2f0" upper="0xa6c06074" lower="(nil)">             g[line1[k].y]=g[line1[k].x]+line1[k].w;<Finish/></txt><txt ptr="0xa890e6e0" next="0xa890e770" prev="0xa890e650" upper="0xa6c06074" lower="(nil)">            k=line1[k].next;<Finish/></txt><txt ptr="0xa890e770" next="0xa890e800" prev="0xa890e6e0" upper="0xa6c06074" lower="(nil)">        }<Finish/></txt><txt ptr="0xa890e800" next="0xa890e890" prev="0xa890e770" upper="0xa6c06074" lower="(nil)">    }<Finish/></txt><txt ptr="0xa890e890" next="0xa890e920" prev="0xa890e800" upper="0xa6c06074" lower="(nil)">    return ;<Finish/></txt><txt ptr="0xa890e920" next="(nil)" prev="0xa890e890" upper="0xa6c06074" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa6c052f8" next="0xa6c05294" prev="0xa6c0535c" upper="0xa99bc180" lower="0xa6c06014"><body ptr="0xa6c06014" next="(nil)" prev="(nil)" upper="0xa6c052f8" lower="0xa890e9b0"><txt ptr="0xa890e9b0" next="0xa890ea40" prev="(nil)" upper="0xa6c06014" lower="(nil)">int Astar() {<Finish/></txt><txt ptr="0xa890ea40" next="0xa890ead0" prev="0xa890e9b0" upper="0xa6c06014" lower="(nil)">    int t,times[MAXN];<Finish/></txt><txt ptr="0xa890ead0" next="0xa890eb60" prev="0xa890ea40" upper="0xa6c06014" lower="(nil)">    node h,temp;<Finish/></txt><txt ptr="0xa890eb60" next="0xa890ebf0" prev="0xa890ead0" upper="0xa6c06014" lower="(nil)">    while (!myqueue.empty()) myqueue.pop();<Finish/></txt><txt ptr="0xa890ebf0" next="0xa890ec80" prev="0xa890eb60" upper="0xa6c06014" lower="(nil)">    memset(times,0,sizeof(times));<Finish/></txt><txt ptr="0xa890ec80" next="0xa890ed10" prev="0xa890ebf0" upper="0xa6c06014" lower="(nil)">    h.p=s;<Finish/></txt><txt ptr="0xa890ed10" next="0xa890eda0" prev="0xa890ec80" upper="0xa6c06014" lower="(nil)">    h.g=0;<Finish/></txt><txt ptr="0xa890eda0" next="0xa890ee30" prev="0xa890ed10" upper="0xa6c06014" lower="(nil)">    h.h=0;<Finish/></txt><txt ptr="0xa890ee30" next="0xa890eec0" prev="0xa890eda0" upper="0xa6c06014" lower="(nil)">    myqueue.push(h);<Finish/></txt><txt ptr="0xa890eec0" next="0xa890ef50" prev="0xa890ee30" upper="0xa6c06014" lower="(nil)">    while (!myqueue.empty()) {<Finish/></txt><txt ptr="0xa890ef50" next="0xa890f024" prev="0xa890eec0" upper="0xa6c06014" lower="(nil)">        h=myqueue.top();<Finish/></txt><txt ptr="0xa890f024" next="0xa890f0b4" prev="0xa890ef50" upper="0xa6c06014" lower="(nil)">        myqueue.pop();<Finish/></txt><txt ptr="0xa890f0b4" next="0xa890f144" prev="0xa890f024" upper="0xa6c06014" lower="(nil)">        times[h.p]++;<Finish/></txt><txt ptr="0xa890f144" next="0xa890f1d4" prev="0xa890f0b4" upper="0xa6c06014" lower="(nil)">        if (times[h.p]==k &amp;&amp; h.p==e) return h.h+h.g;<Finish/></txt><txt ptr="0xa890f1d4" next="0xa890f264" prev="0xa890f144" upper="0xa6c06014" lower="(nil)">        if (times[h.p]&gt;k) continue;<Finish/></txt><txt ptr="0xa890f264" next="0xa890f2f4" prev="0xa890f1d4" upper="0xa6c06014" lower="(nil)">        t=link[h.p];<Finish/></txt><txt ptr="0xa890f2f4" next="0xa890f384" prev="0xa890f264" upper="0xa6c06014" lower="(nil)">        while (t) {<Finish/></txt><txt ptr="0xa890f384" next="0xa890f414" prev="0xa890f2f4" upper="0xa6c06014" lower="(nil)">            temp.h=h.h+line[t].w;<Finish/></txt><txt ptr="0xa890f414" next="0xa890f4a4" prev="0xa890f384" upper="0xa6c06014" lower="(nil)">            temp.g=g[line[t].y];<Finish/></txt><txt ptr="0xa890f4a4" next="0xa890f534" prev="0xa890f414" upper="0xa6c06014" lower="(nil)">            temp.p=line[t].y;<Finish/></txt><txt ptr="0xa890f534" next="0xa890f5c4" prev="0xa890f4a4" upper="0xa6c06014" lower="(nil)">            myqueue.push(temp);<Finish/></txt><txt ptr="0xa890f5c4" next="0xa890f654" prev="0xa890f534" upper="0xa6c06014" lower="(nil)">            t=line[t].next;<Finish/></txt><txt ptr="0xa890f654" next="0xa890f6e4" prev="0xa890f5c4" upper="0xa6c06014" lower="(nil)">        }<Finish/></txt><txt ptr="0xa890f6e4" next="0xa890f774" prev="0xa890f654" upper="0xa6c06014" lower="(nil)">    }<Finish/></txt><txt ptr="0xa890f774" next="0xa890f804" prev="0xa890f6e4" upper="0xa6c06014" lower="(nil)">    return -1;<Finish/></txt><txt ptr="0xa890f804" next="0xa890f894" prev="0xa890f774" upper="0xa6c06014" lower="(nil)">}<Finish/></txt><txt ptr="0xa890f894" next="0xa890fbf4" prev="0xa890f804" upper="0xa6c06014" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa890fbf4" next="(nil)" prev="0xa890f894" upper="0xa6c06014" lower="(nil)">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);<Finish/></txt></body></column><column ptr="0xa6c05294" next="(nil)" prev="0xa6c052f8" upper="0xa99bc180" lower="0xa6c04f70"><body ptr="0xa6c04f70" next="(nil)" prev="(nil)" upper="0xa6c05294" lower="0xa890fc84"><txt ptr="0xa890fc84" next="0xa890fd14" prev="(nil)" upper="0xa6c04f70" lower="(nil)">    memset(link,0,sizeof(link));<Finish/></txt><txt ptr="0xa890fd14" next="0xa890fda4" prev="0xa890fc84" upper="0xa6c04f70" lower="(nil)">    memset(link1,0,sizeof(link1));<Finish/></txt><txt ptr="0xa890fda4" next="0xa890fe34" prev="0xa890fd14" upper="0xa6c04f70" lower="(nil)">    for (i=1; i&lt;=m; i++) {<Finish/></txt><txt ptr="0xa890fe34" next="0xa890fec4" prev="0xa890fda4" upper="0xa6c04f70" lower="(nil)">        scanf(&quot;%d%d%d&quot;,&amp;line[i].x,&amp;line[i].y,&amp;line[i].w);<Finish/></txt><txt ptr="0xa890fec4" next="0xa890ff54" prev="0xa890fe34" upper="0xa6c04f70" lower="(nil)">        line[i].next=link[line[i].x];<Finish/></txt><txt ptr="0xa890ff54" next="0xa8911028" prev="0xa890fec4" upper="0xa6c04f70" lower="(nil)">        link[line[i].x]=i;<Finish/></txt><txt ptr="0xa8911028" next="0xa89110b8" prev="0xa890ff54" upper="0xa6c04f70" lower="(nil)">        line1[i].x=line[i].y;<Finish/></txt><txt ptr="0xa89110b8" next="0xa8911148" prev="0xa8911028" upper="0xa6c04f70" lower="(nil)">        line1[i].y=line[i].x;<Finish/></txt><txt ptr="0xa8911148" next="0xa89111d8" prev="0xa89110b8" upper="0xa6c04f70" lower="(nil)">        line1[i].w=line[i].w;<Finish/></txt><txt ptr="0xa89111d8" next="0xa8911268" prev="0xa8911148" upper="0xa6c04f70" lower="(nil)">        line1[i].next=link1[line1[i].x];<Finish/></txt><txt ptr="0xa8911268" next="0xa89112f8" prev="0xa89111d8" upper="0xa6c04f70" lower="(nil)">        link1[line1[i].x]=i;<Finish/></txt><txt ptr="0xa89112f8" next="0xa8911388" prev="0xa8911268" upper="0xa6c04f70" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8911388" next="0xa8911418" prev="0xa89112f8" upper="0xa6c04f70" lower="(nil)">    scanf(&quot;%d%d%d&quot;,&amp;s,&amp;e,&amp;k);<Finish/></txt><txt ptr="0xa8911418" next="0xa89114a8" prev="0xa8911388" upper="0xa6c04f70" lower="(nil)">    if (s==e) k++;<Finish/></txt><txt ptr="0xa89114a8" next="0xa8911538" prev="0xa8911418" upper="0xa6c04f70" lower="(nil)">    djikstra();<Finish/></txt><txt ptr="0xa8911538" next="0xa89115c8" prev="0xa89114a8" upper="0xa6c04f70" lower="(nil)">    printf(&quot;%d\n&quot;,Astar());<Finish/></txt><txt ptr="0xa89115c8" next="0xa8911658" prev="0xa8911538" upper="0xa6c04f70" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa8911658" next="0xa89116e8" prev="0xa89115c8" upper="0xa6c04f70" lower="(nil)">}<Finish/></txt><txt ptr="0xa89116e8" next="0xa8911778" prev="0xa8911658" upper="0xa6c04f70" lower="(nil)">查分约束<Finish/></txt><txt ptr="0xa8911778" next="0xa8911808" prev="0xa89116e8" upper="0xa6c04f70" lower="(nil)">如果一个系统由n个变量和m个不等式组成，形如 Xj-Xi&lt;=b*k（i，j属于[1，n]，k属于[1，m] ）， 这样的系统称之为差分约束系统。差分约束系统通常用于求关于一组变量的不等式组。<Finish/></txt><txt ptr="0xa8911808" next="0xa8911898" prev="0xa8911778" upper="0xa6c04f70" lower="(nil)"><Finish/></txt><txt ptr="0xa8911898" next="0xa8911928" prev="0xa8911808" upper="0xa6c04f70" lower="(nil)">   求解差分约束系统可以转化为图论中单源最短路问题。<Finish/></txt><txt ptr="0xa8911928" next="(nil)" prev="0xa8911898" upper="0xa6c04f70" lower="(nil)"><Finish/></txt></body></column></section></body><footer ptr="0xa99861e4" next="(nil)" prev="0xa6c060d4" upper="0xa99965e8" lower="0xa8932e24"><txt ptr="0xa8932e24" next="0xa893449c" prev="(nil)" upper="0xa99861e4" lower="(nil)"><anchored><fly ptr="0xb5a7e90" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa8932d94"><txt ptr="0xa8932d94" next="0xa8932c74" prev="(nil)" upper="0xb5a7e90" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa8932c74" next="(nil)" prev="0xa8932d94" upper="0xb5a7e90" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="5"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="0"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa893449c" next="(nil)" prev="0xa8932e24" upper="0xa99861e4" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa999665c" next="0xa99966d0" prev="0xa99965e8" upper="0xb0726b0" lower="0xa9985244"><header ptr="0xa9985244" next="0xa6c04f10" prev="(nil)" upper="0xa999665c" lower="0xa894ccf4"><txt ptr="0xa894ccf4" next="(nil)" prev="(nil)" upper="0xa9985244" lower="(nil)"><Finish/></txt></header><body ptr="0xa6c04f10" next="0xa9986244" prev="0xa9985244" upper="0xa999665c" lower="0xa99bc300"><section ptr="0xa99bc300" next="(nil)" prev="(nil)" upper="0xa6c04f10" lower="0xa6c05230" follow="0xa99bc400" precede="0xa99bc180"><column ptr="0xa6c05230" next="0xa6c051cc" prev="(nil)" upper="0xa99bc300" lower="0xa6c04eb0"><body ptr="0xa6c04eb0" next="(nil)" prev="(nil)" upper="0xa6c05230" lower="0xa89119b8"><txt ptr="0xa89119b8" next="0xa8911a48" prev="(nil)" upper="0xa6c04eb0" lower="(nil)">  Xj-Xi&lt;=k  <Finish/></txt><txt ptr="0xa8911a48" next="0xa8911ad8" prev="0xa89119b8" upper="0xa6c04eb0" lower="(nil)">==&gt;   d[v]-d[u]&lt;=w[u,v]  <Finish/></txt><txt ptr="0xa8911ad8" next="0xa8911b68" prev="0xa8911a48" upper="0xa6c04eb0" lower="(nil)"> ==&gt;   所以转化为图论求解 <Finish/></txt><txt ptr="0xa8911b68" next="0xa8911bf8" prev="0xa8911ad8" upper="0xa6c04eb0" lower="(nil)">也就是if(d[v]-d[u] &gt;w[u,v])那么d[v]-d[u]&lt;=w[u,v] 。  <Finish/></txt><txt ptr="0xa8911bf8" next="0xa8911c88" prev="0xa8911b68" upper="0xa6c04eb0" lower="(nil)">路径距离初始化 dis[i]=INF<Finish/></txt><txt ptr="0xa8911c88" next="0xa8911d18" prev="0xa8911bf8" upper="0xa6c04eb0" lower="(nil)"><Finish/></txt><txt ptr="0xa8911d18" next="0xa8911da8" prev="0xa8911c88" upper="0xa6c04eb0" lower="(nil)">  再增加一个源点s，源点到所有定点的距离为0（ 添加源点的实质意义为默认另外一系列的不等式组Xi-Xo&lt;=0）,再对源点利用spfa算法。<Finish/></txt><txt ptr="0xa8911da8" next="0xa8911e38" prev="0xa8911d18" upper="0xa6c04eb0" lower="(nil)"><Finish/></txt><txt ptr="0xa8911e38" next="0xa89121b0" prev="0xa8911da8" upper="0xa6c04eb0" lower="(nil)"> <Finish/></txt><txt ptr="0xa89121b0" next="0xa8912240" prev="0xa8911e38" upper="0xa6c04eb0" lower="(nil)"><Finish/></txt><txt ptr="0xa8912240" next="0xa89122d0" prev="0xa89121b0" upper="0xa6c04eb0" lower="(nil)">  注意几个问题：<Finish/></txt><txt ptr="0xa89122d0" next="0xa8912360" prev="0xa8912240" upper="0xa6c04eb0" lower="(nil)">  1、当0没有被利用的时候，0作为超级源点。当0已经被利用了，将n+1（未被利用）置为超级源点。<Finish/></txt><txt ptr="0xa8912360" next="0xa89123f0" prev="0xa89122d0" upper="0xa6c04eb0" lower="(nil)">  2、对于Xj-Xi=k 可以转换为 Xj-Xi&lt;=k Xj-Xi&gt;=k来处理。<Finish/></txt><txt ptr="0xa89123f0" next="0xa8912480" prev="0xa8912360" upper="0xa6c04eb0" lower="(nil)">  3、若要判断图中是否出现负环，可以利用深度优先搜索。以前利用spfa是这样的（head-&gt;****-&gt;tail），当head和tail之间所有点都遍历完了才轮得上tail这个点，这样的话我们无法判断图中有没有负环，我们可以这样改变一样遍历顺序，head-&gt;tail-&gt;***-&gt;head。 当深度优先搜索过程中下次再次遇见head（也就是head节点依然在标记栈中）时，则可判断图中含有负环，否则没有。<Finish/></txt><txt ptr="0xa8912480" next="0xa8912510" prev="0xa89123f0" upper="0xa6c04eb0" lower="(nil)">  4、当图连通时，只需要对源点spfa一次；当图不连通时，对每个定点spfa一次。<Finish/></txt><txt ptr="0xa8912510" next="(nil)" prev="0xa8912480" upper="0xa6c04eb0" lower="(nil)" follow="0xa8918764">  5、对于  Xj-Xi&lt;k or  Xj-Xi&gt;k  , 差分约束系统只针对&gt;= or &lt;=， 所以我们还要进行巧妙转换编程大于等于小于等于。<Finish/></txt></body></column><column ptr="0xa6c051cc" next="0xa6c05168" prev="0xa6c05230" upper="0xa99bc300" lower="0xa6c04e50"><body ptr="0xa6c04e50" next="(nil)" prev="(nil)" upper="0xa6c051cc" lower="0xa8918764"><txt ptr="0xa8918764" next="0xa89125a0" prev="(nil)" upper="0xa6c04e50" lower="(nil)" precede="0xa8912510">  5、对于  Xj-Xi&lt;k or  Xj-Xi&gt;k  , 差分约束系统只针对&gt;= or &lt;=， 所以我们还要进行巧妙转换编程大于等于小于等于。<Finish/></txt><txt ptr="0xa89125a0" next="0xa8912630" prev="0xa8918764" upper="0xa6c04e50" lower="(nil)">二分匹配<Finish/></txt><txt ptr="0xa8912630" next="0xa89126c0" prev="0xa89125a0" upper="0xa6c04e50" lower="(nil)">有向二分图判断<Finish/></txt><txt ptr="0xa89126c0" next="0xa8912750" prev="0xa8912630" upper="0xa6c04e50" lower="(nil)">//其实有向图和无向图的类似<Finish/></txt><txt ptr="0xa8912750" next="0xa89127e0" prev="0xa89126c0" upper="0xa6c04e50" lower="(nil)">const int N = 111;<Finish/></txt><txt ptr="0xa89127e0" next="0xa8912870" prev="0xa8912750" upper="0xa6c04e50" lower="(nil)">int str[N][N];<Finish/></txt><txt ptr="0xa8912870" next="0xa8912900" prev="0xa89127e0" upper="0xa6c04e50" lower="(nil)">int mark[N];<Finish/></txt><txt ptr="0xa8912900" next="0xa8912990" prev="0xa8912870" upper="0xa6c04e50" lower="(nil)">int n;<Finish/></txt><txt ptr="0xa8912990" next="0xa8912a20" prev="0xa8912900" upper="0xa6c04e50" lower="(nil)"><Finish/></txt><txt ptr="0xa8912a20" next="0xa8912ab0" prev="0xa8912990" upper="0xa6c04e50" lower="(nil)">bool dfs(int pos) {<Finish/></txt><txt ptr="0xa8912ab0" next="0xa8912b40" prev="0xa8912a20" upper="0xa6c04e50" lower="(nil)">    for(int i=1; i&lt;=n; i++) {<Finish/></txt><txt ptr="0xa8912b40" next="0xa8912bd0" prev="0xa8912ab0" upper="0xa6c04e50" lower="(nil)">        if(i == pos) {<Finish/></txt><txt ptr="0xa8912bd0" next="0xa8912c60" prev="0xa8912b40" upper="0xa6c04e50" lower="(nil)">            continue;<Finish/></txt><txt ptr="0xa8912c60" next="0xa8912cf0" prev="0xa8912bd0" upper="0xa6c04e50" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8912cf0" next="0xa8912d80" prev="0xa8912c60" upper="0xa6c04e50" lower="(nil)"><Finish/></txt><txt ptr="0xa8912d80" next="0xa8912e10" prev="0xa8912cf0" upper="0xa6c04e50" lower="(nil)">        if(str[pos][i] == 0 || str[i][pos] == 0) {<Finish/></txt><txt ptr="0xa8912e10" next="0xa8912ea0" prev="0xa8912d80" upper="0xa6c04e50" lower="(nil)">            if(mark[i] == mark[pos]) {<Finish/></txt><txt ptr="0xa8912ea0" next="0xa8912f30" prev="0xa8912e10" upper="0xa6c04e50" lower="(nil)">                return false;<Finish/></txt><txt ptr="0xa8912f30" next="0xa8913004" prev="0xa8912ea0" upper="0xa6c04e50" lower="(nil)">            } else if(mark[i] == -1) {<Finish/></txt><txt ptr="0xa8913004" next="0xa8913094" prev="0xa8912f30" upper="0xa6c04e50" lower="(nil)">                mark[i] = !mark[pos];<Finish/></txt><txt ptr="0xa8913094" next="0xa8913124" prev="0xa8913004" upper="0xa6c04e50" lower="(nil)">                if(!dfs(i)) {<Finish/></txt><txt ptr="0xa8913124" next="0xa89131b4" prev="0xa8913094" upper="0xa6c04e50" lower="(nil)">                    return false;<Finish/></txt><txt ptr="0xa89131b4" next="0xa8913244" prev="0xa8913124" upper="0xa6c04e50" lower="(nil)">                }<Finish/></txt><txt ptr="0xa8913244" next="0xa89132d4" prev="0xa89131b4" upper="0xa6c04e50" lower="(nil)">            } else if(mark[i] == !mark[pos]) {<Finish/></txt><txt ptr="0xa89132d4" next="0xa8913364" prev="0xa8913244" upper="0xa6c04e50" lower="(nil)">                continue;<Finish/></txt><txt ptr="0xa8913364" next="(nil)" prev="0xa89132d4" upper="0xa6c04e50" lower="(nil)">            }<Finish/></txt></body></column><column ptr="0xa6c05168" next="(nil)" prev="0xa6c051cc" upper="0xa99bc300" lower="0xa89959c0"><body ptr="0xa89959c0" next="(nil)" prev="(nil)" upper="0xa6c05168" lower="0xa89133f4"><txt ptr="0xa89133f4" next="0xa8913754" prev="(nil)" upper="0xa89959c0" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8913754" next="0xa89137e4" prev="0xa89133f4" upper="0xa89959c0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89137e4" next="0xa8913874" prev="0xa8913754" upper="0xa89959c0" lower="(nil)">    return true;<Finish/></txt><txt ptr="0xa8913874" next="0xa8913904" prev="0xa89137e4" upper="0xa89959c0" lower="(nil)">}<Finish/></txt><txt ptr="0xa8913904" next="0xa8913994" prev="0xa8913874" upper="0xa89959c0" lower="(nil)"><Finish/></txt><txt ptr="0xa8913994" next="0xa8913a24" prev="0xa8913904" upper="0xa89959c0" lower="(nil)">bool findAns() {<Finish/></txt><txt ptr="0xa8913a24" next="0xa8913ab4" prev="0xa8913994" upper="0xa89959c0" lower="(nil)">    memset(mark,-1,sizeof(mark));<Finish/></txt><txt ptr="0xa8913ab4" next="0xa8913b44" prev="0xa8913a24" upper="0xa89959c0" lower="(nil)">    for(int i=1; i&lt;=n; i++) {<Finish/></txt><txt ptr="0xa8913b44" next="0xa8913bd4" prev="0xa8913ab4" upper="0xa89959c0" lower="(nil)">        if(mark[i] == -1) {<Finish/></txt><txt ptr="0xa8913bd4" next="0xa8913c64" prev="0xa8913b44" upper="0xa89959c0" lower="(nil)">            mark[i] = 1;<Finish/></txt><txt ptr="0xa8913c64" next="0xa8913cf4" prev="0xa8913bd4" upper="0xa89959c0" lower="(nil)">            if(!dfs(i)) {<Finish/></txt><txt ptr="0xa8913cf4" next="0xa8913d84" prev="0xa8913c64" upper="0xa89959c0" lower="(nil)">                return false;<Finish/></txt><txt ptr="0xa8913d84" next="0xa8913e14" prev="0xa8913cf4" upper="0xa89959c0" lower="(nil)">            }<Finish/></txt><txt ptr="0xa8913e14" next="0xa8913ea4" prev="0xa8913d84" upper="0xa89959c0" lower="(nil)">        }<Finish/></txt><txt ptr="0xa8913ea4" next="0xa8913f34" prev="0xa8913e14" upper="0xa89959c0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8913f34" next="0xa8914008" prev="0xa8913ea4" upper="0xa89959c0" lower="(nil)">    return true;<Finish/></txt><txt ptr="0xa8914008" next="0xa8914098" prev="0xa8913f34" upper="0xa89959c0" lower="(nil)">}<Finish/></txt><txt ptr="0xa8914098" next="0xa8914128" prev="0xa8914008" upper="0xa89959c0" lower="(nil)">Hungary（匈牙利）算法<Finish/></txt><txt ptr="0xa8914128" next="0xa89141b8" prev="0xa8914098" upper="0xa89959c0" lower="(nil)">const int N=601;<Finish/></txt><txt ptr="0xa89141b8" next="0xa8914248" prev="0xa8914128" upper="0xa89959c0" lower="(nil)"><Finish/></txt><txt ptr="0xa8914248" next="0xa89142d8" prev="0xa89141b8" upper="0xa89959c0" lower="(nil)">//行为上部，列为下部，挑最少的点，使得所有的边和挑的点相连。最小顶点覆盖。<Finish/></txt><txt ptr="0xa89142d8" next="0xa8914368" prev="0xa8914248" upper="0xa89959c0" lower="(nil)">int n1,n2;<Finish/></txt><txt ptr="0xa8914368" next="0xa89143f8" prev="0xa89142d8" upper="0xa89959c0" lower="(nil)">//n1,n2 为二分图的顶点集,其中x∈n1,y∈n2<Finish/></txt><txt ptr="0xa89143f8" next="0xa8914488" prev="0xa8914368" upper="0xa89959c0" lower="(nil)">bool _map[N][N],vis[N];<Finish/></txt><txt ptr="0xa8914488" next="0xa8914518" prev="0xa89143f8" upper="0xa89959c0" lower="(nil)">int link[N];<Finish/></txt><txt ptr="0xa8914518" next="0xa89145a8" prev="0xa8914488" upper="0xa89959c0" lower="(nil)">//link 记录n2 中的点y 在n1 中所匹配的x 点的编号<Finish/></txt><txt ptr="0xa89145a8" next="(nil)" prev="0xa8914518" upper="0xa89959c0" lower="(nil)"><Finish/></txt></body></column></section></body><footer ptr="0xa9986244" next="(nil)" prev="0xa6c04f10" upper="0xa999665c" lower="0xa894cc64"><txt ptr="0xa894cc64" next="0xa89342ec" prev="(nil)" upper="0xa9986244" lower="(nil)"><anchored><fly ptr="0xb700a08" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa894cb44"><txt ptr="0xa894cb44" next="0xa892f36c" prev="(nil)" upper="0xb700a08" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa892f36c" next="(nil)" prev="0xa894cb44" upper="0xb700a08" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="5"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="1"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa89342ec" next="(nil)" prev="0xa894cc64" upper="0xa9986244" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa99966d0" next="0xa9996744" prev="0xa999665c" upper="0xb0726b0" lower="0xa99852a4"><header ptr="0xa99852a4" next="0xa8995a20" prev="(nil)" upper="0xa99966d0" lower="0xa894a5a0"><txt ptr="0xa894a5a0" next="(nil)" prev="(nil)" upper="0xa99852a4" lower="(nil)"><Finish/></txt></header><body ptr="0xa8995a20" next="0xa99862a4" prev="0xa99852a4" upper="0xa99966d0" lower="0xa99bc400"><section ptr="0xa99bc400" next="(nil)" prev="(nil)" upper="0xa8995a20" lower="0xa6c05104" follow="0xa891d310" precede="0xa99bc300"><column ptr="0xa6c05104" next="0xa6c050a0" prev="(nil)" upper="0xa99bc400" lower="0xa8995660"><body ptr="0xa8995660" next="(nil)" prev="(nil)" upper="0xa6c05104" lower="0xa8914638"><txt ptr="0xa8914638" next="0xa89146c8" prev="(nil)" upper="0xa8995660" lower="(nil)">int find(int x) {<Finish/></txt><txt ptr="0xa89146c8" next="0xa8914758" prev="0xa8914638" upper="0xa8995660" lower="(nil)">    int i;<Finish/></txt><txt ptr="0xa8914758" next="0xa89147e8" prev="0xa89146c8" upper="0xa8995660" lower="(nil)">    for(i=0; i&lt;n2; i++) {<Finish/></txt><txt ptr="0xa89147e8" next="0xa8914878" prev="0xa8914758" upper="0xa8995660" lower="(nil)">        if(_map[x][i]&amp;&amp;!vis[i]) { <Finish/></txt><txt ptr="0xa8914878" next="0xa8914908" prev="0xa89147e8" upper="0xa8995660" lower="(nil)">//x-&gt;i 有边,且节点i 未被搜索<Finish/></txt><txt ptr="0xa8914908" next="0xa8914998" prev="0xa8914878" upper="0xa8995660" lower="(nil)">            vis[i] = true;//标记节点已被搜索<Finish/></txt><txt ptr="0xa8914998" next="0xa8914cf8" prev="0xa8914908" upper="0xa8995660" lower="(nil)">//如果i 不属于前一个匹配M 或被i 匹配到的节点可以寻找到增广路<Finish/></txt><txt ptr="0xa8914cf8" next="0xa8914d88" prev="0xa8914998" upper="0xa8995660" lower="(nil)">            if(link[i]==-1 || find(link[i])) {<Finish/></txt><txt ptr="0xa8914d88" next="0xa8914e18" prev="0xa8914cf8" upper="0xa8995660" lower="(nil)">                link[i]=x;//更新<Finish/></txt><txt ptr="0xa8914e18" next="0xa8914ea8" prev="0xa8914d88" upper="0xa8995660" lower="(nil)">                return true;//匹配成功<Finish/></txt><txt ptr="0xa8914ea8" next="0xa8914f38" prev="0xa8914e18" upper="0xa8995660" lower="(nil)">            }<Finish/></txt><txt ptr="0xa8914f38" next="0xa891500c" prev="0xa8914ea8" upper="0xa8995660" lower="(nil)">        }<Finish/></txt><txt ptr="0xa891500c" next="0xa891509c" prev="0xa8914f38" upper="0xa8995660" lower="(nil)">    }<Finish/></txt><txt ptr="0xa891509c" next="0xa891512c" prev="0xa891500c" upper="0xa8995660" lower="(nil)">    return false;<Finish/></txt><txt ptr="0xa891512c" next="0xa89151bc" prev="0xa891509c" upper="0xa8995660" lower="(nil)">}<Finish/></txt><txt ptr="0xa89151bc" next="0xa891524c" prev="0xa891512c" upper="0xa8995660" lower="(nil)"><Finish/></txt><txt ptr="0xa891524c" next="0xa89152dc" prev="0xa89151bc" upper="0xa8995660" lower="(nil)">int mach() {<Finish/></txt><txt ptr="0xa89152dc" next="0xa891536c" prev="0xa891524c" upper="0xa8995660" lower="(nil)">    int ans = 0;<Finish/></txt><txt ptr="0xa891536c" next="0xa89153fc" prev="0xa89152dc" upper="0xa8995660" lower="(nil)">    memset(link, -1, sizeof(link));<Finish/></txt><txt ptr="0xa89153fc" next="0xa891548c" prev="0xa891536c" upper="0xa8995660" lower="(nil)">    for (int i = 0; i &lt; n1; i++) {<Finish/></txt><txt ptr="0xa891548c" next="0xa891551c" prev="0xa89153fc" upper="0xa8995660" lower="(nil)">        memset(vis,false,sizeof(vis));<Finish/></txt><txt ptr="0xa891551c" next="0xa89155ac" prev="0xa891548c" upper="0xa8995660" lower="(nil)">        if (find(i))ans++;<Finish/></txt><txt ptr="0xa89155ac" next="0xa891563c" prev="0xa891551c" upper="0xa8995660" lower="(nil)">// 如果从第i个点找到了增光轨，总数加一<Finish/></txt><txt ptr="0xa891563c" next="0xa89156cc" prev="0xa89155ac" upper="0xa8995660" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89156cc" next="0xa891575c" prev="0xa891563c" upper="0xa8995660" lower="(nil)">    return ans;<Finish/></txt><txt ptr="0xa891575c" next="(nil)" prev="0xa89156cc" upper="0xa8995660" lower="(nil)">}<Finish/></txt></body></column><column ptr="0xa6c050a0" next="0xa6c0503c" prev="0xa6c05104" upper="0xa99bc400" lower="0xa8995c60"><body ptr="0xa8995c60" next="(nil)" prev="(nil)" upper="0xa6c050a0" lower="0xa89157ec"><txt ptr="0xa89157ec" next="0xa891587c" prev="(nil)" upper="0xa8995c60" lower="(nil)">Hopcroft–Karp算法<Finish/></txt><txt ptr="0xa891587c" next="0xa891590c" prev="0xa89157ec" upper="0xa8995c60" lower="(nil)">Hopcroft–Karp算法是匈牙利算法的改进，时间复杂度0(E*V^1/2)(怎么证的？)，算法实质其实还是匈牙利算法求增广路，改进的地方是在深度搜索增广路前，先通过广度搜索，查找多条可以增广的路线，从而不再让dfs“一意孤行”。其中算法用到了分层标记防止多条增广路重叠，这里是精髓<Finish/></txt><txt ptr="0xa891590c" next="0xa891599c" prev="0xa891587c" upper="0xa8995c60" lower="(nil)">typedef long long ll;<Finish/></txt><txt ptr="0xa891599c" next="0xa8915a2c" prev="0xa891590c" upper="0xa8995c60" lower="(nil)">#define inf (int)1e10<Finish/></txt><txt ptr="0xa8915a2c" next="0xa8915abc" prev="0xa891599c" upper="0xa8995c60" lower="(nil)">#define maxn 50005<Finish/></txt><txt ptr="0xa8915abc" next="0xa8915b4c" prev="0xa8915a2c" upper="0xa8995c60" lower="(nil)">vector&lt;int&gt;vec[maxn];<Finish/></txt><txt ptr="0xa8915b4c" next="0xa8915bdc" prev="0xa8915abc" upper="0xa8995c60" lower="(nil)">int headU[maxn],headV[maxn];<Finish/></txt><txt ptr="0xa8915bdc" next="0xa8915c6c" prev="0xa8915b4c" upper="0xa8995c60" lower="(nil)">int du[maxn],dv[maxn];<Finish/></txt><txt ptr="0xa8915c6c" next="0xa8915cfc" prev="0xa8915bdc" upper="0xa8995c60" lower="(nil)">int uN,vN;<Finish/></txt><txt ptr="0xa8915cfc" next="0xa8915d8c" prev="0xa8915c6c" upper="0xa8995c60" lower="(nil)">bool bfs() {<Finish/></txt><txt ptr="0xa8915d8c" next="0xa8915e1c" prev="0xa8915cfc" upper="0xa8995c60" lower="(nil)">    queue&lt;int&gt;q;<Finish/></txt><txt ptr="0xa8915e1c" next="0xa8915eac" prev="0xa8915d8c" upper="0xa8995c60" lower="(nil)">    int dis=inf;<Finish/></txt><txt ptr="0xa8915eac" next="0xa8915f3c" prev="0xa8915e1c" upper="0xa8995c60" lower="(nil)">    memset(du,0,sizeof(du));<Finish/></txt><txt ptr="0xa8915f3c" next="0xa89162e0" prev="0xa8915eac" upper="0xa8995c60" lower="(nil)">    memset(dv,0,sizeof(dv));<Finish/></txt><txt ptr="0xa89162e0" next="0xa8916370" prev="0xa8915f3c" upper="0xa8995c60" lower="(nil)">    for(int i=1; i&lt;=uN; i++)<Finish/></txt><txt ptr="0xa8916370" next="0xa8916400" prev="0xa89162e0" upper="0xa8995c60" lower="(nil)">        if(headU[i]==-1)q.push(i);<Finish/></txt><txt ptr="0xa8916400" next="0xa8916490" prev="0xa8916370" upper="0xa8995c60" lower="(nil)">    while(!q.empty()) {<Finish/></txt><txt ptr="0xa8916490" next="0xa8916520" prev="0xa8916400" upper="0xa8995c60" lower="(nil)">        int u=q.front();<Finish/></txt><txt ptr="0xa8916520" next="0xa89165b0" prev="0xa8916490" upper="0xa8995c60" lower="(nil)">        q.pop();<Finish/></txt><txt ptr="0xa89165b0" next="0xa8916640" prev="0xa8916520" upper="0xa8995c60" lower="(nil)">        if(du[u]&gt;dis)break;<Finish/></txt><txt ptr="0xa8916640" next="0xa89166d0" prev="0xa89165b0" upper="0xa8995c60" lower="(nil)">        for(int i=0; i&lt;vec[u].size(); i++)<Finish/></txt><txt ptr="0xa89166d0" next="0xa8916760" prev="0xa8916640" upper="0xa8995c60" lower="(nil)">            if(!dv[vec[u][i]]) {<Finish/></txt><txt ptr="0xa8916760" next="(nil)" prev="0xa89166d0" upper="0xa8995c60" lower="(nil)">                dv[vec[u][i]]=du[u]+1;<Finish/></txt></body></column><column ptr="0xa6c0503c" next="(nil)" prev="0xa6c050a0" upper="0xa99bc400" lower="0xa8995cc0"><body ptr="0xa8995cc0" next="(nil)" prev="(nil)" upper="0xa6c0503c" lower="0xa89167f0"><txt ptr="0xa89167f0" next="0xa8916880" prev="(nil)" upper="0xa8995cc0" lower="(nil)">if(headV[vec[u][i]]==-1)dis=dv[vec[u][i]];<Finish/></txt><txt ptr="0xa8916880" next="0xa8916910" prev="0xa89167f0" upper="0xa8995cc0" lower="(nil)">                else {<Finish/></txt><txt ptr="0xa8916910" next="0xa89169a0" prev="0xa8916880" upper="0xa8995cc0" lower="(nil)">    du[headV[vec[u][i]]]=dv[vec[u][i]]+1;<Finish/></txt><txt ptr="0xa89169a0" next="0xa8916a30" prev="0xa8916910" upper="0xa8995cc0" lower="(nil)">                    q.push(headV[vec[u][i]]);<Finish/></txt><txt ptr="0xa8916a30" next="0xa8916ac0" prev="0xa89169a0" upper="0xa8995cc0" lower="(nil)">                }<Finish/></txt><txt ptr="0xa8916ac0" next="0xa8916b50" prev="0xa8916a30" upper="0xa8995cc0" lower="(nil)">            }<Finish/></txt><txt ptr="0xa8916b50" next="0xa8916be0" prev="0xa8916ac0" upper="0xa8995cc0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8916be0" next="0xa8916c70" prev="0xa8916b50" upper="0xa8995cc0" lower="(nil)">    return dis!=inf;<Finish/></txt><txt ptr="0xa8916c70" next="0xa8916d00" prev="0xa8916be0" upper="0xa8995cc0" lower="(nil)">}<Finish/></txt><txt ptr="0xa8916d00" next="0xa8916d90" prev="0xa8916c70" upper="0xa8995cc0" lower="(nil)">bool dfs(int u) {<Finish/></txt><txt ptr="0xa8916d90" next="0xa8916e20" prev="0xa8916d00" upper="0xa8995cc0" lower="(nil)">    for(int i=0; i&lt;vec[u].size(); i++)<Finish/></txt><txt ptr="0xa8916e20" next="0xa8916eb0" prev="0xa8916d90" upper="0xa8995cc0" lower="(nil)">        if(dv[vec[u][i]]==du[u]+1) {<Finish/></txt><txt ptr="0xa8916eb0" next="0xa8916f40" prev="0xa8916e20" upper="0xa8995cc0" lower="(nil)">            dv[vec[u][i]]=0;<Finish/></txt><txt ptr="0xa8916f40" next="0xa8918014" prev="0xa8916eb0" upper="0xa8995cc0" lower="(nil)">if(headV[vec[u][i]]==-1||dfs(headV[vec[u][i]])) {<Finish/></txt><txt ptr="0xa8918014" next="0xa89180a4" prev="0xa8916f40" upper="0xa8995cc0" lower="(nil)">                headU[u]=vec[u][i];<Finish/></txt><txt ptr="0xa89180a4" next="0xa8918134" prev="0xa8918014" upper="0xa8995cc0" lower="(nil)">                headV[vec[u][i]]=u;<Finish/></txt><txt ptr="0xa8918134" next="0xa89181c4" prev="0xa89180a4" upper="0xa8995cc0" lower="(nil)">                return 1;<Finish/></txt><txt ptr="0xa89181c4" next="0xa8918254" prev="0xa8918134" upper="0xa8995cc0" lower="(nil)">            }<Finish/></txt><txt ptr="0xa8918254" next="0xa89182e4" prev="0xa89181c4" upper="0xa8995cc0" lower="(nil)">        }<Finish/></txt><txt ptr="0xa89182e4" next="0xa8918374" prev="0xa8918254" upper="0xa8995cc0" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa8918374" next="0xa8918404" prev="0xa89182e4" upper="0xa8995cc0" lower="(nil)">}<Finish/></txt><txt ptr="0xa8918404" next="0xa8918494" prev="0xa8918374" upper="0xa8995cc0" lower="(nil)">int Hopcroft() {<Finish/></txt><txt ptr="0xa8918494" next="0xa8918524" prev="0xa8918404" upper="0xa8995cc0" lower="(nil)">    memset(headU,-1,sizeof(headU));<Finish/></txt><txt ptr="0xa8918524" next="0xa8918884" prev="0xa8918494" upper="0xa8995cc0" lower="(nil)">    memset(headV,-1,sizeof(headV));<Finish/></txt><txt ptr="0xa8918884" next="0xa8918914" prev="0xa8918524" upper="0xa8995cc0" lower="(nil)">    int ans=0;<Finish/></txt><txt ptr="0xa8918914" next="0xa89189a4" prev="0xa8918884" upper="0xa8995cc0" lower="(nil)">    while(bfs())<Finish/></txt><txt ptr="0xa89189a4" next="0xa8918a34" prev="0xa8918914" upper="0xa8995cc0" lower="(nil)">        for(int i=1; i&lt;=uN; i++)<Finish/></txt><txt ptr="0xa8918a34" next="(nil)" prev="0xa89189a4" upper="0xa8995cc0" lower="(nil)">            if(headU[i]==-1&amp;&amp;dfs(i))ans++;<Finish/></txt></body></column></section></body><footer ptr="0xa99862a4" next="(nil)" prev="0xa8995a20" upper="0xa99966d0" lower="0xa894cd84"><txt ptr="0xa894cd84" next="0xa8935a40" prev="(nil)" upper="0xa99862a4" lower="(nil)"><anchored><fly ptr="0xac25e28" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa894cbd4"><txt ptr="0xa894cbd4" next="0xa893437c" prev="(nil)" upper="0xac25e28" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa893437c" next="(nil)" prev="0xa894cbd4" upper="0xac25e28" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="5"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="2"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa8935a40" next="(nil)" prev="0xa894cd84" upper="0xa99862a4" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996744" next="0xa99967b8" prev="0xa99966d0" upper="0xb0726b0" lower="0xa9985304"><header ptr="0xa9985304" next="0xa8995d20" prev="(nil)" upper="0xa9996744" lower="0xa8949148"><txt ptr="0xa8949148" next="(nil)" prev="(nil)" upper="0xa9985304" lower="(nil)"><Finish/></txt></header><body ptr="0xa8995d20" next="0xa9986304" prev="0xa9985304" upper="0xa9996744" lower="0xa891d310"><section ptr="0xa891d310" next="(nil)" prev="(nil)" upper="0xa8995d20" lower="0xa89999c4" follow="0xa891d410" precede="0xa99bc400"><column ptr="0xa89999c4" next="0xa8999a28" prev="(nil)" upper="0xa891d310" lower="0xa6c04cd0"><body ptr="0xa6c04cd0" next="(nil)" prev="(nil)" upper="0xa89999c4" lower="0xa8918ac4"><txt ptr="0xa8918ac4" next="0xa8918b54" prev="(nil)" upper="0xa6c04cd0" lower="(nil)">    return ans;<Finish/></txt><txt ptr="0xa8918b54" next="0xa8918be4" prev="0xa8918ac4" upper="0xa6c04cd0" lower="(nil)">}<Finish/></txt><txt ptr="0xa8918be4" next="0xa8918c74" prev="0xa8918b54" upper="0xa6c04cd0" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa8918c74" next="0xa8918d04" prev="0xa8918be4" upper="0xa6c04cd0" lower="(nil)">    int u,v,w;<Finish/></txt><txt ptr="0xa8918d04" next="0xa8918d94" prev="0xa8918c74" upper="0xa6c04cd0" lower="(nil)">    while(~scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w)) {<Finish/></txt><txt ptr="0xa8918d94" next="0xa8918e24" prev="0xa8918d04" upper="0xa6c04cd0" lower="(nil)">        for(int i=0; i&lt;maxn; i++)vec[i].clear();<Finish/></txt><txt ptr="0xa8918e24" next="0xa8918eb4" prev="0xa8918d94" upper="0xa6c04cd0" lower="(nil)">        uN=u;<Finish/></txt><txt ptr="0xa8918eb4" next="0xa8918f44" prev="0xa8918e24" upper="0xa6c04cd0" lower="(nil)">        int tu,tv;<Finish/></txt><txt ptr="0xa8918f44" next="0xa8919018" prev="0xa8918eb4" upper="0xa6c04cd0" lower="(nil)">        while(w--) {<Finish/></txt><txt ptr="0xa8919018" next="0xa89190a8" prev="0xa8918f44" upper="0xa6c04cd0" lower="(nil)">            scanf(&quot;%d%d&quot;,&amp;tu,&amp;tv);<Finish/></txt><txt ptr="0xa89190a8" next="0xa8919138" prev="0xa8919018" upper="0xa6c04cd0" lower="(nil)">            vec[tu].push_back(tv);<Finish/></txt><txt ptr="0xa8919138" next="0xa89191c8" prev="0xa89190a8" upper="0xa6c04cd0" lower="(nil)">        }<Finish/></txt><txt ptr="0xa89191c8" next="0xa8919258" prev="0xa8919138" upper="0xa6c04cd0" lower="(nil)">        printf(&quot;%d\n&quot;,Hopcroft());<Finish/></txt><txt ptr="0xa8919258" next="0xa89192e8" prev="0xa89191c8" upper="0xa6c04cd0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89192e8" next="0xa8919378" prev="0xa8919258" upper="0xa6c04cd0" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa8919378" next="0xa8919408" prev="0xa89192e8" upper="0xa6c04cd0" lower="(nil)">}<Finish/></txt><txt ptr="0xa8919408" next="0xa8919498" prev="0xa8919378" upper="0xa6c04cd0" lower="(nil)">最大权匹配的KM算法<Finish/></txt><txt ptr="0xa8919498" next="0xa8919528" prev="0xa8919408" upper="0xa6c04cd0" lower="(nil)">typedef long long ll;<Finish/></txt><txt ptr="0xa8919528" next="0xa89195b8" prev="0xa8919498" upper="0xa6c04cd0" lower="(nil)">#define inf (int)1e10<Finish/></txt><txt ptr="0xa89195b8" next="0xa8919648" prev="0xa8919528" upper="0xa6c04cd0" lower="(nil)">#define maxn 150<Finish/></txt><txt ptr="0xa8919648" next="0xa89196d8" prev="0xa89195b8" upper="0xa6c04cd0" lower="(nil)">int edge[maxn][maxn];//邻接矩阵<Finish/></txt><txt ptr="0xa89196d8" next="0xa8919768" prev="0xa8919648" upper="0xa6c04cd0" lower="(nil)">int du[maxn],dv[maxn];//可行顶标<Finish/></txt><txt ptr="0xa8919768" next="0xa89197f8" prev="0xa89196d8" upper="0xa6c04cd0" lower="(nil)">int head[maxn];//匹配节点的父节点<Finish/></txt><txt ptr="0xa89197f8" next="0xa8919888" prev="0xa8919768" upper="0xa6c04cd0" lower="(nil)">bool visu[maxn],visv[maxn];//判断是否在交错树上<Finish/></txt><txt ptr="0xa8919888" next="0xa8919918" prev="0xa89197f8" upper="0xa6c04cd0" lower="(nil)">int uN;//匹配点的个数<Finish/></txt><txt ptr="0xa8919918" next="0xa89199a8" prev="0xa8919888" upper="0xa6c04cd0" lower="(nil)">int slack[maxn];//松弛数组<Finish/></txt><txt ptr="0xa89199a8" next="0xa8919a38" prev="0xa8919918" upper="0xa6c04cd0" lower="(nil)">bool dfs(int u) {<Finish/></txt><txt ptr="0xa8919a38" next="(nil)" prev="0xa89199a8" upper="0xa6c04cd0" lower="(nil)">    visu[u]=true;<Finish/></txt></body></column><column ptr="0xa8999a28" next="0xa8999a8c" prev="0xa89999c4" upper="0xa891d310" lower="0xa6c04c70"><body ptr="0xa6c04c70" next="(nil)" prev="(nil)" upper="0xa8999a28" lower="0xa8919ac8"><txt ptr="0xa8919ac8" next="0xa8919e28" prev="(nil)" upper="0xa6c04c70" lower="(nil)">    for(int v=0; v&lt;uN; v++)<Finish/></txt><txt ptr="0xa8919e28" next="0xa8919eb8" prev="0xa8919ac8" upper="0xa6c04c70" lower="(nil)">        if(!visv[v]) {<Finish/></txt><txt ptr="0xa8919eb8" next="0xa8919f48" prev="0xa8919e28" upper="0xa6c04c70" lower="(nil)">            int t=du[u]+dv[v]-edge[u][v];<Finish/></txt><txt ptr="0xa8919f48" next="0xa891a01c" prev="0xa8919eb8" upper="0xa6c04c70" lower="(nil)">            if(t==0) {<Finish/></txt><txt ptr="0xa891a01c" next="0xa891a0ac" prev="0xa8919f48" upper="0xa6c04c70" lower="(nil)">                visv[v]=true;<Finish/></txt><txt ptr="0xa891a0ac" next="0xa891a13c" prev="0xa891a01c" upper="0xa6c04c70" lower="(nil)">                if(head[v]==-1||dfs(head[v])) {<Finish/></txt><txt ptr="0xa891a13c" next="0xa891a1cc" prev="0xa891a0ac" upper="0xa6c04c70" lower="(nil)">                    head[v]=u;<Finish/></txt><txt ptr="0xa891a1cc" next="0xa891a25c" prev="0xa891a13c" upper="0xa6c04c70" lower="(nil)">                    return true;<Finish/></txt><txt ptr="0xa891a25c" next="0xa891a2ec" prev="0xa891a1cc" upper="0xa6c04c70" lower="(nil)">                }<Finish/></txt><txt ptr="0xa891a2ec" next="0xa891a37c" prev="0xa891a25c" upper="0xa6c04c70" lower="(nil)">            } else slack[v]=min(slack[v],t);<Finish/></txt><txt ptr="0xa891a37c" next="0xa891a40c" prev="0xa891a2ec" upper="0xa6c04c70" lower="(nil)">        }<Finish/></txt><txt ptr="0xa891a40c" next="0xa891a49c" prev="0xa891a37c" upper="0xa6c04c70" lower="(nil)">    return false;<Finish/></txt><txt ptr="0xa891a49c" next="0xa891a52c" prev="0xa891a40c" upper="0xa6c04c70" lower="(nil)">}<Finish/></txt><txt ptr="0xa891a52c" next="0xa891a5bc" prev="0xa891a49c" upper="0xa6c04c70" lower="(nil)">int KM() {<Finish/></txt><txt ptr="0xa891a5bc" next="0xa891a64c" prev="0xa891a52c" upper="0xa6c04c70" lower="(nil)">    memset(head,-1,sizeof(head));<Finish/></txt><txt ptr="0xa891a64c" next="0xa891a6dc" prev="0xa891a5bc" upper="0xa6c04c70" lower="(nil)">    memset(du,0,sizeof(du));<Finish/></txt><txt ptr="0xa891a6dc" next="0xa891a76c" prev="0xa891a64c" upper="0xa6c04c70" lower="(nil)">    memset(dv,0,sizeof(dv));<Finish/></txt><txt ptr="0xa891a76c" next="0xa891a7fc" prev="0xa891a6dc" upper="0xa6c04c70" lower="(nil)">    for(int u=0; u&lt;uN; u++)<Finish/></txt><txt ptr="0xa891a7fc" next="0xa891a88c" prev="0xa891a76c" upper="0xa6c04c70" lower="(nil)">        for(int v=0; v&lt;uN; v++)<Finish/></txt><txt ptr="0xa891a88c" next="0xa891a91c" prev="0xa891a7fc" upper="0xa6c04c70" lower="(nil)">            du[u]=max(du[u],edge[u][v]);<Finish/></txt><txt ptr="0xa891a91c" next="0xa891a9ac" prev="0xa891a88c" upper="0xa6c04c70" lower="(nil)">    for(int u=0; u&lt;uN; u++) {<Finish/></txt><txt ptr="0xa891a9ac" next="0xa891aa3c" prev="0xa891a91c" upper="0xa6c04c70" lower="(nil)">        for(int i=0; i&lt;uN; i++)slack[i]=inf;<Finish/></txt><txt ptr="0xa891aa3c" next="0xa891aacc" prev="0xa891a9ac" upper="0xa6c04c70" lower="(nil)">        while(true) {<Finish/></txt><txt ptr="0xa891aacc" next="0xa891ab5c" prev="0xa891aa3c" upper="0xa6c04c70" lower="(nil)">            memset(visu,0,sizeof(visu));<Finish/></txt><txt ptr="0xa891ab5c" next="0xa891abec" prev="0xa891aacc" upper="0xa6c04c70" lower="(nil)">            memset(visv,0,sizeof(visv));<Finish/></txt><txt ptr="0xa891abec" next="0xa891ac7c" prev="0xa891ab5c" upper="0xa6c04c70" lower="(nil)">            if(dfs(u))break;<Finish/></txt><txt ptr="0xa891ac7c" next="0xa891ad0c" prev="0xa891abec" upper="0xa6c04c70" lower="(nil)">            int ex=inf;<Finish/></txt><txt ptr="0xa891ad0c" next="(nil)" prev="0xa891ac7c" upper="0xa6c04c70" lower="(nil)">            for(int v=0; v&lt;uN; v++)if(!visv[v])<Finish/></txt></body></column><column ptr="0xa8999a8c" next="(nil)" prev="0xa8999a28" upper="0xa891d310" lower="0xa6c04c10"><body ptr="0xa6c04c10" next="(nil)" prev="(nil)" upper="0xa8999a8c" lower="0xa891ad9c"><txt ptr="0xa891ad9c" next="0xa891ae2c" prev="(nil)" upper="0xa6c04c10" lower="(nil)">                    ex=min(ex,slack[v]);<Finish/></txt><txt ptr="0xa891ae2c" next="0xa891aebc" prev="0xa891ad9c" upper="0xa6c04c10" lower="(nil)">            for(int i=0; i&lt;uN; i++) {<Finish/></txt><txt ptr="0xa891aebc" next="0xa891af4c" prev="0xa891ae2c" upper="0xa6c04c10" lower="(nil)">                if(visu[i])du[i]-=ex;<Finish/></txt><txt ptr="0xa891af4c" next="0xa891b020" prev="0xa891aebc" upper="0xa6c04c10" lower="(nil)">                if(visv[i])dv[i]+=ex;<Finish/></txt><txt ptr="0xa891b020" next="0xa891b0b0" prev="0xa891af4c" upper="0xa6c04c10" lower="(nil)">                else slack[i]-=ex;<Finish/></txt><txt ptr="0xa891b0b0" next="0xa891b410" prev="0xa891b020" upper="0xa6c04c10" lower="(nil)"><Finish/></txt><txt ptr="0xa891b410" next="0xa891b4a0" prev="0xa891b0b0" upper="0xa6c04c10" lower="(nil)">            }<Finish/></txt><txt ptr="0xa891b4a0" next="0xa891b530" prev="0xa891b410" upper="0xa6c04c10" lower="(nil)">        }<Finish/></txt><txt ptr="0xa891b530" next="0xa891b5c0" prev="0xa891b4a0" upper="0xa6c04c10" lower="(nil)">    }<Finish/></txt><txt ptr="0xa891b5c0" next="0xa891b650" prev="0xa891b530" upper="0xa6c04c10" lower="(nil)">    int ans=0;<Finish/></txt><txt ptr="0xa891b650" next="0xa891b6e0" prev="0xa891b5c0" upper="0xa6c04c10" lower="(nil)">    for(int u=0; u&lt;uN; u++)<Finish/></txt><txt ptr="0xa891b6e0" next="0xa891b770" prev="0xa891b650" upper="0xa6c04c10" lower="(nil)">        ans+=edge[head[u]][u];<Finish/></txt><txt ptr="0xa891b770" next="0xa891b800" prev="0xa891b6e0" upper="0xa6c04c10" lower="(nil)">    return ans;<Finish/></txt><txt ptr="0xa891b800" next="0xa891b890" prev="0xa891b770" upper="0xa6c04c10" lower="(nil)">}<Finish/></txt><txt ptr="0xa891b890" next="0xa891b920" prev="0xa891b800" upper="0xa6c04c10" lower="(nil)">int main() {<Finish/></txt><txt ptr="0xa891b920" next="0xa891b9b0" prev="0xa891b890" upper="0xa6c04c10" lower="(nil)">    //read;<Finish/></txt><txt ptr="0xa891b9b0" next="0xa891ba40" prev="0xa891b920" upper="0xa6c04c10" lower="(nil)">    while(~scanf(&quot;%d&quot;,&amp;uN)) {<Finish/></txt><txt ptr="0xa891ba40" next="0xa891bad0" prev="0xa891b9b0" upper="0xa6c04c10" lower="(nil)">        int sum=0;<Finish/></txt><txt ptr="0xa891bad0" next="0xa891bb60" prev="0xa891ba40" upper="0xa6c04c10" lower="(nil)">        for(int i=0; i&lt;uN; i++)<Finish/></txt><txt ptr="0xa891bb60" next="0xa891bbf0" prev="0xa891bad0" upper="0xa6c04c10" lower="(nil)">            for(int j=0; j&lt;uN; j++) {<Finish/></txt><txt ptr="0xa891bbf0" next="0xa891bc80" prev="0xa891bb60" upper="0xa6c04c10" lower="(nil)">                scanf(&quot;%d&quot;,&amp;edge[i][j]);<Finish/></txt><txt ptr="0xa891bc80" next="0xa891bd10" prev="0xa891bbf0" upper="0xa6c04c10" lower="(nil)">                sum+=edge[i][j];<Finish/></txt><txt ptr="0xa891bd10" next="0xa891bda0" prev="0xa891bc80" upper="0xa6c04c10" lower="(nil)">            }<Finish/></txt><txt ptr="0xa891bda0" next="0xa891be30" prev="0xa891bd10" upper="0xa6c04c10" lower="(nil)">        printf(&quot;%d\n&quot;,sum-KM());<Finish/></txt><txt ptr="0xa891be30" next="0xa891bec0" prev="0xa891bda0" upper="0xa6c04c10" lower="(nil)">    }<Finish/></txt><txt ptr="0xa891bec0" next="0xa891bf50" prev="0xa891be30" upper="0xa6c04c10" lower="(nil)">    return 0;<Finish/></txt><txt ptr="0xa891bf50" next="(nil)" prev="0xa891bec0" upper="0xa6c04c10" lower="(nil)">}<Finish/></txt></body></column></section></body><footer ptr="0xa9986304" next="(nil)" prev="0xa8995d20" upper="0xa9996744" lower="0xa8949028"><txt ptr="0xa8949028" next="0xa894a750" prev="(nil)" upper="0xa9986304" lower="(nil)"><anchored><fly ptr="0xad5dc78" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa894a7e0"><txt ptr="0xa894a7e0" next="0xa894a630" prev="(nil)" upper="0xad5dc78" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa894a630" next="(nil)" prev="0xa894a7e0" upper="0xad5dc78" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="5"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="3"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa894a750" next="(nil)" prev="0xa8949028" upper="0xa9986304" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa99967b8" next="0xa999682c" prev="0xa9996744" upper="0xb0726b0" lower="0xa9985364"><header ptr="0xa9985364" next="0xa99c8364" prev="(nil)" upper="0xa99967b8" lower="0xa8949268"><txt ptr="0xa8949268" next="(nil)" prev="(nil)" upper="0xa9985364" lower="(nil)"><Finish/></txt></header><body ptr="0xa99c8364" next="0xa9986364" prev="0xa9985364" upper="0xa99967b8" lower="0xa891d410"><section ptr="0xa891d410" next="(nil)" prev="(nil)" upper="0xa99c8364" lower="0xa8999c1c" follow="0xa99bc600" precede="0xa891d310"><column ptr="0xa8999c1c" next="0xa8999c80" prev="(nil)" upper="0xa891d410" lower="0xa8995f60"><body ptr="0xa8995f60" next="(nil)" prev="(nil)" upper="0xa8999c1c" lower="0xa891c024"><txt ptr="0xa891c024" next="0xa891c0b4" prev="(nil)" upper="0xa8995f60" lower="(nil)">强连通分支算法<Finish/></txt><txt ptr="0xa891c0b4" next="0xa891c144" prev="0xa891c024" upper="0xa8995f60" lower="(nil)">有向图G=(V, E)的一个强连通分支就是一个最大的顶点子集C，对于C中每对顶点(s, t)，有s和t是强连通的，并且t和 s也是强连通的，即顶点s和t是互达的。<Finish/></txt><txt ptr="0xa891c144" next="0xa891c1d4" prev="0xa891c0b4" upper="0xa8995f60" lower="(nil)">Kosaraju算法<Finish/></txt><txt ptr="0xa891c1d4" next="0xa891c264" prev="0xa891c144" upper="0xa8995f60" lower="(nil)">Kosaraju算法的解释和实现都比较简单，为了找到强连通分支，首先对图G运行DFS，计算出各顶点完成搜索的时间f；然后计算图的逆图GT，对逆图也进行DFS搜索，但是这里搜索时顶点的访问次序不是按照顶点标号的大小，而是按照各顶点f值由大到小的顺序；逆图DFS所得到的森林即对应连通区域<Finish/></txt><txt ptr="0xa891c264" next="0xa891c2f4" prev="0xa891c1d4" upper="0xa8995f60" lower="(nil)">矩阵储存<Finish/></txt><txt ptr="0xa891c2f4" next="0xa891c384" prev="0xa891c264" upper="0xa8995f60" lower="(nil)">const int MAXV = 1024;<Finish/></txt><txt ptr="0xa891c384" next="0xa891c414" prev="0xa891c2f4" upper="0xa8995f60" lower="(nil)">int g[MAXV][MAXV], dfn[MAXV], num[MAXV], n, scc, cnt;<Finish/></txt><txt ptr="0xa891c414" next="0xa891c4a4" prev="0xa891c384" upper="0xa8995f60" lower="(nil)">void dfs(int k) {<Finish/></txt><txt ptr="0xa891c4a4" next="0xa891c534" prev="0xa891c414" upper="0xa8995f60" lower="(nil)">    num[k] = 1;<Finish/></txt><txt ptr="0xa891c534" next="0xa891c5c4" prev="0xa891c4a4" upper="0xa8995f60" lower="(nil)">    for(int i=1; i&lt;=n; i++)<Finish/></txt><txt ptr="0xa891c5c4" next="0xa891c654" prev="0xa891c534" upper="0xa8995f60" lower="(nil)">        if(g[k][i] &amp;&amp; !num[i])<Finish/></txt><txt ptr="0xa891c654" next="0xa891c9b4" prev="0xa891c5c4" upper="0xa8995f60" lower="(nil)">            dfs(i);<Finish/></txt><txt ptr="0xa891c9b4" next="0xa891ca44" prev="0xa891c654" upper="0xa8995f60" lower="(nil)">    dfn[++cnt] = k;//记录第cnt个出栈的顶点为k<Finish/></txt><txt ptr="0xa891ca44" next="0xa891cad4" prev="0xa891c9b4" upper="0xa8995f60" lower="(nil)">}<Finish/></txt><txt ptr="0xa891cad4" next="0xa891cb64" prev="0xa891ca44" upper="0xa8995f60" lower="(nil)">void ndfs(int k) {<Finish/></txt><txt ptr="0xa891cb64" next="0xa891cbf4" prev="0xa891cad4" upper="0xa8995f60" lower="(nil)">num[k] = scc;*<Finish/></txt><txt ptr="0xa891cbf4" next="0xa891cc84" prev="0xa891cb64" upper="0xa8995f60" lower="(nil)">for(int i=1; i&lt;=n; i++)<Finish/></txt><txt ptr="0xa891cc84" next="(nil)" prev="0xa891cbf4" upper="0xa8995f60" lower="(nil)">        if(g[i][k] &amp;&amp; !num[i])*<Finish/></txt></body></column><column ptr="0xa8999c80" next="0xa8999ce4" prev="0xa8999c1c" upper="0xa891d410" lower="0xa99c8004"><body ptr="0xa99c8004" next="(nil)" prev="(nil)" upper="0xa8999c80" lower="0xa891cd14"><txt ptr="0xa891cd14" next="0xa891cda4" prev="(nil)" upper="0xa99c8004" lower="(nil)">            ndfs(i);<Finish/></txt><txt ptr="0xa891cda4" next="0xa891ce34" prev="0xa891cd14" upper="0xa99c8004" lower="(nil)">}<Finish/></txt><txt ptr="0xa891ce34" next="0xa891cec4" prev="0xa891cda4" upper="0xa99c8004" lower="(nil)">void kosaraju() {<Finish/></txt><txt ptr="0xa891cec4" next="0xa891cf54" prev="0xa891ce34" upper="0xa99c8004" lower="(nil)">    int i, j;<Finish/></txt><txt ptr="0xa891cf54" next="0xa88fe028" prev="0xa891cec4" upper="0xa99c8004" lower="(nil)">    for(i=1; i&lt;=n; i++)****        ***if(!num[i])<Finish/></txt><txt ptr="0xa88fe028" next="0xa88fe0b8" prev="0xa891cf54" upper="0xa99c8004" lower="(nil)">            dfs(i);<Finish/></txt><txt ptr="0xa88fe0b8" next="0xa88fe148" prev="0xa88fe028" upper="0xa99c8004" lower="(nil)">    memset(num, 0, sizeof num);<Finish/></txt><txt ptr="0xa88fe148" next="0xa88fe1d8" prev="0xa88fe0b8" upper="0xa99c8004" lower="(nil)">    for(i=n; i&gt;=1; i--)<Finish/></txt><txt ptr="0xa88fe1d8" next="0xa88fe268" prev="0xa88fe148" upper="0xa99c8004" lower="(nil)">        if(!num[dfn[i]]) {*<Finish/></txt><txt ptr="0xa88fe268" next="0xa88fe2f8" prev="0xa88fe1d8" upper="0xa99c8004" lower="(nil)">            scc++;<Finish/></txt><txt ptr="0xa88fe2f8" next="0xa88fe388" prev="0xa88fe268" upper="0xa99c8004" lower="(nil)">            ndfs(dfn[i]);<Finish/></txt><txt ptr="0xa88fe388" next="0xa88fe418" prev="0xa88fe2f8" upper="0xa99c8004" lower="(nil)">        }<Finish/></txt><txt ptr="0xa88fe418" next="0xa88fe4a8" prev="0xa88fe388" upper="0xa99c8004" lower="(nil)">    cout&lt;&lt;&quot;Found: &quot;&lt;&lt;scc&lt;&lt;endl;<Finish/></txt><txt ptr="0xa88fe4a8" next="0xa88fe538" prev="0xa88fe418" upper="0xa99c8004" lower="(nil)">}<Finish/></txt><txt ptr="0xa88fe538" next="0xa88fe5c8" prev="0xa88fe4a8" upper="0xa99c8004" lower="(nil)">邻接表储存<Finish/></txt><txt ptr="0xa88fe5c8" next="0xa88fe658" prev="0xa88fe538" upper="0xa99c8004" lower="(nil)">const int MAXN = 100;<Finish/></txt><txt ptr="0xa88fe658" next="0xa88fe6e8" prev="0xa88fe5c8" upper="0xa99c8004" lower="(nil)">vector&lt;int&gt; adj[ MAXN ] ; //正向邻接表<Finish/></txt><txt ptr="0xa88fe6e8" next="0xa88fe778" prev="0xa88fe658" upper="0xa99c8004" lower="(nil)">vector&lt;int&gt; radj[ MAXN ] ; //反向邻接表<Finish/></txt><txt ptr="0xa88fe778" next="0xa88fe808" prev="0xa88fe6e8" upper="0xa99c8004" lower="(nil)">vector&lt;int&gt; ord; //后序访问顺序<Finish/></txt><txt ptr="0xa88fe808" next="0xa88fe898" prev="0xa88fe778" upper="0xa99c8004" lower="(nil)">int vis[MAXN],cnt,n;<Finish/></txt><txt ptr="0xa88fe898" next="0xa88fe928" prev="0xa88fe808" upper="0xa99c8004" lower="(nil)"><Finish/></txt><txt ptr="0xa88fe928" next="0xa88fe9b8" prev="0xa88fe898" upper="0xa99c8004" lower="(nil)">void dfs ( int v ) {<Finish/></txt><txt ptr="0xa88fe9b8" next="0xa88fea48" prev="0xa88fe928" upper="0xa99c8004" lower="(nil)">    vis[v]=1;<Finish/></txt><txt ptr="0xa88fea48" next="0xa88fead8" prev="0xa88fe9b8" upper="0xa99c8004" lower="(nil)">    for (int i = 0, u, _size = adj[v].size(); i&lt; _size; i++ )<Finish/></txt><txt ptr="0xa88fead8" next="0xa88feb68" prev="0xa88fea48" upper="0xa99c8004" lower="(nil)">        if ( !vis[u=adj[v][i]] )<Finish/></txt><txt ptr="0xa88feb68" next="0xa88febf8" prev="0xa88fead8" upper="0xa99c8004" lower="(nil)">            dfs(u);<Finish/></txt><txt ptr="0xa88febf8" next="(nil)" prev="0xa88feb68" upper="0xa99c8004" lower="(nil)">    ord.push_back(v);<Finish/></txt></body></column><column ptr="0xa8999ce4" next="(nil)" prev="0xa8999c80" upper="0xa891d410" lower="0xa6c04a90"><body ptr="0xa6c04a90" next="(nil)" prev="(nil)" upper="0xa8999ce4" lower="0xa88fef58"><txt ptr="0xa88fef58" next="0xa88ff000" prev="(nil)" upper="0xa6c04a90" lower="(nil)">}<Finish/></txt><txt ptr="0xa88ff000" next="0xa88ff090" prev="0xa88fef58" upper="0xa6c04a90" lower="(nil)"><Finish/></txt><txt ptr="0xa88ff090" next="0xa88ff120" prev="0xa88ff000" upper="0xa6c04a90" lower="(nil)">void ndfs ( int v ) {<Finish/></txt><txt ptr="0xa88ff120" next="0xa88ff1b0" prev="0xa88ff090" upper="0xa6c04a90" lower="(nil)">    vis[v]=cnt;<Finish/></txt><txt ptr="0xa88ff1b0" next="0xa88ff240" prev="0xa88ff120" upper="0xa6c04a90" lower="(nil)">    for (int i = 0, u, _size = radj[v].size(); i &lt; _size; i++ )<Finish/></txt><txt ptr="0xa88ff240" next="0xa88ff2d0" prev="0xa88ff1b0" upper="0xa6c04a90" lower="(nil)">        if ( !vis[u=radj[v][i]] )<Finish/></txt><txt ptr="0xa88ff2d0" next="0xa88ff360" prev="0xa88ff240" upper="0xa6c04a90" lower="(nil)">            ndfs(u);<Finish/></txt><txt ptr="0xa88ff360" next="0xa88ff3f0" prev="0xa88ff2d0" upper="0xa6c04a90" lower="(nil)">}<Finish/></txt><txt ptr="0xa88ff3f0" next="0xa88ff480" prev="0xa88ff360" upper="0xa6c04a90" lower="(nil)"><Finish/></txt><txt ptr="0xa88ff480" next="0xa88ff510" prev="0xa88ff3f0" upper="0xa6c04a90" lower="(nil)">void kosaraju () {<Finish/></txt><txt ptr="0xa88ff510" next="0xa88ff5a0" prev="0xa88ff480" upper="0xa6c04a90" lower="(nil)">    int i;<Finish/></txt><txt ptr="0xa88ff5a0" next="0xa88ff630" prev="0xa88ff510" upper="0xa6c04a90" lower="(nil)">    memset(vis,0,sizeof(vis));<Finish/></txt><txt ptr="0xa88ff630" next="0xa88ff6c0" prev="0xa88ff5a0" upper="0xa6c04a90" lower="(nil)">    ord.clear();<Finish/></txt><txt ptr="0xa88ff6c0" next="0xa88ff750" prev="0xa88ff630" upper="0xa6c04a90" lower="(nil)"><Finish/></txt><txt ptr="0xa88ff750" next="0xa88ff7e0" prev="0xa88ff6c0" upper="0xa6c04a90" lower="(nil)">    for ( i=0 ; i&lt;n ; i++ )<Finish/></txt><txt ptr="0xa88ff7e0" next="0xa88ff870" prev="0xa88ff750" upper="0xa6c04a90" lower="(nil)">        if ( !vis[i] )<Finish/></txt><txt ptr="0xa88ff870" next="0xa88ff900" prev="0xa88ff7e0" upper="0xa6c04a90" lower="(nil)">            dfs(i);<Finish/></txt><txt ptr="0xa88ff900" next="0xa88ff990" prev="0xa88ff870" upper="0xa6c04a90" lower="(nil)"><Finish/></txt><txt ptr="0xa88ff990" next="0xa88ffa20" prev="0xa88ff900" upper="0xa6c04a90" lower="(nil)">    memset(vis,0,sizeof(vis));<Finish/></txt><txt ptr="0xa88ffa20" next="0xa88ffab0" prev="0xa88ff990" upper="0xa6c04a90" lower="(nil)">    for ( cnt=0,i=ord.size()-1 ; i&gt;=0 ; i-- )<Finish/></txt><txt ptr="0xa88ffab0" next="0xa88ffb40" prev="0xa88ffa20" upper="0xa6c04a90" lower="(nil)">        if ( !vis[ord[i]] ) {<Finish/></txt><txt ptr="0xa88ffb40" next="0xa88ffbd0" prev="0xa88ffab0" upper="0xa6c04a90" lower="(nil)">            ndfs(ord[i]);<Finish/></txt><txt ptr="0xa88ffbd0" next="0xa88ffc60" prev="0xa88ffb40" upper="0xa6c04a90" lower="(nil)">            cnt++;<Finish/></txt><txt ptr="0xa88ffc60" next="0xa88ffcf0" prev="0xa88ffbd0" upper="0xa6c04a90" lower="(nil)">        }<Finish/></txt><txt ptr="0xa88ffcf0" next="0xa88ffd80" prev="0xa88ffc60" upper="0xa6c04a90" lower="(nil)">}<Finish/></txt><txt ptr="0xa88ffd80" next="0xa88ffe10" prev="0xa88ffcf0" upper="0xa6c04a90" lower="(nil)"><Finish/></txt><txt ptr="0xa88ffe10" next="0xa88ffea0" prev="0xa88ffd80" upper="0xa6c04a90" lower="(nil)">Tarjan算法<Finish/></txt><txt ptr="0xa88ffea0" next="(nil)" prev="0xa88ffe10" upper="0xa6c04a90" lower="(nil)">#define  M 5010    //题目中可能的最大点数<Finish/></txt></body></column></section></body><footer ptr="0xa9986364" next="(nil)" prev="0xa99c8364" upper="0xa99967b8" lower="0xa89490b8"><txt ptr="0xa89490b8" next="0xa8935890" prev="(nil)" upper="0xa9986364" lower="(nil)"><anchored><fly ptr="0xac29a00" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa89491d8"><txt ptr="0xa89491d8" next="0xa894a6c0" prev="(nil)" upper="0xac29a00" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa894a6c0" next="(nil)" prev="0xa89491d8" upper="0xac29a00" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="5"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="4"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa8935890" next="(nil)" prev="0xa89490b8" upper="0xa9986364" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa999682c" next="0xa99968a0" prev="0xa99967b8" upper="0xb0726b0" lower="0xa99853c4"><header ptr="0xa99853c4" next="0xa6c04a30" prev="(nil)" upper="0xa999682c" lower="0xa8947b60"><txt ptr="0xa8947b60" next="(nil)" prev="(nil)" upper="0xa99853c4" lower="(nil)"><Finish/></txt></header><body ptr="0xa6c04a30" next="0xa99863c4" prev="0xa99853c4" upper="0xa999682c" lower="0xa99bc600"><section ptr="0xa99bc600" next="(nil)" prev="(nil)" upper="0xa6c04a30" lower="0xa6c03e48" follow="0xa891d490" precede="0xa891d410"><column ptr="0xa6c03e48" next="0xa6c03de4" prev="(nil)" upper="0xa99bc600" lower="0xa6c049d0"><body ptr="0xa6c049d0" next="(nil)" prev="(nil)" upper="0xa6c03e48" lower="0xa88fff30"><txt ptr="0xa88fff30" next="0xa8900004" prev="(nil)" upper="0xa6c049d0" lower="(nil)">int STACK[M],top=0;   //Tarjan 算法中的栈<Finish/></txt><txt ptr="0xa8900004" next="0xa8900094" prev="0xa88fff30" upper="0xa6c049d0" lower="(nil)">bool InStack[M];       //检查是否在栈中<Finish/></txt><txt ptr="0xa8900094" next="0xa8900124" prev="0xa8900004" upper="0xa6c049d0" lower="(nil)">int DFN[M];        //深度优先搜索访问次序<Finish/></txt><txt ptr="0xa8900124" next="0xa89001b4" prev="0xa8900094" upper="0xa6c049d0" lower="(nil)">int Low[M];          //能追溯到的最早的次序<Finish/></txt><txt ptr="0xa89001b4" next="0xa8900514" prev="0xa8900124" upper="0xa6c049d0" lower="(nil)">int ComponentNumber=0;   //有向图强连通分量个数<Finish/></txt><txt ptr="0xa8900514" next="0xa89005a4" prev="0xa89001b4" upper="0xa6c049d0" lower="(nil)">int Index=0;            //索引号<Finish/></txt><txt ptr="0xa89005a4" next="0xa8900634" prev="0xa8900514" upper="0xa6c049d0" lower="(nil)">vector &lt;int&gt; Edge[M];        //邻接表表示<Finish/></txt><txt ptr="0xa8900634" next="0xa89006c4" prev="0xa89005a4" upper="0xa6c049d0" lower="(nil)">vector &lt;int&gt; Component[M];   //获得强连通分量结果<Finish/></txt><txt ptr="0xa89006c4" next="0xa8900754" prev="0xa8900634" upper="0xa6c049d0" lower="(nil)">int InComponent[M]; //记录每个点在第几号强连通分量里<Finish/></txt><txt ptr="0xa8900754" next="0xa89007e4" prev="0xa89006c4" upper="0xa6c049d0" lower="(nil)">int ComponentDegree[M]; //记录每个强连通分量的度<Finish/></txt><txt ptr="0xa89007e4" next="0xa8900874" prev="0xa8900754" upper="0xa6c049d0" lower="(nil)">void Tarjan(int i) {<Finish/></txt><txt ptr="0xa8900874" next="0xa8900904" prev="0xa89007e4" upper="0xa6c049d0" lower="(nil)">    int j;<Finish/></txt><txt ptr="0xa8900904" next="0xa8900994" prev="0xa8900874" upper="0xa6c049d0" lower="(nil)">    DFN[i]=Low[i]=Index++;<Finish/></txt><txt ptr="0xa8900994" next="0xa8900a24" prev="0xa8900904" upper="0xa6c049d0" lower="(nil)">    InStack[i]=true;<Finish/></txt><txt ptr="0xa8900a24" next="0xa8900ab4" prev="0xa8900994" upper="0xa6c049d0" lower="(nil)">    STACK[++top]=i;<Finish/></txt><txt ptr="0xa8900ab4" next="0xa8900b44" prev="0xa8900a24" upper="0xa6c049d0" lower="(nil)">    for (int e=0; e&lt;Edge[i].size(); e++) {<Finish/></txt><txt ptr="0xa8900b44" next="0xa8900bd4" prev="0xa8900ab4" upper="0xa6c049d0" lower="(nil)">        j=Edge[i][e];<Finish/></txt><txt ptr="0xa8900bd4" next="0xa8900c64" prev="0xa8900b44" upper="0xa6c049d0" lower="(nil)">        if (DFN[j]==-1) {<Finish/></txt><txt ptr="0xa8900c64" next="0xa8900cf4" prev="0xa8900bd4" upper="0xa6c049d0" lower="(nil)">            Tarjan(j);<Finish/></txt><txt ptr="0xa8900cf4" next="0xa8900d84" prev="0xa8900c64" upper="0xa6c049d0" lower="(nil)">            Low[i]=min(Low[i],Low[j]);<Finish/></txt><txt ptr="0xa8900d84" next="0xa8900e14" prev="0xa8900cf4" upper="0xa6c049d0" lower="(nil)">        } else if (InStack[j])<Finish/></txt><txt ptr="0xa8900e14" next="0xa8900ea4" prev="0xa8900d84" upper="0xa6c049d0" lower="(nil)">            Low[i]=min(Low[i],DFN[j]);<Finish/></txt><txt ptr="0xa8900ea4" next="0xa8900f34" prev="0xa8900e14" upper="0xa6c049d0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8900f34" next="0xa8901008" prev="0xa8900ea4" upper="0xa6c049d0" lower="(nil)">    if (DFN[i]==Low[i]) {<Finish/></txt><txt ptr="0xa8901008" next="0xa8901098" prev="0xa8900f34" upper="0xa6c049d0" lower="(nil)">        ComponentNumber++;<Finish/></txt><txt ptr="0xa8901098" next="0xa8901128" prev="0xa8901008" upper="0xa6c049d0" lower="(nil)">        do {<Finish/></txt><txt ptr="0xa8901128" next="(nil)" prev="0xa8901098" upper="0xa6c049d0" lower="(nil)">            j=STACK[top--];<Finish/></txt></body></column><column ptr="0xa6c03de4" next="0xa6c03d80" prev="0xa6c03e48" upper="0xa99bc600" lower="0xa6c04970"><body ptr="0xa6c04970" next="(nil)" prev="(nil)" upper="0xa6c03de4" lower="0xa89011b8"><txt ptr="0xa89011b8" next="0xa8901248" prev="(nil)" upper="0xa6c04970" lower="(nil)">            InStack[j]=false;<Finish/></txt><txt ptr="0xa8901248" next="0xa89012d8" prev="0xa89011b8" upper="0xa6c04970" lower="(nil)">Component[ComponentNumber].push_back(j);<Finish/></txt><txt ptr="0xa89012d8" next="0xa8901368" prev="0xa8901248" upper="0xa6c04970" lower="(nil)">            InComponent[j]=ComponentNumber;<Finish/></txt><txt ptr="0xa8901368" next="0xa89013f8" prev="0xa89012d8" upper="0xa6c04970" lower="(nil)">        } while (j!=i);<Finish/></txt><txt ptr="0xa89013f8" next="0xa8901488" prev="0xa8901368" upper="0xa6c04970" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8901488" next="0xa8901518" prev="0xa89013f8" upper="0xa6c04970" lower="(nil)">}<Finish/></txt><txt ptr="0xa8901518" next="0xa89015a8" prev="0xa8901488" upper="0xa6c04970" lower="(nil)"><Finish/></txt><txt ptr="0xa89015a8" next="0xa8901638" prev="0xa8901518" upper="0xa6c04970" lower="(nil)">void solve(int N) { <Finish/></txt><txt ptr="0xa8901638" next="0xa89016c8" prev="0xa89015a8" upper="0xa6c04970" lower="(nil)">    memset(STACK,-1,sizeof(STACK));<Finish/></txt><txt ptr="0xa89016c8" next="0xa8901758" prev="0xa8901638" upper="0xa6c04970" lower="(nil)">    memset(InStack,0,sizeof(InStack));<Finish/></txt><txt ptr="0xa8901758" next="0xa8901ab8" prev="0xa89016c8" upper="0xa6c04970" lower="(nil)">    memset(DFN,-1,sizeof(DFN));<Finish/></txt><txt ptr="0xa8901ab8" next="0xa8901b48" prev="0xa8901758" upper="0xa6c04970" lower="(nil)">    memset(Low,-1,sizeof(Low));<Finish/></txt><txt ptr="0xa8901b48" next="0xa8901bd8" prev="0xa8901ab8" upper="0xa6c04970" lower="(nil)">    for(int i=0; i&lt;N; i++)<Finish/></txt><txt ptr="0xa8901bd8" next="0xa8901c68" prev="0xa8901b48" upper="0xa6c04970" lower="(nil)">        if(DFN[i]==-1)<Finish/></txt><txt ptr="0xa8901c68" next="0xa8901cf8" prev="0xa8901bd8" upper="0xa6c04970" lower="(nil)">            Tarjan(i);<Finish/></txt><txt ptr="0xa8901cf8" next="0xa8901d88" prev="0xa8901c68" upper="0xa6c04970" lower="(nil)">}<Finish/></txt><txt ptr="0xa8901d88" next="0xa8901e18" prev="0xa8901cf8" upper="0xa6c04970" lower="(nil)"><Finish/></txt><txt ptr="0xa8901e18" next="0xa8901ea8" prev="0xa8901d88" upper="0xa6c04970" lower="(nil)">Gabow算法<Finish/></txt><txt ptr="0xa8901ea8" next="0xa8901f38" prev="0xa8901e18" upper="0xa6c04970" lower="(nil)">类似于tarjan算法<Finish/></txt><txt ptr="0xa8901f38" next="0xa890300c" prev="0xa8901ea8" upper="0xa6c04970" lower="(nil)">几何<Finish/></txt><txt ptr="0xa890300c" next="0xa890309c" prev="0xa8901f38" upper="0xa6c04970" lower="(nil)">常量<Finish/></txt><txt ptr="0xa890309c" next="0xa890312c" prev="0xa890300c" upper="0xa6c04970" lower="(nil)">const double eps = 1e-8;<Finish/></txt><txt ptr="0xa890312c" next="0xa89031bc" prev="0xa890309c" upper="0xa6c04970" lower="(nil)">const double pi = acos(-1.0);<Finish/></txt><txt ptr="0xa89031bc" next="0xa890324c" prev="0xa890312c" upper="0xa6c04970" lower="(nil)">点<Finish/></txt><txt ptr="0xa890324c" next="(nil)" prev="0xa89031bc" upper="0xa6c04970" lower="(nil)">struct Point_2d {<Finish/></txt></body></column><column ptr="0xa6c03d80" next="(nil)" prev="0xa6c03de4" upper="0xa99bc600" lower="0xa6c04910"><body ptr="0xa6c04910" next="(nil)" prev="(nil)" upper="0xa6c03d80" lower="0xa89032dc"><txt ptr="0xa89032dc" next="0xa890336c" prev="(nil)" upper="0xa6c04910" lower="(nil)">    double x,y;<Finish/></txt><txt ptr="0xa890336c" next="0xa89033fc" prev="0xa89032dc" upper="0xa6c04910" lower="(nil)"> *Point_2d(double x=0,double y=0):x(x),y(y){}<Finish/></txt><txt ptr="0xa89033fc" next="0xa890348c" prev="0xa890336c" upper="0xa6c04910" lower="(nil)">};<Finish/></txt><txt ptr="0xa890348c" next="0xa890351c" prev="0xa89033fc" upper="0xa6c04910" lower="(nil)">两点间的距离<Finish/></txt><txt ptr="0xa890351c" next="0xa89035ac" prev="0xa890348c" upper="0xa6c04910" lower="(nil)">二维<Finish/></txt><txt ptr="0xa89035ac" next="0xa890363c" prev="0xa890351c" upper="0xa6c04910" lower="(nil)">double distance_2d(Point_2d &amp;a, Point_2d &amp;b) {<Finish/></txt><txt ptr="0xa890363c" next="0xa89036cc" prev="0xa89035ac" upper="0xa6c04910" lower="(nil)">    return(sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)));<Finish/></txt><txt ptr="0xa89036cc" next="0xa890375c" prev="0xa890363c" upper="0xa6c04910" lower="(nil)">}<Finish/></txt><txt ptr="0xa890375c" next="0xa89037ec" prev="0xa89036cc" upper="0xa6c04910" lower="(nil)">三维<Finish/></txt><txt ptr="0xa89037ec" next="0xa890387c" prev="0xa890375c" upper="0xa6c04910" lower="(nil)">double distance_3d(Point_3d &amp;a, Point_3d&amp;b) {<Finish/></txt><txt ptr="0xa890387c" next="0xa890390c" prev="0xa89037ec" upper="0xa6c04910" lower="(nil)">    return(sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z)));<Finish/></txt><txt ptr="0xa890390c" next="0xa890399c" prev="0xa890387c" upper="0xa6c04910" lower="(nil)">}<Finish/></txt><txt ptr="0xa890399c" next="0xa8903a2c" prev="0xa890390c" upper="0xa6c04910" lower="(nil)"><Finish/></txt><txt ptr="0xa8903a2c" next="0xa8903abc" prev="0xa890399c" upper="0xa6c04910" lower="(nil)">三角形面积<Finish/></txt><txt ptr="0xa8903abc" next="0xa8903b4c" prev="0xa8903a2c" upper="0xa6c04910" lower="(nil)">海伦公式<Finish/></txt><txt ptr="0xa8903b4c" next="0xa8903bdc" prev="0xa8903abc" upper="0xa6c04910" lower="(nil)">double triangleArea(Point_2d &amp;a,Point_2d &amp;b,Point_2d &amp;c) {<Finish/></txt><txt ptr="0xa8903bdc" next="0xa8903c6c" prev="0xa8903b4c" upper="0xa6c04910" lower="(nil)">    double aa,bb,cc,p,s;<Finish/></txt><txt ptr="0xa8903c6c" next="0xa8903cfc" prev="0xa8903bdc" upper="0xa6c04910" lower="(nil)">    ab=distance_2d(a,b);<Finish/></txt><txt ptr="0xa8903cfc" next="0xa89060a0" prev="0xa8903c6c" upper="0xa6c04910" lower="(nil)">    bc=distance_2d(b,c);<Finish/></txt><txt ptr="0xa89060a0" next="0xa8906130" prev="0xa8903cfc" upper="0xa6c04910" lower="(nil)">    ca=distance_2d(c,a);<Finish/></txt><txt ptr="0xa8906130" next="0xa89061c0" prev="0xa89060a0" upper="0xa6c04910" lower="(nil)">    p=(ab+bc+ca)/2;<Finish/></txt><txt ptr="0xa89061c0" next="0xa8906250" prev="0xa8906130" upper="0xa6c04910" lower="(nil)">    s=sqrt(p*(p-ab)*(p-bc)*(p-ca));<Finish/></txt><txt ptr="0xa8906250" next="0xa89062e0" prev="0xa89061c0" upper="0xa6c04910" lower="(nil)">    return s;<Finish/></txt><txt ptr="0xa89062e0" next="(nil)" prev="0xa8906250" upper="0xa6c04910" lower="(nil)">}<Finish/></txt></body></column></section></body><footer ptr="0xa99863c4" next="(nil)" prev="0xa6c04a30" upper="0xa999682c" lower="0xa8947a40"><txt ptr="0xa8947a40" next="0xa8935920" prev="(nil)" upper="0xa99863c4" lower="(nil)"><anchored><fly ptr="0xb354e60" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa89186d4"><txt ptr="0xa89186d4" next="0xa89359b0" prev="(nil)" upper="0xb354e60" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa89359b0" next="(nil)" prev="0xa89186d4" upper="0xb354e60" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="5"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="5"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa8935920" next="(nil)" prev="0xa8947a40" upper="0xa99863c4" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa99968a0" next="0xa9996914" prev="0xa999682c" upper="0xb0726b0" lower="0xa9985424"><header ptr="0xa9985424" next="0xa6c048b0" prev="(nil)" upper="0xa99968a0" lower="0xa89465bc"><txt ptr="0xa89465bc" next="(nil)" prev="(nil)" upper="0xa9985424" lower="(nil)"><Finish/></txt></header><body ptr="0xa6c048b0" next="0xa9986424" prev="0xa9985424" upper="0xa99968a0" lower="0xa891d490"><section ptr="0xa891d490" next="(nil)" prev="(nil)" upper="0xa6c048b0" lower="0xa8999e74" follow="0xa99bc800" precede="0xa99bc600"><column ptr="0xa8999e74" next="0xa8999ed8" prev="(nil)" upper="0xa891d490" lower="0xa6c04850"><body ptr="0xa6c04850" next="(nil)" prev="(nil)" upper="0xa8999e74" lower="0xa8906370"><txt ptr="0xa8906370" next="0xa8906400" prev="(nil)" upper="0xa6c04850" lower="(nil)">圆的储存<Finish/></txt><txt ptr="0xa8906400" next="0xa8906490" prev="0xa8906370" upper="0xa6c04850" lower="(nil)">struct C {<Finish/></txt><txt ptr="0xa8906490" next="0xa8906520" prev="0xa8906400" upper="0xa6c04850" lower="(nil)">    P mid;<Finish/></txt><txt ptr="0xa8906520" next="0xa89065b0" prev="0xa8906490" upper="0xa6c04850" lower="(nil)">    double r;<Finish/></txt><txt ptr="0xa89065b0" next="0xa8906640" prev="0xa8906520" upper="0xa6c04850" lower="(nil)">    C(const P &amp;_mid, const double &amp;_r)<Finish/></txt><txt ptr="0xa8906640" next="0xa89066d0" prev="0xa89065b0" upper="0xa6c04850" lower="(nil)">        :mid(_mid), r(_r) {}<Finish/></txt><txt ptr="0xa89066d0" next="0xa8906760" prev="0xa8906640" upper="0xa6c04850" lower="(nil)">    C() {}<Finish/></txt><txt ptr="0xa8906760" next="0xa89067f0" prev="0xa89066d0" upper="0xa6c04850" lower="(nil)">    bool operator == (const C &amp;a) const {<Finish/></txt><txt ptr="0xa89067f0" next="0xa8906880" prev="0xa8906760" upper="0xa6c04850" lower="(nil)">        return mid == a.mid &amp;&amp; sgn(r - a.r) == 0;<Finish/></txt><txt ptr="0xa8906880" next="0xa8906910" prev="0xa89067f0" upper="0xa6c04850" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8906910" next="0xa89069a0" prev="0xa8906880" upper="0xa6c04850" lower="(nil)">    bool in(const C &amp;a) const {<Finish/></txt><txt ptr="0xa89069a0" next="0xa8906a30" prev="0xa8906910" upper="0xa6c04850" lower="(nil)">        return sgn(r + dist(mid, a.mid) - a.r) &lt;= 0;<Finish/></txt><txt ptr="0xa8906a30" next="0xa8906ac0" prev="0xa89069a0" upper="0xa6c04850" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8906ac0" next="0xa8906b50" prev="0xa8906a30" upper="0xa6c04850" lower="(nil)">    const C &amp;input() {<Finish/></txt><txt ptr="0xa8906b50" next="0xa8906be0" prev="0xa8906ac0" upper="0xa6c04850" lower="(nil)">        mid.input();<Finish/></txt><txt ptr="0xa8906be0" next="0xa8906c70" prev="0xa8906b50" upper="0xa6c04850" lower="(nil)">        scanf(&quot;%lf&quot;, &amp;r);<Finish/></txt><txt ptr="0xa8906c70" next="0xa8906d00" prev="0xa8906be0" upper="0xa6c04850" lower="(nil)">        return *this;<Finish/></txt><txt ptr="0xa8906d00" next="0xa8906d90" prev="0xa8906c70" upper="0xa6c04850" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8906d90" next="0xa8906e20" prev="0xa8906d00" upper="0xa6c04850" lower="(nil)">    const C &amp;output() const {<Finish/></txt><txt ptr="0xa8906e20" next="0xa8906eb0" prev="0xa8906d90" upper="0xa6c04850" lower="(nil)">  printf(&quot;P: %.12lf %.12lf R: %.12lf\n&quot;, mid.x, mid.y, r);<Finish/></txt><txt ptr="0xa8906eb0" next="0xa8906f40" prev="0xa8906e20" upper="0xa6c04850" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8906f40" next="0xa8907014" prev="0xa8906eb0" upper="0xa6c04850" lower="(nil)">};<Finish/></txt><txt ptr="0xa8907014" next="0xa89070a4" prev="0xa8906f40" upper="0xa6c04850" lower="(nil)">圆相交 返回两个交点<Finish/></txt><txt ptr="0xa89070a4" next="0xa8907134" prev="0xa8907014" upper="0xa6c04850" lower="(nil)">bool circles_intersection(const C &amp;a, const C &amp;b, P &amp;c1, P &amp;c2) {<Finish/></txt><txt ptr="0xa8907134" next="(nil)" prev="0xa89070a4" upper="0xa6c04850" lower="(nil)">    double dd = dist(a.mid, b.mid);<Finish/></txt></body></column><column ptr="0xa8999ed8" next="0xa8999f3c" prev="0xa8999e74" upper="0xa891d490" lower="0xa6c047f0"><body ptr="0xa6c047f0" next="(nil)" prev="(nil)" upper="0xa8999ed8" lower="0xa89071c4"><txt ptr="0xa89071c4" next="0xa8907254" prev="(nil)" upper="0xa6c047f0" lower="(nil)">    if (sgn(dd - (a.r + b.r)) &gt;= 0) {<Finish/></txt><txt ptr="0xa8907254" next="0xa89072e4" prev="0xa89071c4" upper="0xa6c047f0" lower="(nil)">        return false;<Finish/></txt><txt ptr="0xa89072e4" next="0xa8907644" prev="0xa8907254" upper="0xa6c047f0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8907644" next="0xa89076d4" prev="0xa89072e4" upper="0xa6c047f0" lower="(nil)">    double l = (dd + (SQR(a.r) - SQR(b.r)) / dd) / 2;<Finish/></txt><txt ptr="0xa89076d4" next="0xa8907764" prev="0xa8907644" upper="0xa6c047f0" lower="(nil)">    double h = sqrt(SQR(a.r) - SQR(l));<Finish/></txt><txt ptr="0xa8907764" next="0xa89077f4" prev="0xa89076d4" upper="0xa6c047f0" lower="(nil)">    c1 = a.mid + (b.mid - a.mid).trunc(l) + (b.mid - a.mid).turn_left().trunc(h);<Finish/></txt><txt ptr="0xa89077f4" next="0xa8907884" prev="0xa8907764" upper="0xa6c047f0" lower="(nil)">    c2 = a.mid + (b.mid - a.mid).trunc(l) + (b.mid - a.mid).turn_right().trunc(h);<Finish/></txt><txt ptr="0xa8907884" next="0xa8907914" prev="0xa89077f4" upper="0xa6c047f0" lower="(nil)">    return true;<Finish/></txt><txt ptr="0xa8907914" next="0xa89079a4" prev="0xa8907884" upper="0xa6c047f0" lower="(nil)">}<Finish/></txt><txt ptr="0xa89079a4" next="0xa8907a34" prev="0xa8907914" upper="0xa6c047f0" lower="(nil)">(po,ps) X (po,pe)<Finish/></txt><txt ptr="0xa8907a34" next="0xa8907ac4" prev="0xa89079a4" upper="0xa6c047f0" lower="(nil)">    static double xmult(Point_2d &amp;ps, Point_2d &amp;pe,Point_2d &amp;po){<Finish/></txt><txt ptr="0xa8907ac4" next="0xa8907b54" prev="0xa8907a34" upper="0xa6c047f0" lower="(nil)">        return (ps.x - po.x)*(pe.y - po.y) - (pe.x - po.x)*(ps.y - po.y);<Finish/></txt><txt ptr="0xa8907b54" next="0xa8907be4" prev="0xa8907ac4" upper="0xa6c047f0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8907be4" next="0xa8907c74" prev="0xa8907b54" upper="0xa6c047f0" lower="(nil)"><Finish/></txt><txt ptr="0xa8907c74" next="0xa8907d04" prev="0xa8907be4" upper="0xa6c047f0" lower="(nil)">相对偏移<Finish/></txt><txt ptr="0xa8907d04" next="0xa8907d94" prev="0xa8907c74" upper="0xa6c047f0" lower="(nil)">    Point_2d operator - (const Point_2d &amp;_Off)const{<Finish/></txt><txt ptr="0xa8907d94" next="0xa8907e24" prev="0xa8907d04" upper="0xa6c047f0" lower="(nil)">        return Point_2d(x - _Off.x, y - _Off.y);<Finish/></txt><txt ptr="0xa8907e24" next="0xa8907eb4" prev="0xa8907d94" upper="0xa6c047f0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8907eb4" next="0xa8907f44" prev="0xa8907e24" upper="0xa6c047f0" lower="(nil)"><Finish/></txt><txt ptr="0xa8907f44" next="0xa8908018" prev="0xa8907eb4" upper="0xa6c047f0" lower="(nil)"><Finish/></txt><txt ptr="0xa8908018" next="0xa89080a8" prev="0xa8907f44" upper="0xa6c047f0" lower="(nil)">    Point_2d operator + (const Point_2d &amp;_Off)const{<Finish/></txt><txt ptr="0xa89080a8" next="0xa8908138" prev="0xa8908018" upper="0xa6c047f0" lower="(nil)">        return Point_2d(x + _Off.x, y + _Off.y);<Finish/></txt><txt ptr="0xa8908138" next="0xa89081c8" prev="0xa89080a8" upper="0xa6c047f0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89081c8" next="(nil)" prev="0xa8908138" upper="0xa6c047f0" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa8999f3c" next="(nil)" prev="0xa8999ed8" upper="0xa891d490" lower="0xa6c04790"><body ptr="0xa6c04790" next="(nil)" prev="(nil)" upper="0xa8999f3c" lower="0xa8908258"><txt ptr="0xa8908258" next="0xa89082e8" prev="(nil)" upper="0xa6c04790" lower="(nil)">逆时针旋转<Finish/></txt><txt ptr="0xa89082e8" next="0xa8908378" prev="0xa8908258" upper="0xa6c04790" lower="(nil)">    Point_2d toLeft(){<Finish/></txt><txt ptr="0xa8908378" next="0xa8908408" prev="0xa89082e8" upper="0xa6c04790" lower="(nil)">        return Point_2d(-y, x);<Finish/></txt><txt ptr="0xa8908408" next="0xa8908498" prev="0xa8908378" upper="0xa6c04790" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8908498" next="0xa8908528" prev="0xa8908408" upper="0xa6c04790" lower="(nil)"><Finish/></txt><txt ptr="0xa8908528" next="0xa89085b8" prev="0xa8908498" upper="0xa6c04790" lower="(nil)">设置向量的模<Finish/></txt><txt ptr="0xa89085b8" next="0xa8908648" prev="0xa8908528" upper="0xa6c04790" lower="(nil)">    Point_2d setLength(double len){<Finish/></txt><txt ptr="0xa8908648" next="0xa89086d8" prev="0xa89085b8" upper="0xa6c04790" lower="(nil)">        double _len = sqrt(x * x + y * y);<Finish/></txt><txt ptr="0xa89086d8" next="0xa8908768" prev="0xa8908648" upper="0xa6c04790" lower="(nil)">        return Point_2d(x * len / _len , y * len / _len);<Finish/></txt><txt ptr="0xa8908768" next="0xa89087f8" prev="0xa89086d8" upper="0xa6c04790" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89087f8" next="0xa8908888" prev="0xa8908768" upper="0xa6c04790" lower="(nil)"><Finish/></txt><txt ptr="0xa8908888" next="0xa8908be8" prev="0xa89087f8" upper="0xa6c04790" lower="(nil)">判断点是否重合<Finish/></txt><txt ptr="0xa8908be8" next="0xa8908c78" prev="0xa8908888" upper="0xa6c04790" lower="(nil)">    bool operator == (const Point_2d&amp; _point)const{<Finish/></txt><txt ptr="0xa8908c78" next="0xa8908d08" prev="0xa8908be8" upper="0xa6c04790" lower="(nil)">        return fabs(_point.x - x) &lt; eps &amp;&amp; fabs(_point.y - y) &lt; eps;<Finish/></txt><txt ptr="0xa8908d08" next="0xa8908d98" prev="0xa8908c78" upper="0xa6c04790" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8908d98" next="0xa8908e28" prev="0xa8908d08" upper="0xa6c04790" lower="(nil)"><Finish/></txt><txt ptr="0xa8908e28" next="0xa8908eb8" prev="0xa8908d98" upper="0xa6c04790" lower="(nil)">判断点是否不重合<Finish/></txt><txt ptr="0xa8908eb8" next="0xa8908f48" prev="0xa8908e28" upper="0xa6c04790" lower="(nil)">    bool operator != (const Point_2d&amp; _point)const{<Finish/></txt><txt ptr="0xa8908f48" next="0xa890901c" prev="0xa8908eb8" upper="0xa6c04790" lower="(nil)">        return ((*this) == _point) == false;<Finish/></txt><txt ptr="0xa890901c" next="0xa89090ac" prev="0xa8908f48" upper="0xa6c04790" lower="(nil)">    }<Finish/></txt><txt ptr="0xa89090ac" next="0xa890913c" prev="0xa890901c" upper="0xa6c04790" lower="(nil)"><Finish/></txt><txt ptr="0xa890913c" next="0xa89091cc" prev="0xa89090ac" upper="0xa6c04790" lower="(nil)">两点间的距离的平方<Finish/></txt><txt ptr="0xa89091cc" next="0xa890925c" prev="0xa890913c" upper="0xa6c04790" lower="(nil)">    double dis2(const Point_2d &amp;_Off)const{<Finish/></txt><txt ptr="0xa890925c" next="0xa89092ec" prev="0xa89091cc" upper="0xa6c04790" lower="(nil)">        return (x - _Off.x)*(x - _Off.x) + (y - _Off.y)*(y - _Off.y);<Finish/></txt><txt ptr="0xa89092ec" next="0xa890937c" prev="0xa890925c" upper="0xa6c04790" lower="(nil)">    }<Finish/></txt><txt ptr="0xa890937c" next="(nil)" prev="0xa89092ec" upper="0xa6c04790" lower="(nil)"><Finish/></txt></body></column></section></body><footer ptr="0xa9986424" next="(nil)" prev="0xa6c048b0" upper="0xa99968a0" lower="0xa894649c"><txt ptr="0xa894649c" next="0xa8947bf0" prev="(nil)" upper="0xa9986424" lower="(nil)"><anchored><fly ptr="0xabd0b28" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa8947c80"><txt ptr="0xa8947c80" next="0xa8947ad0" prev="(nil)" upper="0xabd0b28" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa8947ad0" next="(nil)" prev="0xa8947c80" upper="0xabd0b28" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="5"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="6"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa8947bf0" next="(nil)" prev="0xa894649c" upper="0xa9986424" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996914" next="0xa9996988" prev="0xa99968a0" upper="0xb0726b0" lower="0xa9985484"><header ptr="0xa9985484" next="0xa6c04730" prev="(nil)" upper="0xa9996914" lower="0xa8944eb4"><txt ptr="0xa8944eb4" next="(nil)" prev="(nil)" upper="0xa9985484" lower="(nil)"><Finish/></txt></header><body ptr="0xa6c04730" next="0xa9986484" prev="0xa9985484" upper="0xa9996914" lower="0xa99bc800"><section ptr="0xa99bc800" next="(nil)" prev="(nil)" upper="0xa6c04730" lower="0xa6c03bf0" follow="0xa99bc900" precede="0xa891d490"><column ptr="0xa6c03bf0" next="0xa6c03b8c" prev="(nil)" upper="0xa99bc800" lower="0xa6c046d0"><body ptr="0xa6c046d0" next="(nil)" prev="(nil)" upper="0xa6c03bf0" lower="0xa890940c"><txt ptr="0xa890940c" next="0xa890949c" prev="(nil)" upper="0xa6c046d0" lower="(nil)">两点间的距离<Finish/></txt><txt ptr="0xa890949c" next="0xa890952c" prev="0xa890940c" upper="0xa6c046d0" lower="(nil)">    double dis(const Point_2d &amp;_Off)const{<Finish/></txt><txt ptr="0xa890952c" next="0xa89095bc" prev="0xa890949c" upper="0xa6c046d0" lower="(nil)">        return sqrt(dis2(_Off));<Finish/></txt><txt ptr="0xa89095bc" next="0xa890964c" prev="0xa890952c" upper="0xa6c046d0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa890964c" next="0xa89096dc" prev="0xa89095bc" upper="0xa6c046d0" lower="(nil)">};<Finish/></txt><txt ptr="0xa89096dc" next="0xa890976c" prev="0xa890964c" upper="0xa6c046d0" lower="(nil)">向量<Finish/></txt><txt ptr="0xa890976c" next="0xa89097fc" prev="0xa89096dc" upper="0xa6c046d0" lower="(nil)">se,起点s,终点e.<Finish/></txt><txt ptr="0xa89097fc" next="0xa890988c" prev="0xa890976c" upper="0xa6c046d0" lower="(nil)">struct pVector{<Finish/></txt><txt ptr="0xa890988c" next="0xa890991c" prev="0xa89097fc" upper="0xa6c046d0" lower="(nil)">    Point_2d s,e;<Finish/></txt><txt ptr="0xa890991c" next="0xa89099ac" prev="0xa890988c" upper="0xa6c046d0" lower="(nil)">    double a,b,c;<Finish/></txt><txt ptr="0xa89099ac" next="0xa8909a3c" prev="0xa890991c" upper="0xa6c046d0" lower="(nil)"><Finish/></txt><txt ptr="0xa8909a3c" next="0xa8909acc" prev="0xa89099ac" upper="0xa6c046d0" lower="(nil)">    pVector(){}<Finish/></txt><txt ptr="0xa8909acc" next="0xa8909b5c" prev="0xa8909a3c" upper="0xa6c046d0" lower="(nil)">    pVector(const Point_2d &amp; s,const Point_2d &amp; e):s(s),e(e){}<Finish/></txt><txt ptr="0xa8909b5c" next="0xa8909bec" prev="0xa8909acc" upper="0xa6c046d0" lower="(nil)"> 判断点相对向量的位置  AB = |A||B|Cos(θ)<Finish/></txt><txt ptr="0xa8909bec" next="0xa8909c7c" prev="0xa8909b5c" upper="0xa6c046d0" lower="(nil)">    double operator*(const Point_2d&amp; _Off)const{<Finish/></txt><txt ptr="0xa8909c7c" next="0xa8909d0c" prev="0xa8909bec" upper="0xa6c046d0" lower="(nil)">        return (e.x - s.x)*(_Off.y - s.y) - (_Off.x - s.x)*(e.y - s.y);<Finish/></txt><txt ptr="0xa8909d0c" next="0xa8909d9c" prev="0xa8909c7c" upper="0xa6c046d0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa8909d9c" next="0xa8909e2c" prev="0xa8909d0c" upper="0xa6c046d0" lower="(nil)"><Finish/></txt><txt ptr="0xa8909e2c" next="0xa890a1d0" prev="0xa8909d9c" upper="0xa6c046d0" lower="(nil)">向量的叉积<Finish/></txt><txt ptr="0xa890a1d0" next="0xa890a260" prev="0xa8909e2c" upper="0xa6c046d0" lower="(nil)">    double operator * (const pVector&amp; _Off)const{<Finish/></txt><txt ptr="0xa890a260" next="0xa890a2f0" prev="0xa890a1d0" upper="0xa6c046d0" lower="(nil)">        return (e.x - s.x)*(_Off.e.y - _Off.s.y) - (e.y - s.y)*(_Off.e.x - _Off.s.x);<Finish/></txt><txt ptr="0xa890a2f0" next="0xa890a380" prev="0xa890a260" upper="0xa6c046d0" lower="(nil)">    }<Finish/></txt><txt ptr="0xa890a380" next="(nil)" prev="0xa890a2f0" upper="0xa6c046d0" lower="(nil)"><Finish/></txt></body></column><column ptr="0xa6c03b8c" next="0xa6c03b28" prev="0xa6c03bf0" upper="0xa99bc800" lower="0xa6c04670"><body ptr="0xa6c04670" next="(nil)" prev="(nil)" upper="0xa6c03b8c" lower="0xa890a410"><txt ptr="0xa890a410" next="0xa890a4a0" prev="(nil)" upper="0xa6c04670" lower="(nil)">求直线的a,b,c.<Finish/></txt><txt ptr="0xa890a4a0" next="0xa890a530" prev="0xa890a410" upper="0xa6c04670" lower="(nil)">    void toLine(){<Finish/></txt><txt ptr="0xa890a530" next="0xa890a5c0" prev="0xa890a4a0" upper="0xa6c04670" lower="(nil)">        a = s.y - e.y;<Finish/></txt><txt ptr="0xa890a5c0" next="0xa890a650" prev="0xa890a530" upper="0xa6c04670" lower="(nil)">        b = e.x - s.x;<Finish/></txt><txt ptr="0xa890a650" next="0xa890a6e0" prev="0xa890a5c0" upper="0xa6c04670" lower="(nil)">        c = s.x * e.y - s.y * e.x;<Finish/></txt><txt ptr="0xa890a6e0" next="0xa890a770" prev="0xa890a650" upper="0xa6c04670" lower="(nil)">    }<Finish/></txt><txt ptr="0xa890a770" next="0xa890a800" prev="0xa890a6e0" upper="0xa6c04670" lower="(nil)"><Finish/></txt><txt ptr="0xa890a800" next="0xa890a890" prev="0xa890a770" upper="0xa6c04670" lower="(nil)">判断点在向量左边<Finish/></txt><txt ptr="0xa890a890" next="0xa890a920" prev="0xa890a800" upper="0xa6c04670" lower="(nil)">    bool operator &lt; (const Point_2d&amp; _Off){<Finish/></txt><txt ptr="0xa890a920" next="0xa890a9b0" prev="0xa890a890" upper="0xa6c04670" lower="(nil)">        return (_Off.x - s.x)*(e.y - s.y) &lt; (e.x - s.x)*(_Off.y - s.y);<Finish/></txt><txt ptr="0xa890a9b0" next="0xa890aa40" prev="0xa890a920" upper="0xa6c04670" lower="(nil)">    }<Finish/></txt><txt ptr="0xa890aa40" next="0xa890aad0" prev="0xa890a9b0" upper="0xa6c04670" lower="(nil)"><Finish/></txt><txt ptr="0xa890aad0" next="0xa890ab60" prev="0xa890aa40" upper="0xa6c04670" lower="(nil)">点在直线上<Finish/></txt><txt ptr="0xa890ab60" next="0xa890abf0" prev="0xa890aad0" upper="0xa6c04670" lower="(nil)">    bool inLine(const Point_2d&amp; _Off)const{<Finish/></txt><txt ptr="0xa890abf0" next="0xa890ac80" prev="0xa890ab60" upper="0xa6c04670" lower="(nil)">        return fabs((*this)*_Off) &lt; eps;<Finish/></txt><txt ptr="0xa890ac80" next="0xa890ad10" prev="0xa890abf0" upper="0xa6c04670" lower="(nil)">    }<Finish/></txt><txt ptr="0xa890ad10" next="0xa890ada0" prev="0xa890ac80" upper="0xa6c04670" lower="(nil)"><Finish/></txt><txt ptr="0xa890ada0" next="0xa890ae30" prev="0xa890ad10" upper="0xa6c04670" lower="(nil)">点在线段上<Finish/></txt><txt ptr="0xa890ae30" next="0xa890aec0" prev="0xa890ada0" upper="0xa6c04670" lower="(nil)">    bool inSeg(const Point_2d&amp; _Off)const{<Finish/></txt><txt ptr="0xa890aec0" next="0xa890af50" prev="0xa890ae30" upper="0xa6c04670" lower="(nil)">        return inLine(_Off) &amp;&amp; (s.x - _Off.x)*(e.x - _Off.x) &lt;= 0;<Finish/></txt><txt ptr="0xa890af50" next="0xa890b024" prev="0xa890aec0" upper="0xa6c04670" lower="(nil)">    }<Finish/></txt><txt ptr="0xa890b024" next="0xa890b0b4" prev="0xa890af50" upper="0xa6c04670" lower="(nil)">点到直线的距离<Finish/></txt><txt ptr="0xa890b0b4" next="0xa890b144" prev="0xa890b024" upper="0xa6c04670" lower="(nil)">    double dis(const Point_2d&amp;_Off){<Finish/></txt><txt ptr="0xa890b144" next="0xa890b1d4" prev="0xa890b0b4" upper="0xa6c04670" lower="(nil)">        toLine();<Finish/></txt><txt ptr="0xa890b1d4" next="(nil)" prev="0xa890b144" upper="0xa6c04670" lower="(nil)">        return fabs((a * _Off.x + b * _Off.y + c)/sqrt(a*a + b*b));<Finish/></txt></body></column><column ptr="0xa6c03b28" next="(nil)" prev="0xa6c03b8c" upper="0xa99bc800" lower="0xa8902424"><body ptr="0xa8902424" next="(nil)" prev="(nil)" upper="0xa6c03b28" lower="0xa890b264"><txt ptr="0xa890b264" next="0xa890b2f4" prev="(nil)" upper="0xa8902424" lower="(nil)">    }<Finish/></txt><txt ptr="0xa890b2f4" next="0xa890b384" prev="0xa890b264" upper="0xa8902424" lower="(nil)">};<Finish/></txt><txt ptr="0xa890b384" next="0xa890b414" prev="0xa890b2f4" upper="0xa8902424" lower="(nil)"><Finish/></txt><txt ptr="0xa890b414" next="0xa890b774" prev="0xa890b384" upper="0xa8902424" lower="(nil)"><Finish/></txt><txt ptr="0xa890b774" next="0xa890b804" prev="0xa890b414" upper="0xa8902424" lower="(nil)">JAVA<Finish/></txt><txt ptr="0xa890b804" next="0xa890b894" prev="0xa890b774" upper="0xa8902424" lower="(nil)">大数<Finish/></txt><txt ptr="0xa890b894" next="0xa890b924" prev="0xa890b804" upper="0xa8902424" lower="(nil)">import java.math.BigInteger;<Finish/></txt><txt ptr="0xa890b924" next="0xa890b9b4" prev="0xa890b894" upper="0xa8902424" lower="(nil)">import java.util.Scanner;<Finish/></txt><txt ptr="0xa890b9b4" next="0xa890ba44" prev="0xa890b924" upper="0xa8902424" lower="(nil)"><Finish/></txt><txt ptr="0xa890ba44" next="0xa890bad4" prev="0xa890b9b4" upper="0xa8902424" lower="(nil)">public class Main {<Finish/></txt><txt ptr="0xa890bad4" next="0xa890bb64" prev="0xa890ba44" upper="0xa8902424" lower="(nil)">*public static void main(String[] args) {<Finish/></txt><txt ptr="0xa890bb64" next="0xa890bbf4" prev="0xa890bad4" upper="0xa8902424" lower="(nil)">**BigInteger a;<Finish/></txt><txt ptr="0xa890bbf4" next="0xa890bc84" prev="0xa890bb64" upper="0xa8902424" lower="(nil)">**Scanner cin = new Scanner(System.in);<Finish/></txt><txt ptr="0xa890bc84" next="0xa890bd14" prev="0xa890bbf4" upper="0xa8902424" lower="(nil)">**while (cin.hasNextBigInteger()) {<Finish/></txt><txt ptr="0xa890bd14" next="0xa890bda4" prev="0xa890bc84" upper="0xa8902424" lower="(nil)">***a = cin.nextBigInteger();<Finish/></txt><txt ptr="0xa890bda4" next="0xa890be34" prev="0xa890bd14" upper="0xa8902424" lower="(nil)">***System.out.println(a.toString());<Finish/></txt><txt ptr="0xa890be34" next="0xa890bec4" prev="0xa890bda4" upper="0xa8902424" lower="(nil)">**}<Finish/></txt><txt ptr="0xa890bec4" next="0xa890bf54" prev="0xa890be34" upper="0xa8902424" lower="(nil)"><Finish/></txt><txt ptr="0xa890bf54" next="0xa890c028" prev="0xa890bec4" upper="0xa8902424" lower="(nil)">*}<Finish/></txt><txt ptr="0xa890c028" next="0xa890c0b8" prev="0xa890bf54" upper="0xa8902424" lower="(nil)">}<Finish/></txt><txt ptr="0xa890c0b8" next="0xa890c148" prev="0xa890c028" upper="0xa8902424" lower="(nil)">127库函数之数学函数<Finish/></txt><txt ptr="0xa890c148" next="0xa890c1d8" prev="0xa890c0b8" upper="0xa8902424" lower="(nil)">1. 绝对值<Finish/></txt><txt ptr="0xa890c1d8" next="0xa890c268" prev="0xa890c148" upper="0xa8902424" lower="(nil)">int    abs(int i) 返回整型参数i的绝对值<Finish/></txt><txt ptr="0xa890c268" next="(nil)" prev="0xa890c1d8" upper="0xa8902424" lower="(nil)">double cabs(struct complex znum) <Finish/></txt></body></column></section></body><footer ptr="0xa9986484" next="(nil)" prev="0xa6c04730" upper="0xa9996914" lower="0xa89466dc"><txt ptr="0xa89466dc" next="0xa8935800" prev="(nil)" upper="0xa9986484" lower="(nil)"><anchored><fly ptr="0xb7ca360" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa894652c"><txt ptr="0xa894652c" next="0xa894664c" prev="(nil)" upper="0xb7ca360" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa894664c" next="(nil)" prev="0xa894652c" upper="0xb7ca360" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="5"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="7"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa8935800" next="(nil)" prev="0xa89466dc" upper="0xa9986484" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page><page ptr="0xa9996988" next="(nil)" prev="0xa9996914" upper="0xb0726b0" lower="0xa99854e4"><header ptr="0xa99854e4" next="0xa89023c4" prev="(nil)" upper="0xa9996988" lower="0xa8943910"><txt ptr="0xa8943910" next="(nil)" prev="(nil)" upper="0xa99854e4" lower="(nil)"><Finish/></txt></header><body ptr="0xa89023c4" next="0xa99864e4" prev="0xa99854e4" upper="0xa9996988" lower="0xa99bc900"><section ptr="0xa99bc900" next="(nil)" prev="(nil)" upper="0xa89023c4" lower="0xa6c03ac4" precede="0xa99bc800"><column ptr="0xa6c03ac4" next="0xa6c03a60" prev="(nil)" upper="0xa99bc900" lower="0xa8902364"><body ptr="0xa8902364" next="(nil)" prev="(nil)" upper="0xa6c03ac4" lower="0xa890c2f8"><txt ptr="0xa890c2f8" next="0xa890c388" prev="(nil)" upper="0xa8902364" lower="(nil)">返回复数znum的绝对值<Finish/></txt><txt ptr="0xa890c388" next="0xa890c418" prev="0xa890c2f8" upper="0xa8902364" lower="(nil)">double fabs(double x)    返回双精度参数x的绝对值<Finish/></txt><txt ptr="0xa890c418" next="0xa890c4a8" prev="0xa890c388" upper="0xa8902364" lower="(nil)">long   labs(long n) 返回长整型参数n的绝对值<Finish/></txt><txt ptr="0xa890c4a8" next="0xa890c538" prev="0xa890c418" upper="0xa8902364" lower="(nil)">2. 指数与对数<Finish/></txt><txt ptr="0xa890c538" next="0xa890c5c8" prev="0xa890c4a8" upper="0xa8902364" lower="(nil)">double exp(double x)    返回指数函数ex的值<Finish/></txt><txt ptr="0xa890c5c8" next="0xa890c658" prev="0xa890c538" upper="0xa8902364" lower="(nil)">double log(double x)    返回logex的值<Finish/></txt><txt ptr="0xa890c658" next="0xa890c6e8" prev="0xa890c5c8" upper="0xa8902364" lower="(nil)">double log10(double x)  返回log10x的值<Finish/></txt><txt ptr="0xa890c6e8" next="0xa890c778" prev="0xa890c658" upper="0xa8902364" lower="(nil)">double pow(double x,double y) 返回xy的值<Finish/></txt><txt ptr="0xa890c778" next="0xa890c808" prev="0xa890c6e8" upper="0xa8902364" lower="(nil)">double pow10(int p)         返回10p的值<Finish/></txt><txt ptr="0xa890c808" next="0xa890c898" prev="0xa890c778" upper="0xa8902364" lower="(nil)">double sqrt(double x)        返回+√x的值<Finish/></txt><txt ptr="0xa890c898" next="0xa890c928" prev="0xa890c808" upper="0xa8902364" lower="(nil)">3. 反三角函数<Finish/></txt><txt ptr="0xa890c928" next="0xa890c9b8" prev="0xa890c898" upper="0xa8902364" lower="(nil)">double acos(double x) 求反余弦cos-1(x)值,x为弧度<Finish/></txt><txt ptr="0xa890c9b8" next="0xa890cd18" prev="0xa890c928" upper="0xa8902364" lower="(nil)">double asin(double x) 求反正弦sin-1(x)值,x为弧度<Finish/></txt><txt ptr="0xa890cd18" next="0xa890cda8" prev="0xa890c9b8" upper="0xa8902364" lower="(nil)">double atan(double x) 求反正切tan-1(x)值,x为弧度<Finish/></txt><txt ptr="0xa890cda8" next="0xa890ce38" prev="0xa890cd18" upper="0xa8902364" lower="(nil)">double atan2(double y,double x)<Finish/></txt><txt ptr="0xa890ce38" next="0xa890cec8" prev="0xa890cda8" upper="0xa8902364" lower="(nil)">返回y/x的反正切tan-1(x)值,y的x为弧度<Finish/></txt><txt ptr="0xa890cec8" next="0xa890cf58" prev="0xa890ce38" upper="0xa8902364" lower="(nil)">4. 三角函数<Finish/></txt><txt ptr="0xa890cf58" next="0xa890d000" prev="0xa890cec8" upper="0xa8902364" lower="(nil)">double cos(double x)  返回x的余弦cos(x)值,x为弧度<Finish/></txt><txt ptr="0xa890d000" next="0xa890d090" prev="0xa890cf58" upper="0xa8902364" lower="(nil)">double sin(double x)  返回x的正弦sin(x)值,x为弧度<Finish/></txt><txt ptr="0xa890d090" next="0xa890d120" prev="0xa890d000" upper="0xa8902364" lower="(nil)">double tan(double x)  返回x的正切tan(x)值,x为弧度<Finish/></txt><txt ptr="0xa890d120" next="0xa890d1b0" prev="0xa890d090" upper="0xa8902364" lower="(nil)">5. 双曲三角函数<Finish/></txt><txt ptr="0xa890d1b0" next="0xa890d240" prev="0xa890d120" upper="0xa8902364" lower="(nil)">double cosh(double x)求双曲余弦cosh(x)值,x为弧度<Finish/></txt><txt ptr="0xa890d240" next="0xa890d2d0" prev="0xa890d1b0" upper="0xa8902364" lower="(nil)">double sinh(double x)求双曲正弦sinh(x)值,x为弧度<Finish/></txt><txt ptr="0xa890d2d0" next="0xa890d360" prev="0xa890d240" upper="0xa8902364" lower="(nil)">double tanh(double x)求双曲正切tanh(x)值,x为弧度<Finish/></txt><txt ptr="0xa890d360" next="0xa890d3f0" prev="0xa890d2d0" upper="0xa8902364" lower="(nil)">double hypot(double x,double y)        <Finish/></txt><txt ptr="0xa890d3f0" next="(nil)" prev="0xa890d360" upper="0xa8902364" lower="(nil)">返回直角三角形斜边的长度(z),x和y为直角边的长度,z2=x2+y2<Finish/></txt></body></column><column ptr="0xa6c03a60" next="0xa6c039fc" prev="0xa6c03ac4" upper="0xa99bc900" lower="0xa8902124"><body ptr="0xa8902124" next="(nil)" prev="(nil)" upper="0xa6c03a60" lower="0xa890d480"><txt ptr="0xa890d480" next="0xa890d510" prev="(nil)" upper="0xa8902124" lower="(nil)">6. 取整<Finish/></txt><txt ptr="0xa890d510" next="0xa890d5a0" prev="0xa890d480" upper="0xa8902124" lower="(nil)">double ceil(double x) 返回不小于x的最小整数<Finish/></txt><txt ptr="0xa890d5a0" next="0xa890d630" prev="0xa890d510" upper="0xa8902124" lower="(nil)">double floor(double x)  返回不大于x的最大整数<Finish/></txt><txt ptr="0xa890d630" next="0xa890d6c0" prev="0xa890d5a0" upper="0xa8902124" lower="(nil)">7. 标准化浮点数<Finish/></txt><txt ptr="0xa890d6c0" next="0xa890d750" prev="0xa890d630" upper="0xa8902124" lower="(nil)">double frexp(double value,int *eptr)   <Finish/></txt><txt ptr="0xa890d750" next="0xa890d7e0" prev="0xa890d6c0" upper="0xa8902124" lower="(nil)">返回value=x*2n中x的值,n存贮在eptr中<Finish/></txt><txt ptr="0xa890d7e0" next="0xa890d870" prev="0xa890d750" upper="0xa8902124" lower="(nil)">double ldexp(double value,int exp);    <Finish/></txt><txt ptr="0xa890d870" next="0xa890d900" prev="0xa890d7e0" upper="0xa8902124" lower="(nil)">返回value*2exp的值<Finish/></txt><txt ptr="0xa890d900" next="0xa890d990" prev="0xa890d870" upper="0xa8902124" lower="(nil)">8. 随机数<Finish/></txt><txt ptr="0xa890d990" next="0xa890da20" prev="0xa890d900" upper="0xa8902124" lower="(nil)">void   srand(unsigned seed)     初始化随机数发生器<Finish/></txt><txt ptr="0xa890da20" next="0xa890dab0" prev="0xa890d990" upper="0xa8902124" lower="(nil)">int    rand()      产生一个随机数并返回这个数<Finish/></txt><txt ptr="0xa890dab0" next="0xa890db40" prev="0xa890da20" upper="0xa8902124" lower="(nil)">double poly(double x,int n,double c[]) 从参数产生一个多项式<Finish/></txt><txt ptr="0xa890db40" next="0xa890dbd0" prev="0xa890dab0" upper="0xa8902124" lower="(nil)"><Finish/></txt><txt ptr="0xa890dbd0" next="0xa890dc60" prev="0xa890db40" upper="0xa8902124" lower="(nil)">9. 取整与取余<Finish/></txt><txt ptr="0xa890dc60" next="0xa890dcf0" prev="0xa890dbd0" upper="0xa8902124" lower="(nil)"><Finish/></txt><txt ptr="0xa890dcf0" next="0xa890dd80" prev="0xa890dc60" upper="0xa8902124" lower="(nil)">double modf(double value,double *iptr) 将双精度数value分解成尾数和阶<Finish/></txt><txt ptr="0xa890dd80" next="0xa890de10" prev="0xa890dcf0" upper="0xa8902124" lower="(nil)">double fmod(double x,double y)           返回x/y的余数，即两参数相除的余数<Finish/></txt><txt ptr="0xa890de10" next="0xa890dea0" prev="0xa890dd80" upper="0xa8902124" lower="(nil)">double frexp(double value,int *eptr)     将双精度数value分成尾数和阶<Finish/></txt><txt ptr="0xa890dea0" next="0xa890df30" prev="0xa890de10" upper="0xa8902124" lower="(nil)"><Finish/></txt><txt ptr="0xa890df30" next="0xa88ee2d4" prev="0xa890dea0" upper="0xa8902124" lower="(nil)">参考资料<Finish/></txt><txt ptr="0xa88ee2d4" next="0xa88ee364" prev="0xa890df30" upper="0xa8902124" lower="(nil)">吉大模板<Finish/></txt><txt ptr="0xa88ee364" next="0xa88ee3f4" prev="0xa88ee2d4" upper="0xa8902124" lower="(nil)">NENUCS模板<Finish/></txt><txt ptr="0xa88ee3f4" next="(nil)" prev="0xa88ee364" upper="0xa8902124" lower="(nil)">NENUCS 张某人的模板<Finish/></txt></body></column><column ptr="0xa6c039fc" next="(nil)" prev="0xa6c03a60" upper="0xa99bc900" lower="0xa89020c4"><body ptr="0xa89020c4" next="(nil)" prev="(nil)" upper="0xa6c039fc" lower="0xa88ee484"><txt ptr="0xa88ee484" next="0xa88ee514" prev="(nil)" upper="0xa89020c4" lower="(nil)">NENUCS 赵小舟的模板<Finish/></txt><txt ptr="0xa88ee514" next="0xa88ee5a4" prev="0xa88ee484" upper="0xa89020c4" lower="(nil)">历年来国家集训队论文<Finish/></txt><txt ptr="0xa88ee5a4" next="0xa88ee634" prev="0xa88ee514" upper="0xa89020c4" lower="(nil)">wiki http://en.wikipedia.org/wiki/Main_Page§<Finish/></txt><txt ptr="0xa88ee634" next="(nil)" prev="0xa88ee5a4" upper="0xa89020c4" lower="(nil)"><Finish/></txt></body></column></section></body><footer ptr="0xa99864e4" next="(nil)" prev="0xa89023c4" upper="0xa9996988" lower="0xa8945138"><txt ptr="0xa8945138" next="0xa8944f44" prev="(nil)" upper="0xa99864e4" lower="(nil)"><anchored><fly ptr="0xa262628" next="(nil)" prev="(nil)" upper="(nil)" lower="0xa89450a8"><txt ptr="0xa89450a8" next="0xa8945018" prev="(nil)" upper="0xa262628" lower="(nil)"><Text nLength="0" nType="POR_PARA"/><LineBreak/><Finish/></txt><txt ptr="0xa8945018" next="(nil)" prev="0xa89450a8" upper="0xa262628" lower="(nil)">*<Special nLength="1" nType="POR_FLD" rText="5"/><LineBreak/><Special nLength="0" nType="POR_FLD" rText="8"/><LineBreak/><Finish/></txt></fly></anchored>V<Finish/></txt><txt ptr="0xa8944f44" next="(nil)" prev="0xa8945138" upper="0xa99864e4" lower="(nil)">er 04make by tiankonguse <Finish/></txt></footer></page></root>
