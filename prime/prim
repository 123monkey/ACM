问题：求小的n的素数的精确个数
(也可以把素数表保存下来或者快速判断一个数是不是素数)。
素数：因子只有1和本身的数。
基本方法：
	 从1开始，一个一个的判断这个数除了1和本身是否还有其它因子。
	 判断一个数n是不是素数，只需要判断出从2到n-1都不是n的因子即可。
	 复杂度: O(n^2)
	 正确性分析：这个算法是从上面素数的定义找的，所以正确性可以保证。
	 复杂度分析： 每个数需要判断是不是素数，判断一个数n是不是素数需要至少O(n)次。所以综合复杂度是 O(n^2)
	
正向优化.
	 从1开始，一个一个的判断这个数除了1和本身是否还有其它因子。
	 判断一个数 n 是不是素数， 只需要判断小于n的素数是不是n的因子即可。
	 复杂度： O(n^2/log(n))
	 正确性分析： 判断一个数n是不是素数时，我们只考虑小于n的素数。因为假设一个合数m是n的因子，则m的一个素因子一定也是n的因子，所以正确性可以保证
	 复杂度分析： 判断一个数n是不是素数时，我们只判断了小于n的素数的个数 pi(n)次，而pi(n) = O(n/log(n)), 故复杂度为 O(n^2/log(n))
	
逆向优化
	 把所有数字标记为素数。
	 从2开始查找第一个被标记为素数的数字，记为找到的一个素数。
	 把这个找到的素数的所有公倍数(忽略自己)标记为非素数。
	 直到查找到最后一个。
	 估计复杂度： O(n log(n))
	 正确性分析： 当一个数字被标记为非素数时可以理解，找到因子了; 对于找到的第一个被标记为素数的数字为什么是素书呢? 其实也很好理解,可以看到真正的素数一定没有被标记为非素数,然后那些未标记的数一个也不是第一个数的因子，那自然小于第一个数的素数都不是这个数的因子，所以正确性可以保证。
	 估计复杂度分析: 
	首先非素数，我们O(1) 判断，所以对于非素数的复杂度是 O(n - n/log(n))
	对于素数m，我们会循环 这个素数的公倍数的个数次，我们可以简单的理解为 n/m 次。
	即 O(n/2 + n/3 + n/5 + n/7 + n/11 + ... + n/n) 
	=O(n ( 1/2 + 1/3 + 1/7 + 1/11 + ... 1/n)) 
	=O(n log(n)) (证明暂时略，过几天补上)
	所以综合复杂度就是 O(n - n/log(n) + n log(n)) = O(n log(n))
	 精确复杂度: O(n log log(n))
	 精确复杂度分析： 实际上 O( 1/2 + 1/3 + 1/7 + 1/11 + .. + 1/n) = O(log log(n)),所以精确复杂度就是证明了。
	
再次逆向优化
	 在逆向优化的第三步，我们假设找到的素数是x, 我们可以从 x^2 开始标记非素数。
	 分析为什么: x的公倍数有 x*2, x*3, ..., x*(x-1) , x*x , ... 显然小于 x*x 的公倍数已经被标记为非素数了。
	 对于x*x 之后，每次应该加多少呢？ x 是奇数， x*x 也是奇数， 那么 x*x +x 一定是偶数，所以我们只需要每次家 2*x 即可。
	 对于 x*x 之后，我们是把 x*x + 2*k*x 标记为非素数，显然还是重复标记了好多数字。
	 那我们应该标记哪些数字呢？那我们就需要知道这次要标记的数字中哪些已经标记过，哪些未标记过。
	 这次我们准备标记的有 x*x, x*(x+2), x*(x+4) ..., 这个确实不好找到突破点，所以我们需要换种思路了。
	
新思路
	 我们假设已经找到了k个素数。现在该对i操作了。
	 i与这k个素数的乘积所的得到的数字都一定不是素数，所以我们标记了。
	 此时，我们找到的下一个未标记的一定是素数。
	 为什么呢？ 假设找到的下一个未标记的是m，但不是素数，则m有一个最小素因子k,以及另一个因子h(h=m/k, h>=k),则我们在h的时候就会把m标记的。
	 复杂度： O(n ?)
	 复杂度分析： 小于 k的素数的个数是 k/log(k),所以复杂度就是 3/log(3) + 4/log(4) + 5/log(5) + ... + n/log(n) = O( ? )
	 这样我们可以做什么呢？ 我们假设当前循环的数字是m, 有n=m/log(m)个素数。
	 当m不是素数的时候，在m的第一个素因子之后，会发生什么事呢？
	 假设m的最小素因子是k, 则 k*m 会被标记。 由于 m%k==0, 所以k之后的下一个素因子k2*m = k2 * m/k * k ,所以 k2 * m 有会在 k2*m/k 是被标记一次。实际上 k 之后的所有素数和m的乘积都会被再次标记。
	 既然会被再次标记，这次就没必要标记了。
	会不会由于这次未标记，而导致下次找到的第一个未标记的数字不是素数呢？答案是不会的。还是假设有这样的数字，在第一次遇到这样的不准确的数字m时，我们找到它的最小素因子k，然后会发现在 m/k 的时候，一定会把这个数字标记了。
	 这个优化对复杂度影响多大呢？
	 实际复杂度: 每个数字实际上只循环到它的最小素因子。我们用函数 minPrime(n) 表示吧。 然后循环次数是小于最小素因子的素数的个数。
	 即 minPrime(n)/log( minPrime(n) ). 而minPrime(n) 我们是非常小的，我们可以粗略估计为 minPrime(n)/log( minPrime(n) ) = O(1) 吧。
	 则综合复杂度是 n 吧。
	
	
10数字毫秒级算法
	网上流传一个 THE MEISSEL-LEHMER METHOD 算法，可谓厉害。
	我跑了一下，10亿数量级的仅仅跑了不到200毫秒。
	
